"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bson";
exports.ids = ["vendor-chunks/bson"];
exports.modules = {

/***/ "(ssr)/./node_modules/bson/lib/bson.cjs":
/*!****************************************!*\
  !*** ./node_modules/bson/lib/bson.cjs ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nfunction isAnyArrayBuffer(value) {\n    return [\n        \"[object ArrayBuffer]\",\n        \"[object SharedArrayBuffer]\"\n    ].includes(Object.prototype.toString.call(value));\n}\nfunction isUint8Array(value) {\n    return Object.prototype.toString.call(value) === \"[object Uint8Array]\";\n}\nfunction isRegExp(d) {\n    return Object.prototype.toString.call(d) === \"[object RegExp]\";\n}\nfunction isMap(d) {\n    return Object.prototype.toString.call(d) === \"[object Map]\";\n}\nfunction isDate(d) {\n    return Object.prototype.toString.call(d) === \"[object Date]\";\n}\nfunction defaultInspect(x, _options) {\n    return JSON.stringify(x, (k, v)=>{\n        if (typeof v === \"bigint\") {\n            return {\n                $numberLong: `${v}`\n            };\n        } else if (isMap(v)) {\n            return Object.fromEntries(v);\n        }\n        return v;\n    });\n}\nfunction getStylizeFunction(options) {\n    const stylizeExists = options != null && typeof options === \"object\" && \"stylize\" in options && typeof options.stylize === \"function\";\n    if (stylizeExists) {\n        return options.stylize;\n    }\n}\nconst BSON_MAJOR_VERSION = 6;\nconst BSON_INT32_MAX = 0x7fffffff;\nconst BSON_INT32_MIN = -0x80000000;\nconst BSON_INT64_MAX = Math.pow(2, 63) - 1;\nconst BSON_INT64_MIN = -Math.pow(2, 63);\nconst JS_INT_MAX = Math.pow(2, 53);\nconst JS_INT_MIN = -Math.pow(2, 53);\nconst BSON_DATA_NUMBER = 1;\nconst BSON_DATA_STRING = 2;\nconst BSON_DATA_OBJECT = 3;\nconst BSON_DATA_ARRAY = 4;\nconst BSON_DATA_BINARY = 5;\nconst BSON_DATA_UNDEFINED = 6;\nconst BSON_DATA_OID = 7;\nconst BSON_DATA_BOOLEAN = 8;\nconst BSON_DATA_DATE = 9;\nconst BSON_DATA_NULL = 10;\nconst BSON_DATA_REGEXP = 11;\nconst BSON_DATA_DBPOINTER = 12;\nconst BSON_DATA_CODE = 13;\nconst BSON_DATA_SYMBOL = 14;\nconst BSON_DATA_CODE_W_SCOPE = 15;\nconst BSON_DATA_INT = 16;\nconst BSON_DATA_TIMESTAMP = 17;\nconst BSON_DATA_LONG = 18;\nconst BSON_DATA_DECIMAL128 = 19;\nconst BSON_DATA_MIN_KEY = 0xff;\nconst BSON_DATA_MAX_KEY = 0x7f;\nconst BSON_BINARY_SUBTYPE_DEFAULT = 0;\nconst BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nconst BSONType = Object.freeze({\n    double: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    binData: 5,\n    undefined: 6,\n    objectId: 7,\n    bool: 8,\n    date: 9,\n    null: 10,\n    regex: 11,\n    dbPointer: 12,\n    javascript: 13,\n    symbol: 14,\n    javascriptWithScope: 15,\n    int: 16,\n    timestamp: 17,\n    long: 18,\n    decimal: 19,\n    minKey: -1,\n    maxKey: 127\n});\nclass BSONError extends Error {\n    get bsonError() {\n        return true;\n    }\n    get name() {\n        return \"BSONError\";\n    }\n    constructor(message, options){\n        super(message, options);\n    }\n    static isBSONError(value) {\n        return value != null && typeof value === \"object\" && \"bsonError\" in value && value.bsonError === true && \"name\" in value && \"message\" in value && \"stack\" in value;\n    }\n}\nclass BSONVersionError extends BSONError {\n    get name() {\n        return \"BSONVersionError\";\n    }\n    constructor(){\n        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.x.x`);\n    }\n}\nclass BSONRuntimeError extends BSONError {\n    get name() {\n        return \"BSONRuntimeError\";\n    }\n    constructor(message){\n        super(message);\n    }\n}\nconst FIRST_BIT = 0x80;\nconst FIRST_TWO_BITS = 0xc0;\nconst FIRST_THREE_BITS = 0xe0;\nconst FIRST_FOUR_BITS = 0xf0;\nconst FIRST_FIVE_BITS = 0xf8;\nconst TWO_BIT_CHAR = 0xc0;\nconst THREE_BIT_CHAR = 0xe0;\nconst FOUR_BIT_CHAR = 0xf0;\nconst CONTINUING_CHAR = 0x80;\nfunction validateUtf8(bytes, start, end) {\n    let continuation = 0;\n    for(let i = start; i < end; i += 1){\n        const byte = bytes[i];\n        if (continuation) {\n            if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {\n                return false;\n            }\n            continuation -= 1;\n        } else if (byte & FIRST_BIT) {\n            if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {\n                continuation = 1;\n            } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {\n                continuation = 2;\n            } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {\n                continuation = 3;\n            } else {\n                return false;\n            }\n        }\n    }\n    return !continuation;\n}\nfunction tryLatin(uint8array, start, end) {\n    if (uint8array.length === 0) {\n        return \"\";\n    }\n    const stringByteLength = end - start;\n    if (stringByteLength === 0) {\n        return \"\";\n    }\n    if (stringByteLength > 20) {\n        return null;\n    }\n    if (stringByteLength === 1 && uint8array[start] < 128) {\n        return String.fromCharCode(uint8array[start]);\n    }\n    if (stringByteLength === 2 && uint8array[start] < 128 && uint8array[start + 1] < 128) {\n        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]);\n    }\n    if (stringByteLength === 3 && uint8array[start] < 128 && uint8array[start + 1] < 128 && uint8array[start + 2] < 128) {\n        return String.fromCharCode(uint8array[start]) + String.fromCharCode(uint8array[start + 1]) + String.fromCharCode(uint8array[start + 2]);\n    }\n    const latinBytes = [];\n    for(let i = start; i < end; i++){\n        const byte = uint8array[i];\n        if (byte > 127) {\n            return null;\n        }\n        latinBytes.push(byte);\n    }\n    return String.fromCharCode(...latinBytes);\n}\nfunction nodejsMathRandomBytes(byteLength) {\n    return nodeJsByteUtils.fromNumberArray(Array.from({\n        length: byteLength\n    }, ()=>Math.floor(Math.random() * 256)));\n}\nconst nodejsRandomBytes = (()=>{\n    try {\n        return (__webpack_require__(/*! crypto */ \"crypto\").randomBytes);\n    } catch  {\n        return nodejsMathRandomBytes;\n    }\n})();\nconst nodeJsByteUtils = {\n    toLocalBufferType (potentialBuffer) {\n        if (Buffer.isBuffer(potentialBuffer)) {\n            return potentialBuffer;\n        }\n        if (ArrayBuffer.isView(potentialBuffer)) {\n            return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n        }\n        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);\n        if (stringTag === \"ArrayBuffer\" || stringTag === \"SharedArrayBuffer\" || stringTag === \"[object ArrayBuffer]\" || stringTag === \"[object SharedArrayBuffer]\") {\n            return Buffer.from(potentialBuffer);\n        }\n        throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);\n    },\n    allocate (size) {\n        return Buffer.alloc(size);\n    },\n    equals (a, b) {\n        return nodeJsByteUtils.toLocalBufferType(a).equals(b);\n    },\n    fromNumberArray (array) {\n        return Buffer.from(array);\n    },\n    fromBase64 (base64) {\n        return Buffer.from(base64, \"base64\");\n    },\n    toBase64 (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"base64\");\n    },\n    fromISO88591 (codePoints) {\n        return Buffer.from(codePoints, \"binary\");\n    },\n    toISO88591 (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"binary\");\n    },\n    fromHex (hex) {\n        return Buffer.from(hex, \"hex\");\n    },\n    toHex (buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString(\"hex\");\n    },\n    fromUTF8 (text) {\n        return Buffer.from(text, \"utf8\");\n    },\n    toUTF8 (buffer, start, end, fatal) {\n        const basicLatin = end - start <= 20 ? tryLatin(buffer, start, end) : null;\n        if (basicLatin != null) {\n            return basicLatin;\n        }\n        const string = nodeJsByteUtils.toLocalBufferType(buffer).toString(\"utf8\", start, end);\n        if (fatal) {\n            for(let i = 0; i < string.length; i++){\n                if (string.charCodeAt(i) === 0xfffd) {\n                    if (!validateUtf8(buffer, start, end)) {\n                        throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n                    }\n                    break;\n                }\n            }\n        }\n        return string;\n    },\n    utf8ByteLength (input) {\n        return Buffer.byteLength(input, \"utf8\");\n    },\n    encodeUTF8Into (buffer, source, byteOffset) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, \"utf8\");\n    },\n    randomBytes: nodejsRandomBytes\n};\nfunction isReactNative() {\n    const { navigator } = globalThis;\n    return typeof navigator === \"object\" && navigator.product === \"ReactNative\";\n}\nfunction webMathRandomBytes(byteLength) {\n    if (byteLength < 0) {\n        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);\n    }\n    return webByteUtils.fromNumberArray(Array.from({\n        length: byteLength\n    }, ()=>Math.floor(Math.random() * 256)));\n}\nconst webRandomBytes = (()=>{\n    const { crypto } = globalThis;\n    if (crypto != null && typeof crypto.getRandomValues === \"function\") {\n        return (byteLength)=>{\n            return crypto.getRandomValues(webByteUtils.allocate(byteLength));\n        };\n    } else {\n        if (isReactNative()) {\n            const { console } = globalThis;\n            console?.warn?.(\"BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.\");\n        }\n        return webMathRandomBytes;\n    }\n})();\nconst HEX_DIGIT = /(\\d|[a-f])/i;\nconst webByteUtils = {\n    toLocalBufferType (potentialUint8array) {\n        const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);\n        if (stringTag === \"Uint8Array\") {\n            return potentialUint8array;\n        }\n        if (ArrayBuffer.isView(potentialUint8array)) {\n            return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));\n        }\n        if (stringTag === \"ArrayBuffer\" || stringTag === \"SharedArrayBuffer\" || stringTag === \"[object ArrayBuffer]\" || stringTag === \"[object SharedArrayBuffer]\") {\n            return new Uint8Array(potentialUint8array);\n        }\n        throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);\n    },\n    allocate (size) {\n        if (typeof size !== \"number\") {\n            throw new TypeError(`The \"size\" argument must be of type number. Received ${String(size)}`);\n        }\n        return new Uint8Array(size);\n    },\n    equals (a, b) {\n        if (a.byteLength !== b.byteLength) {\n            return false;\n        }\n        for(let i = 0; i < a.byteLength; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    fromNumberArray (array) {\n        return Uint8Array.from(array);\n    },\n    fromBase64 (base64) {\n        return Uint8Array.from(atob(base64), (c)=>c.charCodeAt(0));\n    },\n    toBase64 (uint8array) {\n        return btoa(webByteUtils.toISO88591(uint8array));\n    },\n    fromISO88591 (codePoints) {\n        return Uint8Array.from(codePoints, (c)=>c.charCodeAt(0) & 0xff);\n    },\n    toISO88591 (uint8array) {\n        return Array.from(Uint16Array.from(uint8array), (b)=>String.fromCharCode(b)).join(\"\");\n    },\n    fromHex (hex) {\n        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);\n        const buffer = [];\n        for(let i = 0; i < evenLengthHex.length; i += 2){\n            const firstDigit = evenLengthHex[i];\n            const secondDigit = evenLengthHex[i + 1];\n            if (!HEX_DIGIT.test(firstDigit)) {\n                break;\n            }\n            if (!HEX_DIGIT.test(secondDigit)) {\n                break;\n            }\n            const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);\n            buffer.push(hexDigit);\n        }\n        return Uint8Array.from(buffer);\n    },\n    toHex (uint8array) {\n        return Array.from(uint8array, (byte)=>byte.toString(16).padStart(2, \"0\")).join(\"\");\n    },\n    fromUTF8 (text) {\n        return new TextEncoder().encode(text);\n    },\n    toUTF8 (uint8array, start, end, fatal) {\n        const basicLatin = end - start <= 20 ? tryLatin(uint8array, start, end) : null;\n        if (basicLatin != null) {\n            return basicLatin;\n        }\n        if (fatal) {\n            try {\n                return new TextDecoder(\"utf8\", {\n                    fatal\n                }).decode(uint8array.slice(start, end));\n            } catch (cause) {\n                throw new BSONError(\"Invalid UTF-8 string in BSON document\", {\n                    cause\n                });\n            }\n        }\n        return new TextDecoder(\"utf8\", {\n            fatal\n        }).decode(uint8array.slice(start, end));\n    },\n    utf8ByteLength (input) {\n        return webByteUtils.fromUTF8(input).byteLength;\n    },\n    encodeUTF8Into (buffer, source, byteOffset) {\n        const bytes = webByteUtils.fromUTF8(source);\n        buffer.set(bytes, byteOffset);\n        return bytes.byteLength;\n    },\n    randomBytes: webRandomBytes\n};\nconst hasGlobalBuffer = typeof Buffer === \"function\" && Buffer.prototype?._isBuffer !== true;\nconst ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;\nclass BSONDataView extends DataView {\n    static fromUint8Array(input) {\n        return new DataView(input.buffer, input.byteOffset, input.byteLength);\n    }\n}\nclass BSONValue {\n    get [Symbol.for(\"@@mdb.bson.version\")]() {\n        return BSON_MAJOR_VERSION;\n    }\n    [Symbol.for(\"nodejs.util.inspect.custom\")](depth, options, inspect) {\n        return this.inspect(depth, options, inspect);\n    }\n}\nclass Binary extends BSONValue {\n    get _bsontype() {\n        return \"Binary\";\n    }\n    constructor(buffer, subType){\n        super();\n        if (!(buffer == null) && typeof buffer === \"string\" && !ArrayBuffer.isView(buffer) && !isAnyArrayBuffer(buffer) && !Array.isArray(buffer)) {\n            throw new BSONError(\"Binary can only be constructed from Uint8Array or number[]\");\n        }\n        this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n        if (buffer == null) {\n            this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);\n            this.position = 0;\n        } else {\n            this.buffer = Array.isArray(buffer) ? ByteUtils.fromNumberArray(buffer) : ByteUtils.toLocalBufferType(buffer);\n            this.position = this.buffer.byteLength;\n        }\n    }\n    put(byteValue) {\n        if (typeof byteValue === \"string\" && byteValue.length !== 1) {\n            throw new BSONError(\"only accepts single character String\");\n        } else if (typeof byteValue !== \"number\" && byteValue.length !== 1) throw new BSONError(\"only accepts single character Uint8Array or Array\");\n        let decodedByte;\n        if (typeof byteValue === \"string\") {\n            decodedByte = byteValue.charCodeAt(0);\n        } else if (typeof byteValue === \"number\") {\n            decodedByte = byteValue;\n        } else {\n            decodedByte = byteValue[0];\n        }\n        if (decodedByte < 0 || decodedByte > 255) {\n            throw new BSONError(\"only accepts number in a valid unsigned byte range 0-255\");\n        }\n        if (this.buffer.byteLength > this.position) {\n            this.buffer[this.position++] = decodedByte;\n        } else {\n            const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n            this.buffer[this.position++] = decodedByte;\n        }\n    }\n    write(sequence, offset) {\n        offset = typeof offset === \"number\" ? offset : this.position;\n        if (this.buffer.byteLength < offset + sequence.length) {\n            const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n        }\n        if (ArrayBuffer.isView(sequence)) {\n            this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);\n            this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n        } else if (typeof sequence === \"string\") {\n            throw new BSONError(\"input cannot be string\");\n        }\n    }\n    read(position, length) {\n        length = length && length > 0 ? length : this.position;\n        return this.buffer.slice(position, position + length);\n    }\n    value() {\n        return this.buffer.length === this.position ? this.buffer : this.buffer.subarray(0, this.position);\n    }\n    length() {\n        return this.position;\n    }\n    toJSON() {\n        return ByteUtils.toBase64(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === \"hex\") return ByteUtils.toHex(this.buffer);\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.buffer);\n        if (encoding === \"utf8\" || encoding === \"utf-8\") return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength, false);\n        return ByteUtils.toUTF8(this.buffer, 0, this.buffer.byteLength, false);\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        const base64String = ByteUtils.toBase64(this.buffer);\n        const subType = Number(this.sub_type).toString(16);\n        if (options.legacy) {\n            return {\n                $binary: base64String,\n                $type: subType.length === 1 ? \"0\" + subType : subType\n            };\n        }\n        return {\n            $binary: {\n                base64: base64String,\n                subType: subType.length === 1 ? \"0\" + subType : subType\n            }\n        };\n    }\n    toUUID() {\n        if (this.sub_type === Binary.SUBTYPE_UUID) {\n            return new UUID(this.buffer.slice(0, this.position));\n        }\n        throw new BSONError(`Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`);\n    }\n    static createFromHexString(hex, subType) {\n        return new Binary(ByteUtils.fromHex(hex), subType);\n    }\n    static createFromBase64(base64, subType) {\n        return new Binary(ByteUtils.fromBase64(base64), subType);\n    }\n    static fromExtendedJSON(doc, options) {\n        options = options || {};\n        let data;\n        let type;\n        if (\"$binary\" in doc) {\n            if (options.legacy && typeof doc.$binary === \"string\" && \"$type\" in doc) {\n                type = doc.$type ? parseInt(doc.$type, 16) : 0;\n                data = ByteUtils.fromBase64(doc.$binary);\n            } else {\n                if (typeof doc.$binary !== \"string\") {\n                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n                    data = ByteUtils.fromBase64(doc.$binary.base64);\n                }\n            }\n        } else if (\"$uuid\" in doc) {\n            type = 4;\n            data = UUID.bytesFromString(doc.$uuid);\n        }\n        if (!data) {\n            throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\n        }\n        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        const base64Arg = inspect(base64, options);\n        const subTypeArg = inspect(this.sub_type, options);\n        return `Binary.createFromBase64(${base64Arg}, ${subTypeArg})`;\n    }\n}\nBinary.BSON_BINARY_SUBTYPE_DEFAULT = 0;\nBinary.BUFFER_SIZE = 256;\nBinary.SUBTYPE_DEFAULT = 0;\nBinary.SUBTYPE_FUNCTION = 1;\nBinary.SUBTYPE_BYTE_ARRAY = 2;\nBinary.SUBTYPE_UUID_OLD = 3;\nBinary.SUBTYPE_UUID = 4;\nBinary.SUBTYPE_MD5 = 5;\nBinary.SUBTYPE_ENCRYPTED = 6;\nBinary.SUBTYPE_COLUMN = 7;\nBinary.SUBTYPE_USER_DEFINED = 128;\nconst UUID_BYTE_LENGTH = 16;\nconst UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;\nconst UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;\nclass UUID extends Binary {\n    constructor(input){\n        let bytes;\n        if (input == null) {\n            bytes = UUID.generate();\n        } else if (input instanceof UUID) {\n            bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));\n        } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n            bytes = ByteUtils.toLocalBufferType(input);\n        } else if (typeof input === \"string\") {\n            bytes = UUID.bytesFromString(input);\n        } else {\n            throw new BSONError(\"Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).\");\n        }\n        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n    }\n    toHexString(includeDashes = true) {\n        if (includeDashes) {\n            return [\n                ByteUtils.toHex(this.buffer.subarray(0, 4)),\n                ByteUtils.toHex(this.buffer.subarray(4, 6)),\n                ByteUtils.toHex(this.buffer.subarray(6, 8)),\n                ByteUtils.toHex(this.buffer.subarray(8, 10)),\n                ByteUtils.toHex(this.buffer.subarray(10, 16))\n            ].join(\"-\");\n        }\n        return ByteUtils.toHex(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === \"hex\") return ByteUtils.toHex(this.id);\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.id);\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (!otherId) {\n            return false;\n        }\n        if (otherId instanceof UUID) {\n            return ByteUtils.equals(otherId.id, this.id);\n        }\n        try {\n            return ByteUtils.equals(new UUID(otherId).id, this.id);\n        } catch  {\n            return false;\n        }\n    }\n    toBinary() {\n        return new Binary(this.id, Binary.SUBTYPE_UUID);\n    }\n    static generate() {\n        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);\n        bytes[6] = bytes[6] & 0x0f | 0x40;\n        bytes[8] = bytes[8] & 0x3f | 0x80;\n        return bytes;\n    }\n    static isValid(input) {\n        if (!input) {\n            return false;\n        }\n        if (typeof input === \"string\") {\n            return UUID.isValidUUIDString(input);\n        }\n        if (isUint8Array(input)) {\n            return input.byteLength === UUID_BYTE_LENGTH;\n        }\n        return input._bsontype === \"Binary\" && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;\n    }\n    static createFromHexString(hexString) {\n        const buffer = UUID.bytesFromString(hexString);\n        return new UUID(buffer);\n    }\n    static createFromBase64(base64) {\n        return new UUID(ByteUtils.fromBase64(base64));\n    }\n    static bytesFromString(representation) {\n        if (!UUID.isValidUUIDString(representation)) {\n            throw new BSONError(\"UUID string representation must be 32 hex digits or canonical hyphenated representation\");\n        }\n        return ByteUtils.fromHex(representation.replace(/-/g, \"\"));\n    }\n    static isValidUUIDString(representation) {\n        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new UUID(${inspect(this.toHexString(), options)})`;\n    }\n}\nclass Code extends BSONValue {\n    get _bsontype() {\n        return \"Code\";\n    }\n    constructor(code, scope){\n        super();\n        this.code = code.toString();\n        this.scope = scope ?? null;\n    }\n    toJSON() {\n        if (this.scope != null) {\n            return {\n                code: this.code,\n                scope: this.scope\n            };\n        }\n        return {\n            code: this.code\n        };\n    }\n    toExtendedJSON() {\n        if (this.scope) {\n            return {\n                $code: this.code,\n                $scope: this.scope\n            };\n        }\n        return {\n            $code: this.code\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new Code(doc.$code, doc.$scope);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        let parametersString = inspect(this.code, options);\n        const multiLineFn = parametersString.includes(\"\\n\");\n        if (this.scope != null) {\n            parametersString += `,${multiLineFn ? \"\\n\" : \" \"}${inspect(this.scope, options)}`;\n        }\n        const endingNewline = multiLineFn && this.scope === null;\n        return `new Code(${multiLineFn ? \"\\n\" : \"\"}${parametersString}${endingNewline ? \"\\n\" : \"\"})`;\n    }\n}\nfunction isDBRefLike(value) {\n    return value != null && typeof value === \"object\" && \"$id\" in value && value.$id != null && \"$ref\" in value && typeof value.$ref === \"string\" && (!(\"$db\" in value) || \"$db\" in value && typeof value.$db === \"string\");\n}\nclass DBRef extends BSONValue {\n    get _bsontype() {\n        return \"DBRef\";\n    }\n    constructor(collection, oid, db, fields){\n        super();\n        const parts = collection.split(\".\");\n        if (parts.length === 2) {\n            db = parts.shift();\n            collection = parts.shift();\n        }\n        this.collection = collection;\n        this.oid = oid;\n        this.db = db;\n        this.fields = fields || {};\n    }\n    get namespace() {\n        return this.collection;\n    }\n    set namespace(value) {\n        this.collection = value;\n    }\n    toJSON() {\n        const o = Object.assign({\n            $ref: this.collection,\n            $id: this.oid\n        }, this.fields);\n        if (this.db != null) o.$db = this.db;\n        return o;\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        let o = {\n            $ref: this.collection,\n            $id: this.oid\n        };\n        if (options.legacy) {\n            return o;\n        }\n        if (this.db) o.$db = this.db;\n        o = Object.assign(o, this.fields);\n        return o;\n    }\n    static fromExtendedJSON(doc) {\n        const copy = Object.assign({}, doc);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const args = [\n            inspect(this.namespace, options),\n            inspect(this.oid, options),\n            ...this.db ? [\n                inspect(this.db, options)\n            ] : [],\n            ...Object.keys(this.fields).length > 0 ? [\n                inspect(this.fields, options)\n            ] : []\n        ];\n        args[1] = inspect === defaultInspect ? `new ObjectId(${args[1]})` : args[1];\n        return `new DBRef(${args.join(\", \")})`;\n    }\n}\nlet wasm = undefined;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\n        0,\n        97,\n        115,\n        109,\n        1,\n        0,\n        0,\n        0,\n        1,\n        13,\n        2,\n        96,\n        0,\n        1,\n        127,\n        96,\n        4,\n        127,\n        127,\n        127,\n        127,\n        1,\n        127,\n        3,\n        7,\n        6,\n        0,\n        1,\n        1,\n        1,\n        1,\n        1,\n        6,\n        6,\n        1,\n        127,\n        1,\n        65,\n        0,\n        11,\n        7,\n        50,\n        6,\n        3,\n        109,\n        117,\n        108,\n        0,\n        1,\n        5,\n        100,\n        105,\n        118,\n        95,\n        115,\n        0,\n        2,\n        5,\n        100,\n        105,\n        118,\n        95,\n        117,\n        0,\n        3,\n        5,\n        114,\n        101,\n        109,\n        95,\n        115,\n        0,\n        4,\n        5,\n        114,\n        101,\n        109,\n        95,\n        117,\n        0,\n        5,\n        8,\n        103,\n        101,\n        116,\n        95,\n        104,\n        105,\n        103,\n        104,\n        0,\n        0,\n        10,\n        191,\n        1,\n        6,\n        4,\n        0,\n        35,\n        0,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        126,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        127,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        128,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        129,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11,\n        36,\n        1,\n        1,\n        126,\n        32,\n        0,\n        173,\n        32,\n        1,\n        173,\n        66,\n        32,\n        134,\n        132,\n        32,\n        2,\n        173,\n        32,\n        3,\n        173,\n        66,\n        32,\n        134,\n        132,\n        130,\n        34,\n        4,\n        66,\n        32,\n        135,\n        167,\n        36,\n        0,\n        32,\n        4,\n        167,\n        11\n    ])), {}).exports;\n} catch  {}\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst INT_CACHE = {};\nconst UINT_CACHE = {};\nconst MAX_INT64_STRING_LENGTH = 20;\nconst DECIMAL_REG_EX = /^(\\+?0|(\\+|-)?[1-9][0-9]*)$/;\nclass Long extends BSONValue {\n    get _bsontype() {\n        return \"Long\";\n    }\n    get __isLong__() {\n        return true;\n    }\n    constructor(low = 0, high, unsigned){\n        super();\n        if (typeof low === \"bigint\") {\n            Object.assign(this, Long.fromBigInt(low, !!high));\n        } else if (typeof low === \"string\") {\n            Object.assign(this, Long.fromString(low, !!high));\n        } else {\n            this.low = low | 0;\n            this.high = high | 0;\n            this.unsigned = !!unsigned;\n        }\n    }\n    static fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    static fromInt(value, unsigned) {\n        let obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if (cache = 0 <= value && value < 256) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n            if (cache) UINT_CACHE[value] = obj;\n            return obj;\n        } else {\n            value |= 0;\n            if (cache = -128 <= value && value < 128) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj) return cachedObj;\n            }\n            obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache) INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    static fromNumber(value, unsigned) {\n        if (isNaN(value)) return unsigned ? Long.UZERO : Long.ZERO;\n        if (unsigned) {\n            if (value < 0) return Long.UZERO;\n            if (value >= TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE;\n        } else {\n            if (value <= -TWO_PWR_63_DBL) return Long.MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL) return Long.MAX_VALUE;\n        }\n        if (value < 0) return Long.fromNumber(-value, unsigned).neg();\n        return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n    }\n    static fromBigInt(value, unsigned) {\n        return Long.fromString(value.toString(), unsigned);\n    }\n    static fromString(str, unsigned, radix) {\n        if (str.length === 0) throw new BSONError(\"empty string\");\n        if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\") return Long.ZERO;\n        if (typeof unsigned === \"number\") {\n            radix = unsigned, unsigned = false;\n        } else {\n            unsigned = !!unsigned;\n        }\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw new BSONError(\"radix\");\n        let p;\n        if ((p = str.indexOf(\"-\")) > 0) throw new BSONError(\"interior hyphen\");\n        else if (p === 0) {\n            return Long.fromString(str.substring(1), unsigned, radix).neg();\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 8));\n        let result = Long.ZERO;\n        for(let i = 0; i < str.length; i += 8){\n            const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                const power = Long.fromNumber(Math.pow(radix, size));\n                result = result.mul(power).add(Long.fromNumber(value));\n            } else {\n                result = result.mul(radixToPower);\n                result = result.add(Long.fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    static fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    }\n    static fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n    }\n    static fromBytesBE(bytes, unsigned) {\n        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n    }\n    static isLong(value) {\n        return value != null && typeof value === \"object\" && \"__isLong__\" in value && value.__isLong__ === true;\n    }\n    static fromValue(val, unsigned) {\n        if (typeof val === \"number\") return Long.fromNumber(val, unsigned);\n        if (typeof val === \"string\") return Long.fromString(val, unsigned);\n        return Long.fromBits(val.low, val.high, typeof unsigned === \"boolean\" ? unsigned : val.unsigned);\n    }\n    add(addend) {\n        if (!Long.isLong(addend)) addend = Long.fromValue(addend);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = addend.high >>> 16;\n        const b32 = addend.high & 0xffff;\n        const b16 = addend.low >>> 16;\n        const b00 = addend.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 + b48;\n        c48 &= 0xffff;\n        return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    }\n    and(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    }\n    compare(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        if (this.eq(other)) return 0;\n        const thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg) return -1;\n        if (!thisNeg && otherNeg) return 1;\n        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n    }\n    comp(other) {\n        return this.compare(other);\n    }\n    divide(divisor) {\n        if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n        if (divisor.isZero()) throw new BSONError(\"division by zero\");\n        if (wasm) {\n            if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n                return this;\n            }\n            const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO;\n        let approx, rem, res;\n        if (!this.unsigned) {\n            if (this.eq(Long.MIN_VALUE)) {\n                if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE)) return Long.MIN_VALUE;\n                else if (divisor.eq(Long.MIN_VALUE)) return Long.ONE;\n                else {\n                    const halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(Long.ZERO)) {\n                        return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n                    } else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            } else if (divisor.eq(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative()) return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n            res = Long.ZERO;\n        } else {\n            if (!divisor.unsigned) divisor = divisor.toUnsigned();\n            if (divisor.gt(this)) return Long.UZERO;\n            if (divisor.gt(this.shru(1))) return Long.UONE;\n            res = Long.UZERO;\n        }\n        rem = this;\n        while(rem.gte(divisor)){\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n            const log2 = Math.ceil(Math.log(approx) / Math.LN2);\n            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            let approxRes = Long.fromNumber(approx);\n            let approxRem = approxRes.mul(divisor);\n            while(approxRem.isNegative() || approxRem.gt(rem)){\n                approx -= delta;\n                approxRes = Long.fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            }\n            if (approxRes.isZero()) approxRes = Long.ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    }\n    div(divisor) {\n        return this.divide(divisor);\n    }\n    equals(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n        return this.high === other.high && this.low === other.low;\n    }\n    eq(other) {\n        return this.equals(other);\n    }\n    getHighBits() {\n        return this.high;\n    }\n    getHighBitsUnsigned() {\n        return this.high >>> 0;\n    }\n    getLowBits() {\n        return this.low;\n    }\n    getLowBitsUnsigned() {\n        return this.low >>> 0;\n    }\n    getNumBitsAbs() {\n        if (this.isNegative()) {\n            return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        }\n        const val = this.high !== 0 ? this.high : this.low;\n        let bit;\n        for(bit = 31; bit > 0; bit--)if ((val & 1 << bit) !== 0) break;\n        return this.high !== 0 ? bit + 33 : bit + 1;\n    }\n    greaterThan(other) {\n        return this.comp(other) > 0;\n    }\n    gt(other) {\n        return this.greaterThan(other);\n    }\n    greaterThanOrEqual(other) {\n        return this.comp(other) >= 0;\n    }\n    gte(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    ge(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    isEven() {\n        return (this.low & 1) === 0;\n    }\n    isNegative() {\n        return !this.unsigned && this.high < 0;\n    }\n    isOdd() {\n        return (this.low & 1) === 1;\n    }\n    isPositive() {\n        return this.unsigned || this.high >= 0;\n    }\n    isZero() {\n        return this.high === 0 && this.low === 0;\n    }\n    lessThan(other) {\n        return this.comp(other) < 0;\n    }\n    lt(other) {\n        return this.lessThan(other);\n    }\n    lessThanOrEqual(other) {\n        return this.comp(other) <= 0;\n    }\n    lte(other) {\n        return this.lessThanOrEqual(other);\n    }\n    modulo(divisor) {\n        if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n        if (wasm) {\n            const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    }\n    mod(divisor) {\n        return this.modulo(divisor);\n    }\n    rem(divisor) {\n        return this.modulo(divisor);\n    }\n    multiply(multiplier) {\n        if (this.isZero()) return Long.ZERO;\n        if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier);\n        if (wasm) {\n            const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (multiplier.isZero()) return Long.ZERO;\n        if (this.eq(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (multiplier.eq(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());\n            else return this.neg().mul(multiplier).neg();\n        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n        if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = multiplier.high >>> 16;\n        const b32 = multiplier.high & 0xffff;\n        const b16 = multiplier.low >>> 16;\n        const b00 = multiplier.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xffff;\n        return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n    }\n    mul(multiplier) {\n        return this.multiply(multiplier);\n    }\n    negate() {\n        if (!this.unsigned && this.eq(Long.MIN_VALUE)) return Long.MIN_VALUE;\n        return this.not().add(Long.ONE);\n    }\n    neg() {\n        return this.negate();\n    }\n    not() {\n        return Long.fromBits(~this.low, ~this.high, this.unsigned);\n    }\n    notEquals(other) {\n        return !this.equals(other);\n    }\n    neq(other) {\n        return this.notEquals(other);\n    }\n    ne(other) {\n        return this.notEquals(other);\n    }\n    or(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    }\n    shiftLeft(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);\n        else return Long.fromBits(0, this.low << numBits - 32, this.unsigned);\n    }\n    shl(numBits) {\n        return this.shiftLeft(numBits);\n    }\n    shiftRight(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        if ((numBits &= 63) === 0) return this;\n        else if (numBits < 32) return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);\n        else return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n    }\n    shr(numBits) {\n        return this.shiftRight(numBits);\n    }\n    shiftRightUnsigned(numBits) {\n        if (Long.isLong(numBits)) numBits = numBits.toInt();\n        numBits &= 63;\n        if (numBits === 0) return this;\n        else {\n            const high = this.high;\n            if (numBits < 32) {\n                const low = this.low;\n                return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n            } else if (numBits === 32) return Long.fromBits(high, 0, this.unsigned);\n            else return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);\n        }\n    }\n    shr_u(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    shru(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    subtract(subtrahend) {\n        if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    }\n    sub(subtrahend) {\n        return this.subtract(subtrahend);\n    }\n    toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    }\n    toNumber() {\n        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    }\n    toBytesLE() {\n        const hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            lo >>> 8 & 0xff,\n            lo >>> 16 & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            hi >>> 8 & 0xff,\n            hi >>> 16 & 0xff,\n            hi >>> 24\n        ];\n    }\n    toBytesBE() {\n        const hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            hi >>> 16 & 0xff,\n            hi >>> 8 & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            lo >>> 16 & 0xff,\n            lo >>> 8 & 0xff,\n            lo & 0xff\n        ];\n    }\n    toSigned() {\n        if (!this.unsigned) return this;\n        return Long.fromBits(this.low, this.high, false);\n    }\n    toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix) throw new BSONError(\"radix\");\n        if (this.isZero()) return \"0\";\n        if (this.isNegative()) {\n            if (this.eq(Long.MIN_VALUE)) {\n                const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            } else return \"-\" + this.neg().toString(radix);\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n        let rem = this;\n        let result = \"\";\n        while(true){\n            const remDiv = rem.div(radixToPower);\n            const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n            let digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) {\n                return digits + result;\n            } else {\n                while(digits.length < 6)digits = \"0\" + digits;\n                result = \"\" + digits + result;\n            }\n        }\n    }\n    toUnsigned() {\n        if (this.unsigned) return this;\n        return Long.fromBits(this.low, this.high, true);\n    }\n    xor(other) {\n        if (!Long.isLong(other)) other = Long.fromValue(other);\n        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    }\n    eqz() {\n        return this.isZero();\n    }\n    le(other) {\n        return this.lessThanOrEqual(other);\n    }\n    toExtendedJSON(options) {\n        if (options && options.relaxed) return this.toNumber();\n        return {\n            $numberLong: this.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const { useBigInt64 = false, relaxed = true } = {\n            ...options\n        };\n        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {\n            throw new BSONError(\"$numberLong string is too long\");\n        }\n        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {\n            throw new BSONError(`$numberLong string \"${doc.$numberLong}\" is in an invalid format`);\n        }\n        if (useBigInt64) {\n            const bigIntResult = BigInt(doc.$numberLong);\n            return BigInt.asIntN(64, bigIntResult);\n        }\n        const longResult = Long.fromString(doc.$numberLong);\n        if (relaxed) {\n            return longResult.toNumber();\n        }\n        return longResult;\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const longVal = inspect(this.toString(), options);\n        const unsignedVal = this.unsigned ? `, ${inspect(this.unsigned, options)}` : \"\";\n        return `new Long(${longVal}${unsignedVal})`;\n    }\n}\nLong.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\nLong.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);\nLong.ZERO = Long.fromInt(0);\nLong.UZERO = Long.fromInt(0, true);\nLong.ONE = Long.fromInt(1);\nLong.UONE = Long.fromInt(1, true);\nLong.NEG_ONE = Long.fromInt(-1);\nLong.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\nLong.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\nconst PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nconst PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nconst PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nconst EXPONENT_MAX = 6111;\nconst EXPONENT_MIN = -6176;\nconst EXPONENT_BIAS = 6176;\nconst MAX_DIGITS = 34;\nconst NAN_BUFFER = ByteUtils.fromNumberArray([\n    0x7c,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([\n    0xf8,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([\n    0x78,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00,\n    0x00\n].reverse());\nconst EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nconst COMBINATION_MASK = 0x1f;\nconst EXPONENT_MASK = 0x3fff;\nconst COMBINATION_INFINITY = 30;\nconst COMBINATION_NAN = 31;\nfunction isDigit(value) {\n    return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);\n    let _rem = Long.fromNumber(0);\n    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n        return {\n            quotient: value,\n            rem: _rem\n        };\n    }\n    for(let i = 0; i <= 3; i++){\n        _rem = _rem.shiftLeft(32);\n        _rem = _rem.add(new Long(value.parts[i], 0));\n        value.parts[i] = _rem.div(DIVISOR).low;\n        _rem = _rem.modulo(DIVISOR);\n    }\n    return {\n        quotient: value,\n        rem: _rem\n    };\n}\nfunction multiply64x2(left, right) {\n    if (!left && !right) {\n        return {\n            high: Long.fromNumber(0),\n            low: Long.fromNumber(0)\n        };\n    }\n    const leftHigh = left.shiftRightUnsigned(32);\n    const leftLow = new Long(left.getLowBits(), 0);\n    const rightHigh = right.shiftRightUnsigned(32);\n    const rightLow = new Long(right.getLowBits(), 0);\n    let productHigh = leftHigh.multiply(rightHigh);\n    let productMid = leftHigh.multiply(rightLow);\n    const productMid2 = leftLow.multiply(rightHigh);\n    let productLow = leftLow.multiply(rightLow);\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n    return {\n        high: productHigh,\n        low: productLow\n    };\n}\nfunction lessThan(left, right) {\n    const uhleft = left.high >>> 0;\n    const uhright = right.high >>> 0;\n    if (uhleft < uhright) {\n        return true;\n    } else if (uhleft === uhright) {\n        const ulleft = left.low >>> 0;\n        const ulright = right.low >>> 0;\n        if (ulleft < ulright) return true;\n    }\n    return false;\n}\nfunction invalidErr(string, message) {\n    throw new BSONError(`\"${string}\" is not a valid Decimal128 string - ${message}`);\n}\nclass Decimal128 extends BSONValue {\n    get _bsontype() {\n        return \"Decimal128\";\n    }\n    constructor(bytes){\n        super();\n        if (typeof bytes === \"string\") {\n            this.bytes = Decimal128.fromString(bytes).bytes;\n        } else if (isUint8Array(bytes)) {\n            if (bytes.byteLength !== 16) {\n                throw new BSONError(\"Decimal128 must take a Buffer of 16 bytes\");\n            }\n            this.bytes = bytes;\n        } else {\n            throw new BSONError(\"Decimal128 must take a Buffer or string\");\n        }\n    }\n    static fromString(representation) {\n        return Decimal128._fromString(representation, {\n            allowRounding: false\n        });\n    }\n    static fromStringWithRounding(representation) {\n        return Decimal128._fromString(representation, {\n            allowRounding: true\n        });\n    }\n    static _fromString(representation, options) {\n        let isNegative = false;\n        let sawSign = false;\n        let sawRadix = false;\n        let foundNonZero = false;\n        let significantDigits = 0;\n        let nDigitsRead = 0;\n        let nDigits = 0;\n        let radixPosition = 0;\n        let firstNonZero = 0;\n        const digits = [\n            0\n        ];\n        let nDigitsStored = 0;\n        let digitsInsert = 0;\n        let lastDigit = 0;\n        let exponent = 0;\n        let significandHigh = new Long(0, 0);\n        let significandLow = new Long(0, 0);\n        let biasedExponent = 0;\n        let index = 0;\n        if (representation.length >= 7000) {\n            throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        }\n        const stringMatch = representation.match(PARSE_STRING_REGEXP);\n        const infMatch = representation.match(PARSE_INF_REGEXP);\n        const nanMatch = representation.match(PARSE_NAN_REGEXP);\n        if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {\n            throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        }\n        if (stringMatch) {\n            const unsignedNumber = stringMatch[2];\n            const e = stringMatch[4];\n            const expSign = stringMatch[5];\n            const expNumber = stringMatch[6];\n            if (e && expNumber === undefined) invalidErr(representation, \"missing exponent power\");\n            if (e && unsignedNumber === undefined) invalidErr(representation, \"missing exponent base\");\n            if (e === undefined && (expSign || expNumber)) {\n                invalidErr(representation, \"missing e before exponent\");\n            }\n        }\n        if (representation[index] === \"+\" || representation[index] === \"-\") {\n            sawSign = true;\n            isNegative = representation[index++] === \"-\";\n        }\n        if (!isDigit(representation[index]) && representation[index] !== \".\") {\n            if (representation[index] === \"i\" || representation[index] === \"I\") {\n                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n            } else if (representation[index] === \"N\") {\n                return new Decimal128(NAN_BUFFER);\n            }\n        }\n        while(isDigit(representation[index]) || representation[index] === \".\"){\n            if (representation[index] === \".\") {\n                if (sawRadix) invalidErr(representation, \"contains multiple periods\");\n                sawRadix = true;\n                index = index + 1;\n                continue;\n            }\n            if (nDigitsStored < MAX_DIGITS) {\n                if (representation[index] !== \"0\" || foundNonZero) {\n                    if (!foundNonZero) {\n                        firstNonZero = nDigitsRead;\n                    }\n                    foundNonZero = true;\n                    digits[digitsInsert++] = parseInt(representation[index], 10);\n                    nDigitsStored = nDigitsStored + 1;\n                }\n            }\n            if (foundNonZero) nDigits = nDigits + 1;\n            if (sawRadix) radixPosition = radixPosition + 1;\n            nDigitsRead = nDigitsRead + 1;\n            index = index + 1;\n        }\n        if (sawRadix && !nDigitsRead) throw new BSONError(\"\" + representation + \" not a valid Decimal128 string\");\n        if (representation[index] === \"e\" || representation[index] === \"E\") {\n            const match = representation.substr(++index).match(EXPONENT_REGEX);\n            if (!match || !match[2]) return new Decimal128(NAN_BUFFER);\n            exponent = parseInt(match[0], 10);\n            index = index + match[0].length;\n        }\n        if (representation[index]) return new Decimal128(NAN_BUFFER);\n        if (!nDigitsStored) {\n            digits[0] = 0;\n            nDigits = 1;\n            nDigitsStored = 1;\n            significantDigits = 0;\n        } else {\n            lastDigit = nDigitsStored - 1;\n            significantDigits = nDigits;\n            if (significantDigits !== 1) {\n                while(representation[firstNonZero + significantDigits - 1 + Number(sawSign) + Number(sawRadix)] === \"0\"){\n                    significantDigits = significantDigits - 1;\n                }\n            }\n        }\n        if (exponent <= radixPosition && radixPosition > exponent + (1 << 14)) {\n            exponent = EXPONENT_MIN;\n        } else {\n            exponent = exponent - radixPosition;\n        }\n        while(exponent > EXPONENT_MAX){\n            lastDigit = lastDigit + 1;\n            if (lastDigit >= MAX_DIGITS) {\n                if (significantDigits === 0) {\n                    exponent = EXPONENT_MAX;\n                    break;\n                }\n                invalidErr(representation, \"overflow\");\n            }\n            exponent = exponent - 1;\n        }\n        if (options.allowRounding) {\n            while(exponent < EXPONENT_MIN || nDigitsStored < nDigits){\n                if (lastDigit === 0 && significantDigits < nDigitsStored) {\n                    exponent = EXPONENT_MIN;\n                    significantDigits = 0;\n                    break;\n                }\n                if (nDigitsStored < nDigits) {\n                    nDigits = nDigits - 1;\n                } else {\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                } else {\n                    const digitsString = digits.join(\"\");\n                    if (digitsString.match(/^0+$/)) {\n                        exponent = EXPONENT_MAX;\n                        break;\n                    }\n                    invalidErr(representation, \"overflow\");\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                let endOfString = nDigitsRead;\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                    endOfString = endOfString + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                let roundBit = 0;\n                if (roundDigit >= 5) {\n                    roundBit = 1;\n                    if (roundDigit === 5) {\n                        roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n                        for(let i = firstNonZero + lastDigit + 2; i < endOfString; i++){\n                            if (parseInt(representation[i], 10)) {\n                                roundBit = 1;\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (roundBit) {\n                    let dIdx = lastDigit;\n                    for(; dIdx >= 0; dIdx--){\n                        if (++digits[dIdx] > 9) {\n                            digits[dIdx] = 0;\n                            if (dIdx === 0) {\n                                if (exponent < EXPONENT_MAX) {\n                                    exponent = exponent + 1;\n                                    digits[dIdx] = 1;\n                                } else {\n                                    return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n                                }\n                            }\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        } else {\n            while(exponent < EXPONENT_MIN || nDigitsStored < nDigits){\n                if (lastDigit === 0) {\n                    if (significantDigits === 0) {\n                        exponent = EXPONENT_MIN;\n                        break;\n                    }\n                    invalidErr(representation, \"exponent underflow\");\n                }\n                if (nDigitsStored < nDigits) {\n                    if (representation[nDigits - 1 + Number(sawSign) + Number(sawRadix)] !== \"0\" && significantDigits !== 0) {\n                        invalidErr(representation, \"inexact rounding\");\n                    }\n                    nDigits = nDigits - 1;\n                } else {\n                    if (digits[lastDigit] !== 0) {\n                        invalidErr(representation, \"inexact rounding\");\n                    }\n                    lastDigit = lastDigit - 1;\n                }\n                if (exponent < EXPONENT_MAX) {\n                    exponent = exponent + 1;\n                } else {\n                    invalidErr(representation, \"overflow\");\n                }\n            }\n            if (lastDigit + 1 < significantDigits) {\n                if (sawRadix) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                if (sawSign) {\n                    firstNonZero = firstNonZero + 1;\n                }\n                const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n                if (roundDigit !== 0) {\n                    invalidErr(representation, \"inexact rounding\");\n                }\n            }\n        }\n        significandHigh = Long.fromNumber(0);\n        significandLow = Long.fromNumber(0);\n        if (significantDigits === 0) {\n            significandHigh = Long.fromNumber(0);\n            significandLow = Long.fromNumber(0);\n        } else if (lastDigit < 17) {\n            let dIdx = 0;\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            significandHigh = new Long(0, 0);\n            for(; dIdx <= lastDigit; dIdx++){\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        } else {\n            let dIdx = 0;\n            significandHigh = Long.fromNumber(digits[dIdx++]);\n            for(; dIdx <= lastDigit - 17; dIdx++){\n                significandHigh = significandHigh.multiply(Long.fromNumber(10));\n                significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n            }\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            for(; dIdx <= lastDigit; dIdx++){\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        const significand = multiply64x2(significandHigh, Long.fromString(\"100000000000000000\"));\n        significand.low = significand.low.add(significandLow);\n        if (lessThan(significand.low, significandLow)) {\n            significand.high = significand.high.add(Long.fromNumber(1));\n        }\n        biasedExponent = exponent + EXPONENT_BIAS;\n        const dec = {\n            low: Long.fromNumber(0),\n            high: Long.fromNumber(0)\n        };\n        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n            dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));\n        } else {\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));\n        }\n        dec.low = significand.low;\n        if (isNegative) {\n            dec.high = dec.high.or(Long.fromString(\"9223372036854775808\"));\n        }\n        const buffer = ByteUtils.allocate(16);\n        index = 0;\n        buffer[index++] = dec.low.low & 0xff;\n        buffer[index++] = dec.low.low >> 8 & 0xff;\n        buffer[index++] = dec.low.low >> 16 & 0xff;\n        buffer[index++] = dec.low.low >> 24 & 0xff;\n        buffer[index++] = dec.low.high & 0xff;\n        buffer[index++] = dec.low.high >> 8 & 0xff;\n        buffer[index++] = dec.low.high >> 16 & 0xff;\n        buffer[index++] = dec.low.high >> 24 & 0xff;\n        buffer[index++] = dec.high.low & 0xff;\n        buffer[index++] = dec.high.low >> 8 & 0xff;\n        buffer[index++] = dec.high.low >> 16 & 0xff;\n        buffer[index++] = dec.high.low >> 24 & 0xff;\n        buffer[index++] = dec.high.high & 0xff;\n        buffer[index++] = dec.high.high >> 8 & 0xff;\n        buffer[index++] = dec.high.high >> 16 & 0xff;\n        buffer[index++] = dec.high.high >> 24 & 0xff;\n        return new Decimal128(buffer);\n    }\n    toString() {\n        let biased_exponent;\n        let significand_digits = 0;\n        const significand = new Array(36);\n        for(let i = 0; i < significand.length; i++)significand[i] = 0;\n        let index = 0;\n        let is_zero = false;\n        let significand_msb;\n        let significand128 = {\n            parts: [\n                0,\n                0,\n                0,\n                0\n            ]\n        };\n        let j, k;\n        const string = [];\n        index = 0;\n        const buffer = this.bytes;\n        const low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        const high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        index = 0;\n        const dec = {\n            low: new Long(low, midl),\n            high: new Long(midh, high)\n        };\n        if (dec.high.lessThan(Long.ZERO)) {\n            string.push(\"-\");\n        }\n        const combination = high >> 26 & COMBINATION_MASK;\n        if (combination >> 3 === 3) {\n            if (combination === COMBINATION_INFINITY) {\n                return string.join(\"\") + \"Infinity\";\n            } else if (combination === COMBINATION_NAN) {\n                return \"NaN\";\n            } else {\n                biased_exponent = high >> 15 & EXPONENT_MASK;\n                significand_msb = 0x08 + (high >> 14 & 0x01);\n            }\n        } else {\n            significand_msb = high >> 14 & 0x07;\n            biased_exponent = high >> 17 & EXPONENT_MASK;\n        }\n        const exponent = biased_exponent - EXPONENT_BIAS;\n        significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\n        significand128.parts[1] = midh;\n        significand128.parts[2] = midl;\n        significand128.parts[3] = low;\n        if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {\n            is_zero = true;\n        } else {\n            for(k = 3; k >= 0; k--){\n                let least_digits = 0;\n                const result = divideu128(significand128);\n                significand128 = result.quotient;\n                least_digits = result.rem.low;\n                if (!least_digits) continue;\n                for(j = 8; j >= 0; j--){\n                    significand[k * 9 + j] = least_digits % 10;\n                    least_digits = Math.floor(least_digits / 10);\n                }\n            }\n        }\n        if (is_zero) {\n            significand_digits = 1;\n            significand[index] = 0;\n        } else {\n            significand_digits = 36;\n            while(!significand[index]){\n                significand_digits = significand_digits - 1;\n                index = index + 1;\n            }\n        }\n        const scientific_exponent = significand_digits - 1 + exponent;\n        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n            if (significand_digits > 34) {\n                string.push(`${0}`);\n                if (exponent > 0) string.push(`E+${exponent}`);\n                else if (exponent < 0) string.push(`E${exponent}`);\n                return string.join(\"\");\n            }\n            string.push(`${significand[index++]}`);\n            significand_digits = significand_digits - 1;\n            if (significand_digits) {\n                string.push(\".\");\n            }\n            for(let i = 0; i < significand_digits; i++){\n                string.push(`${significand[index++]}`);\n            }\n            string.push(\"E\");\n            if (scientific_exponent > 0) {\n                string.push(`+${scientific_exponent}`);\n            } else {\n                string.push(`${scientific_exponent}`);\n            }\n        } else {\n            if (exponent >= 0) {\n                for(let i = 0; i < significand_digits; i++){\n                    string.push(`${significand[index++]}`);\n                }\n            } else {\n                let radix_position = significand_digits + exponent;\n                if (radix_position > 0) {\n                    for(let i = 0; i < radix_position; i++){\n                        string.push(`${significand[index++]}`);\n                    }\n                } else {\n                    string.push(\"0\");\n                }\n                string.push(\".\");\n                while(radix_position++ < 0){\n                    string.push(\"0\");\n                }\n                for(let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++){\n                    string.push(`${significand[index++]}`);\n                }\n            }\n        }\n        return string.join(\"\");\n    }\n    toJSON() {\n        return {\n            $numberDecimal: this.toString()\n        };\n    }\n    toExtendedJSON() {\n        return {\n            $numberDecimal: this.toString()\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return Decimal128.fromString(doc.$numberDecimal);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const d128string = inspect(this.toString(), options);\n        return `new Decimal128(${d128string})`;\n    }\n}\nclass Double extends BSONValue {\n    get _bsontype() {\n        return \"Double\";\n    }\n    constructor(value){\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toExtendedJSON(options) {\n        if (options && (options.legacy || options.relaxed && isFinite(this.value))) {\n            return this.value;\n        }\n        if (Object.is(Math.sign(this.value), -0)) {\n            return {\n                $numberDouble: \"-0.0\"\n            };\n        }\n        return {\n            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const doubleValue = parseFloat(doc.$numberDouble);\n        return options && options.relaxed ? doubleValue : new Double(doubleValue);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new Double(${inspect(this.value, options)})`;\n    }\n}\nclass Int32 extends BSONValue {\n    get _bsontype() {\n        return \"Int32\";\n    }\n    constructor(value){\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value | 0;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON(options) {\n        if (options && (options.relaxed || options.legacy)) return this.value;\n        return {\n            $numberInt: this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new Int32(${inspect(this.value, options)})`;\n    }\n}\nclass MaxKey extends BSONValue {\n    get _bsontype() {\n        return \"MaxKey\";\n    }\n    toExtendedJSON() {\n        return {\n            $maxKey: 1\n        };\n    }\n    static fromExtendedJSON() {\n        return new MaxKey();\n    }\n    inspect() {\n        return \"new MaxKey()\";\n    }\n}\nclass MinKey extends BSONValue {\n    get _bsontype() {\n        return \"MinKey\";\n    }\n    toExtendedJSON() {\n        return {\n            $minKey: 1\n        };\n    }\n    static fromExtendedJSON() {\n        return new MinKey();\n    }\n    inspect() {\n        return \"new MinKey()\";\n    }\n}\nconst checkForHexRegExp = new RegExp(\"^[0-9a-fA-F]{24}$\");\nlet PROCESS_UNIQUE = null;\nconst kId = Symbol(\"id\");\nclass ObjectId extends BSONValue {\n    get _bsontype() {\n        return \"ObjectId\";\n    }\n    constructor(inputId){\n        super();\n        let workingId;\n        if (typeof inputId === \"object\" && inputId && \"id\" in inputId) {\n            if (typeof inputId.id !== \"string\" && !ArrayBuffer.isView(inputId.id)) {\n                throw new BSONError(\"Argument passed in must have an id that is of type string or Buffer\");\n            }\n            if (\"toHexString\" in inputId && typeof inputId.toHexString === \"function\") {\n                workingId = ByteUtils.fromHex(inputId.toHexString());\n            } else {\n                workingId = inputId.id;\n            }\n        } else {\n            workingId = inputId;\n        }\n        if (workingId == null || typeof workingId === \"number\") {\n            this[kId] = ObjectId.generate(typeof workingId === \"number\" ? workingId : undefined);\n        } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n            this[kId] = ByteUtils.toLocalBufferType(workingId);\n        } else if (typeof workingId === \"string\") {\n            if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\n                this[kId] = ByteUtils.fromHex(workingId);\n            } else {\n                throw new BSONError(\"input must be a 24 character hex string, 12 byte Uint8Array, or an integer\");\n            }\n        } else {\n            throw new BSONError(\"Argument passed in does not match the accepted types\");\n        }\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(this.id);\n        }\n    }\n    get id() {\n        return this[kId];\n    }\n    set id(value) {\n        this[kId] = value;\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(value);\n        }\n    }\n    toHexString() {\n        if (ObjectId.cacheHexString && this.__id) {\n            return this.__id;\n        }\n        const hexString = ByteUtils.toHex(this.id);\n        if (ObjectId.cacheHexString && !this.__id) {\n            this.__id = hexString;\n        }\n        return hexString;\n    }\n    static getInc() {\n        return ObjectId.index = (ObjectId.index + 1) % 0xffffff;\n    }\n    static generate(time) {\n        if (\"number\" !== typeof time) {\n            time = Math.floor(Date.now() / 1000);\n        }\n        const inc = ObjectId.getInc();\n        const buffer = ByteUtils.allocate(12);\n        BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n        if (PROCESS_UNIQUE === null) {\n            PROCESS_UNIQUE = ByteUtils.randomBytes(5);\n        }\n        buffer[4] = PROCESS_UNIQUE[0];\n        buffer[5] = PROCESS_UNIQUE[1];\n        buffer[6] = PROCESS_UNIQUE[2];\n        buffer[7] = PROCESS_UNIQUE[3];\n        buffer[8] = PROCESS_UNIQUE[4];\n        buffer[11] = inc & 0xff;\n        buffer[10] = inc >> 8 & 0xff;\n        buffer[9] = inc >> 16 & 0xff;\n        return buffer;\n    }\n    toString(encoding) {\n        if (encoding === \"base64\") return ByteUtils.toBase64(this.id);\n        if (encoding === \"hex\") return this.toHexString();\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    static is(variable) {\n        return variable != null && typeof variable === \"object\" && \"_bsontype\" in variable && variable._bsontype === \"ObjectId\";\n    }\n    equals(otherId) {\n        if (otherId === undefined || otherId === null) {\n            return false;\n        }\n        if (ObjectId.is(otherId)) {\n            return this[kId][11] === otherId[kId][11] && ByteUtils.equals(this[kId], otherId[kId]);\n        }\n        if (typeof otherId === \"string\") {\n            return otherId.toLowerCase() === this.toHexString();\n        }\n        if (typeof otherId === \"object\" && typeof otherId.toHexString === \"function\") {\n            const otherIdString = otherId.toHexString();\n            const thisIdString = this.toHexString();\n            return typeof otherIdString === \"string\" && otherIdString.toLowerCase() === thisIdString;\n        }\n        return false;\n    }\n    getTimestamp() {\n        const timestamp = new Date();\n        const time = BSONDataView.fromUint8Array(this.id).getUint32(0, false);\n        timestamp.setTime(Math.floor(time) * 1000);\n        return timestamp;\n    }\n    static createPk() {\n        return new ObjectId();\n    }\n    static createFromTime(time) {\n        const buffer = ByteUtils.fromNumberArray([\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ]);\n        BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n        return new ObjectId(buffer);\n    }\n    static createFromHexString(hexString) {\n        if (hexString?.length !== 24) {\n            throw new BSONError(\"hex string must be 24 characters\");\n        }\n        return new ObjectId(ByteUtils.fromHex(hexString));\n    }\n    static createFromBase64(base64) {\n        if (base64?.length !== 16) {\n            throw new BSONError(\"base64 string must be 16 characters\");\n        }\n        return new ObjectId(ByteUtils.fromBase64(base64));\n    }\n    static isValid(id) {\n        if (id == null) return false;\n        try {\n            new ObjectId(id);\n            return true;\n        } catch  {\n            return false;\n        }\n    }\n    toExtendedJSON() {\n        if (this.toHexString) return {\n            $oid: this.toHexString()\n        };\n        return {\n            $oid: this.toString(\"hex\")\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new ObjectId(doc.$oid);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new ObjectId(${inspect(this.toHexString(), options)})`;\n    }\n}\nObjectId.index = Math.floor(Math.random() * 0xffffff);\nfunction internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {\n    let totalLength = 4 + 1;\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; i++){\n            totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n        }\n    } else {\n        if (typeof object?.toBSON === \"function\") {\n            object = object.toBSON();\n        }\n        for (const key of Object.keys(object)){\n            totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n        }\n    }\n    return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {\n    if (typeof value?.toBSON === \"function\") {\n        value = value.toBSON();\n    }\n    switch(typeof value){\n        case \"string\":\n            return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;\n        case \"number\":\n            if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {\n                if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n                }\n            } else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n        case \"undefined\":\n            if (isArray || !ignoreUndefined) return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            return 0;\n        case \"boolean\":\n            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);\n        case \"object\":\n            if (value != null && typeof value._bsontype === \"string\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value == null || value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            } else if (value._bsontype === \"ObjectId\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);\n            } else if (value instanceof Date || isDate(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Double\" || value._bsontype === \"Timestamp\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            } else if (value._bsontype === \"Decimal128\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);\n            } else if (value._bsontype === \"Code\") {\n                if (value.scope != null && Object.keys(value.scope).length > 0) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;\n                }\n            } else if (value._bsontype === \"Binary\") {\n                const binary = value;\n                if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);\n                } else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);\n                }\n            } else if (value._bsontype === \"Symbol\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;\n            } else if (value._bsontype === \"DBRef\") {\n                const ordered_values = Object.assign({\n                    $ref: value.collection,\n                    $id: value.oid\n                }, value.fields);\n                if (value.db != null) {\n                    ordered_values[\"$db\"] = value.db;\n                }\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;\n            } else if (value._bsontype === \"BSONRegExp\") {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;\n            } else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;\n            }\n        case \"function\":\n            if (serializeFunctions) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;\n            }\n    }\n    return 0;\n}\nfunction alphabetize(str) {\n    return str.split(\"\").sort().join(\"\");\n}\nclass BSONRegExp extends BSONValue {\n    get _bsontype() {\n        return \"BSONRegExp\";\n    }\n    constructor(pattern, options){\n        super();\n        this.pattern = pattern;\n        this.options = alphabetize(options ?? \"\");\n        if (this.pattern.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);\n        }\n        if (this.options.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);\n        }\n        for(let i = 0; i < this.options.length; i++){\n            if (!(this.options[i] === \"i\" || this.options[i] === \"m\" || this.options[i] === \"x\" || this.options[i] === \"l\" || this.options[i] === \"s\" || this.options[i] === \"u\")) {\n                throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);\n            }\n        }\n    }\n    static parseOptions(options) {\n        return options ? options.split(\"\").sort().join(\"\") : \"\";\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        if (options.legacy) {\n            return {\n                $regex: this.pattern,\n                $options: this.options\n            };\n        }\n        return {\n            $regularExpression: {\n                pattern: this.pattern,\n                options: this.options\n            }\n        };\n    }\n    static fromExtendedJSON(doc) {\n        if (\"$regex\" in doc) {\n            if (typeof doc.$regex !== \"string\") {\n                if (doc.$regex._bsontype === \"BSONRegExp\") {\n                    return doc;\n                }\n            } else {\n                return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\n            }\n        }\n        if (\"$regularExpression\" in doc) {\n            return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));\n        }\n        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);\n    }\n    inspect(depth, options, inspect) {\n        const stylize = getStylizeFunction(options) ?? ((v)=>v);\n        inspect ??= defaultInspect;\n        const pattern = stylize(inspect(this.pattern), \"regexp\");\n        const flags = stylize(inspect(this.options), \"regexp\");\n        return `new BSONRegExp(${pattern}, ${flags})`;\n    }\n}\nclass BSONSymbol extends BSONValue {\n    get _bsontype() {\n        return \"BSONSymbol\";\n    }\n    constructor(value){\n        super();\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON() {\n        return {\n            $symbol: this.value\n        };\n    }\n    static fromExtendedJSON(doc) {\n        return new BSONSymbol(doc.$symbol);\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        return `new BSONSymbol(${inspect(this.value, options)})`;\n    }\n}\nconst LongWithoutOverridesClass = Long;\nclass Timestamp extends LongWithoutOverridesClass {\n    get _bsontype() {\n        return \"Timestamp\";\n    }\n    constructor(low){\n        if (low == null) {\n            super(0, 0, true);\n        } else if (typeof low === \"bigint\") {\n            super(low, true);\n        } else if (Long.isLong(low)) {\n            super(low.low, low.high, true);\n        } else if (typeof low === \"object\" && \"t\" in low && \"i\" in low) {\n            if (typeof low.t !== \"number\" && (typeof low.t !== \"object\" || low.t._bsontype !== \"Int32\")) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide t as a number\");\n            }\n            if (typeof low.i !== \"number\" && (typeof low.i !== \"object\" || low.i._bsontype !== \"Int32\")) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide i as a number\");\n            }\n            const t = Number(low.t);\n            const i = Number(low.i);\n            if (t < 0 || Number.isNaN(t)) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide a positive t\");\n            }\n            if (i < 0 || Number.isNaN(i)) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide a positive i\");\n            }\n            if (t > 4294967295) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide t equal or less than uint32 max\");\n            }\n            if (i > 4294967295) {\n                throw new BSONError(\"Timestamp constructed from { t, i } must provide i equal or less than uint32 max\");\n            }\n            super(i, t, true);\n        } else {\n            throw new BSONError(\"A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }\");\n        }\n    }\n    toJSON() {\n        return {\n            $timestamp: this.toString()\n        };\n    }\n    static fromInt(value) {\n        return new Timestamp(Long.fromInt(value, true));\n    }\n    static fromNumber(value) {\n        return new Timestamp(Long.fromNumber(value, true));\n    }\n    static fromBits(lowBits, highBits) {\n        return new Timestamp({\n            i: lowBits,\n            t: highBits\n        });\n    }\n    static fromString(str, optRadix) {\n        return new Timestamp(Long.fromString(str, true, optRadix));\n    }\n    toExtendedJSON() {\n        return {\n            $timestamp: {\n                t: this.high >>> 0,\n                i: this.low >>> 0\n            }\n        };\n    }\n    static fromExtendedJSON(doc) {\n        const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;\n        const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;\n        return new Timestamp({\n            t,\n            i\n        });\n    }\n    inspect(depth, options, inspect) {\n        inspect ??= defaultInspect;\n        const t = inspect(this.high >>> 0, options);\n        const i = inspect(this.low >>> 0, options);\n        return `new Timestamp({ t: ${t}, i: ${i} })`;\n    }\n}\nTimestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\nconst JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nconst JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nfunction internalDeserialize(buffer, options, isArray) {\n    options = options == null ? {} : options;\n    const index = options && options.index ? options.index : 0;\n    const size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n    if (size < 5) {\n        throw new BSONError(`bson size must be >= 5, is ${size}`);\n    }\n    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n        throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\n    }\n    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n        throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\n    }\n    if (size + index > buffer.byteLength) {\n        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);\n    }\n    if (buffer[index + size - 1] !== 0) {\n        throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n    }\n    return deserializeObject(buffer, index, options, isArray);\n}\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer, index, options, isArray = false) {\n    const fieldsAsRaw = options[\"fieldsAsRaw\"] == null ? null : options[\"fieldsAsRaw\"];\n    const raw = options[\"raw\"] == null ? false : options[\"raw\"];\n    const bsonRegExp = typeof options[\"bsonRegExp\"] === \"boolean\" ? options[\"bsonRegExp\"] : false;\n    const promoteBuffers = options.promoteBuffers ?? false;\n    const promoteLongs = options.promoteLongs ?? true;\n    const promoteValues = options.promoteValues ?? true;\n    const useBigInt64 = options.useBigInt64 ?? false;\n    if (useBigInt64 && !promoteValues) {\n        throw new BSONError(\"Must either request bigint or Long for int64 deserialization\");\n    }\n    if (useBigInt64 && !promoteLongs) {\n        throw new BSONError(\"Must either request bigint or Long for int64 deserialization\");\n    }\n    const validation = options.validation == null ? {\n        utf8: true\n    } : options.validation;\n    let globalUTFValidation = true;\n    let validationSetting;\n    const utf8KeysSet = new Set();\n    const utf8ValidatedKeys = validation.utf8;\n    if (typeof utf8ValidatedKeys === \"boolean\") {\n        validationSetting = utf8ValidatedKeys;\n    } else {\n        globalUTFValidation = false;\n        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function(key) {\n            return utf8ValidatedKeys[key];\n        });\n        if (utf8ValidationValues.length === 0) {\n            throw new BSONError(\"UTF-8 validation setting cannot be empty\");\n        }\n        if (typeof utf8ValidationValues[0] !== \"boolean\") {\n            throw new BSONError(\"Invalid UTF-8 validation option, must specify boolean values\");\n        }\n        validationSetting = utf8ValidationValues[0];\n        if (!utf8ValidationValues.every((item)=>item === validationSetting)) {\n            throw new BSONError(\"Invalid UTF-8 validation option - keys must be all true or all false\");\n        }\n    }\n    if (!globalUTFValidation) {\n        for (const key of Object.keys(utf8ValidatedKeys)){\n            utf8KeysSet.add(key);\n        }\n    }\n    const startIndex = index;\n    if (buffer.length < 5) throw new BSONError(\"corrupt bson message < 5 bytes long\");\n    const size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    if (size < 5 || size > buffer.length) throw new BSONError(\"corrupt bson message\");\n    const object = isArray ? [] : {};\n    let arrayIndex = 0;\n    const done = false;\n    let isPossibleDBRef = isArray ? false : null;\n    const dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    while(!done){\n        const elementType = buffer[index++];\n        if (elementType === 0) break;\n        let i = index;\n        while(buffer[i] !== 0x00 && i < buffer.length){\n            i++;\n        }\n        if (i >= buffer.byteLength) throw new BSONError(\"Bad BSON Document: illegal CString\");\n        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer, index, i, false);\n        let shouldValidateKey = true;\n        if (globalUTFValidation || utf8KeysSet.has(name)) {\n            shouldValidateKey = validationSetting;\n        } else {\n            shouldValidateKey = !validationSetting;\n        }\n        if (isPossibleDBRef !== false && name[0] === \"$\") {\n            isPossibleDBRef = allowedDBRefKeys.test(name);\n        }\n        let value;\n        index = i + 1;\n        if (elementType === BSON_DATA_STRING) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            value = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_OID) {\n            const oid = ByteUtils.allocate(12);\n            oid.set(buffer.subarray(index, index + 12));\n            value = new ObjectId(oid);\n            index = index + 12;\n        } else if (elementType === BSON_DATA_INT && promoteValues === false) {\n            value = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);\n        } else if (elementType === BSON_DATA_INT) {\n            value = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n        } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {\n            value = new Double(dataview.getFloat64(index, true));\n            index = index + 8;\n        } else if (elementType === BSON_DATA_NUMBER) {\n            value = dataview.getFloat64(index, true);\n            index = index + 8;\n        } else if (elementType === BSON_DATA_DATE) {\n            const lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            value = new Date(new Long(lowBits, highBits).toNumber());\n        } else if (elementType === BSON_DATA_BOOLEAN) {\n            if (buffer[index] !== 0 && buffer[index] !== 1) throw new BSONError(\"illegal boolean type value\");\n            value = buffer[index++] === 1;\n        } else if (elementType === BSON_DATA_OBJECT) {\n            const _index = index;\n            const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n            if (objectSize <= 0 || objectSize > buffer.length - index) throw new BSONError(\"bad embedded document length in bson\");\n            if (raw) {\n                value = buffer.slice(index, index + objectSize);\n            } else {\n                let objectOptions = options;\n                if (!globalUTFValidation) {\n                    objectOptions = {\n                        ...options,\n                        validation: {\n                            utf8: shouldValidateKey\n                        }\n                    };\n                }\n                value = deserializeObject(buffer, _index, objectOptions, false);\n            }\n            index = index + objectSize;\n        } else if (elementType === BSON_DATA_ARRAY) {\n            const _index = index;\n            const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n            let arrayOptions = options;\n            const stopIndex = index + objectSize;\n            if (fieldsAsRaw && fieldsAsRaw[name]) {\n                arrayOptions = {\n                    ...options,\n                    raw: true\n                };\n            }\n            if (!globalUTFValidation) {\n                arrayOptions = {\n                    ...arrayOptions,\n                    validation: {\n                        utf8: shouldValidateKey\n                    }\n                };\n            }\n            value = deserializeObject(buffer, _index, arrayOptions, true);\n            index = index + objectSize;\n            if (buffer[index - 1] !== 0) throw new BSONError(\"invalid array terminator byte\");\n            if (index !== stopIndex) throw new BSONError(\"corrupted array bson\");\n        } else if (elementType === BSON_DATA_UNDEFINED) {\n            value = undefined;\n        } else if (elementType === BSON_DATA_NULL) {\n            value = null;\n        } else if (elementType === BSON_DATA_LONG) {\n            const dataview = BSONDataView.fromUint8Array(buffer.subarray(index, index + 8));\n            const lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const long = new Long(lowBits, highBits);\n            if (useBigInt64) {\n                value = dataview.getBigInt64(0, true);\n            } else if (promoteLongs && promoteValues === true) {\n                value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n            } else {\n                value = long;\n            }\n        } else if (elementType === BSON_DATA_DECIMAL128) {\n            const bytes = ByteUtils.allocate(16);\n            bytes.set(buffer.subarray(index, index + 16), 0);\n            index = index + 16;\n            value = new Decimal128(bytes);\n        } else if (elementType === BSON_DATA_BINARY) {\n            let binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            const totalBinarySize = binarySize;\n            const subType = buffer[index++];\n            if (binarySize < 0) throw new BSONError(\"Negative binary type element size found\");\n            if (binarySize > buffer.byteLength) throw new BSONError(\"Binary type size larger than document size\");\n            if (buffer[\"slice\"] != null) {\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n                    if (binarySize < 0) throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n                    if (binarySize > totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n                    if (binarySize < totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));\n                } else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            } else {\n                const _buffer = ByteUtils.allocate(binarySize);\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n                    if (binarySize < 0) throw new BSONError(\"Negative binary type element size found for subtype 0x02\");\n                    if (binarySize > totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too long binary size\");\n                    if (binarySize < totalBinarySize - 4) throw new BSONError(\"Binary type with subtype 0x02 contains too short binary size\");\n                }\n                for(i = 0; i < binarySize; i++){\n                    _buffer[i] = buffer[index + i];\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = _buffer;\n                } else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            }\n            index = index + binarySize;\n        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const source = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            const optionsArray = new Array(regExpOptions.length);\n            for(i = 0; i < regExpOptions.length; i++){\n                switch(regExpOptions[i]){\n                    case \"m\":\n                        optionsArray[i] = \"m\";\n                        break;\n                    case \"s\":\n                        optionsArray[i] = \"g\";\n                        break;\n                    case \"i\":\n                        optionsArray[i] = \"i\";\n                        break;\n                }\n            }\n            value = new RegExp(source, optionsArray.join(\"\"));\n        } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const source = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            i = index;\n            while(buffer[i] !== 0x00 && i < buffer.length){\n                i++;\n            }\n            if (i >= buffer.length) throw new BSONError(\"Bad BSON Document: illegal CString\");\n            const regExpOptions = ByteUtils.toUTF8(buffer, index, i, false);\n            index = i + 1;\n            value = new BSONRegExp(source, regExpOptions);\n        } else if (elementType === BSON_DATA_SYMBOL) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const symbol = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = promoteValues ? symbol : new BSONSymbol(symbol);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_TIMESTAMP) {\n            const i = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24);\n            const t = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24);\n            value = new Timestamp({\n                i,\n                t\n            });\n        } else if (elementType === BSON_DATA_MIN_KEY) {\n            value = new MinKey();\n        } else if (elementType === BSON_DATA_MAX_KEY) {\n            value = new MaxKey();\n        } else if (elementType === BSON_DATA_CODE) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = new Code(functionString);\n            index = index + stringSize;\n        } else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n            const totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (totalSize < 4 + 4 + 4 + 1) {\n                throw new BSONError(\"code_w_scope total size shorter minimum expected length\");\n            }\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError(\"bad string length in bson\");\n            }\n            const functionString = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n            const _index = index;\n            const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n            const scopeObject = deserializeObject(buffer, _index, options, false);\n            index = index + objectSize;\n            if (totalSize < 4 + 4 + objectSize + stringSize) {\n                throw new BSONError(\"code_w_scope total size is too short, truncating scope\");\n            }\n            if (totalSize > 4 + 4 + objectSize + stringSize) {\n                throw new BSONError(\"code_w_scope total size is too long, clips outer document\");\n            }\n            value = new Code(functionString, scopeObject);\n        } else if (elementType === BSON_DATA_DBPOINTER) {\n            const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n            if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new BSONError(\"bad string length in bson\");\n            if (validation != null && validation.utf8) {\n                if (!validateUtf8(buffer, index, index + stringSize - 1)) {\n                    throw new BSONError(\"Invalid UTF-8 string in BSON document\");\n                }\n            }\n            const namespace = ByteUtils.toUTF8(buffer, index, index + stringSize - 1, false);\n            index = index + stringSize;\n            const oidBuffer = ByteUtils.allocate(12);\n            oidBuffer.set(buffer.subarray(index, index + 12), 0);\n            const oid = new ObjectId(oidBuffer);\n            index = index + 12;\n            value = new DBRef(namespace, oid);\n        } else {\n            throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`);\n        }\n        if (name === \"__proto__\") {\n            Object.defineProperty(object, name, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        } else {\n            object[name] = value;\n        }\n    }\n    if (size !== index - startIndex) {\n        if (isArray) throw new BSONError(\"corrupt array bson\");\n        throw new BSONError(\"corrupt object bson\");\n    }\n    if (!isPossibleDBRef) return object;\n    if (isDBRefLike(object)) {\n        const copy = Object.assign({}, object);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(object.$ref, object.$id, object.$db, copy);\n    }\n    return object;\n}\nconst regexp = /\\x00/;\nconst ignoreKeys = new Set([\n    \"$db\",\n    \"$ref\",\n    \"$id\",\n    \"$clusterTime\"\n]);\nfunction serializeString(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_STRING;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes + 1;\n    buffer[index - 1] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);\n    buffer[index + 3] = size + 1 >> 24 & 0xff;\n    buffer[index + 2] = size + 1 >> 16 & 0xff;\n    buffer[index + 1] = size + 1 >> 8 & 0xff;\n    buffer[index] = size + 1 & 0xff;\n    index = index + 4 + size;\n    buffer[index++] = 0;\n    return index;\n}\nconst NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8);\nconst FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4);\nconst EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8);\nfunction serializeNumber(buffer, key, value, index) {\n    const isNegativeZero = Object.is(value, -0);\n    const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;\n    if (type === BSON_DATA_INT) {\n        NUMBER_SPACE.setInt32(0, value, true);\n    } else {\n        NUMBER_SPACE.setFloat64(0, value, true);\n    }\n    const bytes = type === BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER;\n    buffer[index++] = type;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0x00;\n    buffer.set(bytes, index);\n    index += bytes.byteLength;\n    return index;\n}\nfunction serializeBigInt(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_LONG;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index += numberOfWrittenBytes;\n    buffer[index++] = 0;\n    NUMBER_SPACE.setBigInt64(0, value, true);\n    buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n    index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;\n    return index;\n}\nfunction serializeNull(buffer, key, _, index) {\n    buffer[index++] = BSON_DATA_NULL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeBoolean(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BOOLEAN;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value ? 1 : 0;\n    return index;\n}\nfunction serializeDate(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DATE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const dateInMilis = Long.fromNumber(value.getTime());\n    const lowBits = dateInMilis.getLowBits();\n    const highBits = dateInMilis.getHighBits();\n    buffer[index++] = lowBits & 0xff;\n    buffer[index++] = lowBits >> 8 & 0xff;\n    buffer[index++] = lowBits >> 16 & 0xff;\n    buffer[index++] = lowBits >> 24 & 0xff;\n    buffer[index++] = highBits & 0xff;\n    buffer[index++] = highBits >> 8 & 0xff;\n    buffer[index++] = highBits >> 16 & 0xff;\n    buffer[index++] = highBits >> 24 & 0xff;\n    return index;\n}\nfunction serializeRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.source && value.source.match(regexp) != null) {\n        throw new BSONError(\"value \" + value.source + \" must not contain null bytes\");\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);\n    buffer[index++] = 0x00;\n    if (value.ignoreCase) buffer[index++] = 0x69;\n    if (value.global) buffer[index++] = 0x73;\n    if (value.multiline) buffer[index++] = 0x6d;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeBSONRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.pattern.match(regexp) != null) {\n        throw new BSONError(\"pattern \" + value.pattern + \" must not contain null bytes\");\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);\n    buffer[index++] = 0x00;\n    const sortedOptions = value.options.split(\"\").sort().join(\"\");\n    index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeMinMax(buffer, key, value, index) {\n    if (value === null) {\n        buffer[index++] = BSON_DATA_NULL;\n    } else if (value._bsontype === \"MinKey\") {\n        buffer[index++] = BSON_DATA_MIN_KEY;\n    } else {\n        buffer[index++] = BSON_DATA_MAX_KEY;\n    }\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeObjectId(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_OID;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const idValue = value.id;\n    if (isUint8Array(idValue)) {\n        for(let i = 0; i < 12; i++){\n            buffer[index++] = idValue[i];\n        }\n    } else {\n        throw new BSONError(\"object [\" + JSON.stringify(value) + \"] is not a valid ObjectId\");\n    }\n    return index;\n}\nfunction serializeBuffer(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = value.length;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = size >> 8 & 0xff;\n    buffer[index++] = size >> 16 & 0xff;\n    buffer[index++] = size >> 24 & 0xff;\n    buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n    buffer.set(value, index);\n    index = index + size;\n    return index;\n}\nfunction serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path.has(value)) {\n        throw new BSONError(\"Cannot convert circular structure to BSON\");\n    }\n    path.add(value);\n    buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n    path.delete(value);\n    return endIndex;\n}\nfunction serializeDecimal128(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DECIMAL128;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer.set(value.bytes.subarray(0, 16), index);\n    return index + 16;\n}\nfunction serializeLong(buffer, key, value, index) {\n    buffer[index++] = value._bsontype === \"Long\" ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const lowBits = value.getLowBits();\n    const highBits = value.getHighBits();\n    buffer[index++] = lowBits & 0xff;\n    buffer[index++] = lowBits >> 8 & 0xff;\n    buffer[index++] = lowBits >> 16 & 0xff;\n    buffer[index++] = lowBits >> 24 & 0xff;\n    buffer[index++] = highBits & 0xff;\n    buffer[index++] = highBits >> 8 & 0xff;\n    buffer[index++] = highBits >> 16 & 0xff;\n    buffer[index++] = highBits >> 24 & 0xff;\n    return index;\n}\nfunction serializeInt32(buffer, key, value, index) {\n    value = value.valueOf();\n    buffer[index++] = BSON_DATA_INT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value & 0xff;\n    buffer[index++] = value >> 8 & 0xff;\n    buffer[index++] = value >> 16 & 0xff;\n    buffer[index++] = value >> 24 & 0xff;\n    return index;\n}\nfunction serializeDouble(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_NUMBER;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    NUMBER_SPACE.setFloat64(0, value.value, true);\n    buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n    index = index + 8;\n    return index;\n}\nfunction serializeFunction(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_CODE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const functionString = value.toString();\n    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = size >> 8 & 0xff;\n    buffer[index + 2] = size >> 16 & 0xff;\n    buffer[index + 3] = size >> 24 & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {\n    if (value.scope && typeof value.scope === \"object\") {\n        buffer[index++] = BSON_DATA_CODE_W_SCOPE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        let startIndex = index;\n        const functionString = value.code;\n        index = index + 4;\n        const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        buffer[index] = codeSize & 0xff;\n        buffer[index + 1] = codeSize >> 8 & 0xff;\n        buffer[index + 2] = codeSize >> 16 & 0xff;\n        buffer[index + 3] = codeSize >> 24 & 0xff;\n        buffer[index + 4 + codeSize - 1] = 0;\n        index = index + codeSize + 4;\n        const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n        index = endIndex - 1;\n        const totalSize = endIndex - startIndex;\n        buffer[startIndex++] = totalSize & 0xff;\n        buffer[startIndex++] = totalSize >> 8 & 0xff;\n        buffer[startIndex++] = totalSize >> 16 & 0xff;\n        buffer[startIndex++] = totalSize >> 24 & 0xff;\n        buffer[index++] = 0;\n    } else {\n        buffer[index++] = BSON_DATA_CODE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        const functionString = value.code.toString();\n        const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        buffer[index] = size & 0xff;\n        buffer[index + 1] = size >> 8 & 0xff;\n        buffer[index + 2] = size >> 16 & 0xff;\n        buffer[index + 3] = size >> 24 & 0xff;\n        index = index + 4 + size - 1;\n        buffer[index++] = 0;\n    }\n    return index;\n}\nfunction serializeBinary(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const data = value.buffer;\n    let size = value.position;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = size >> 8 & 0xff;\n    buffer[index++] = size >> 16 & 0xff;\n    buffer[index++] = size >> 24 & 0xff;\n    buffer[index++] = value.sub_type;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n        size = size - 4;\n        buffer[index++] = size & 0xff;\n        buffer[index++] = size >> 8 & 0xff;\n        buffer[index++] = size >> 16 & 0xff;\n        buffer[index++] = size >> 24 & 0xff;\n    }\n    buffer.set(data, index);\n    index = index + value.position;\n    return index;\n}\nfunction serializeSymbol(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_SYMBOL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = size >> 8 & 0xff;\n    buffer[index + 2] = size >> 16 & 0xff;\n    buffer[index + 3] = size >> 24 & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {\n    buffer[index++] = BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    let startIndex = index;\n    let output = {\n        $ref: value.collection || value.namespace,\n        $id: value.oid\n    };\n    if (value.db != null) {\n        output.$db = value.db;\n    }\n    output = Object.assign(output, value.fields);\n    const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);\n    const size = endIndex - startIndex;\n    buffer[startIndex++] = size & 0xff;\n    buffer[startIndex++] = size >> 8 & 0xff;\n    buffer[startIndex++] = size >> 16 & 0xff;\n    buffer[startIndex++] = size >> 24 & 0xff;\n    return endIndex;\n}\nfunction serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path == null) {\n        if (object == null) {\n            buffer[0] = 0x05;\n            buffer[1] = 0x00;\n            buffer[2] = 0x00;\n            buffer[3] = 0x00;\n            buffer[4] = 0x00;\n            return 5;\n        }\n        if (Array.isArray(object)) {\n            throw new BSONError(\"serialize does not support an array as the root input\");\n        }\n        if (typeof object !== \"object\") {\n            throw new BSONError(\"serialize does not support non-object as the root input\");\n        } else if (\"_bsontype\" in object && typeof object._bsontype === \"string\") {\n            throw new BSONError(`BSON types cannot be serialized as a document`);\n        } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {\n            throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);\n        }\n        path = new Set();\n    }\n    path.add(object);\n    let index = startingIndex + 4;\n    if (Array.isArray(object)) {\n        for(let i = 0; i < object.length; i++){\n            const key = `${i}`;\n            let value = object[i];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            if (typeof value === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (typeof value === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (typeof value === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (typeof value === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === undefined) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (typeof value === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    } else if (object instanceof Map || isMap(object)) {\n        const iterator = object.entries();\n        let done = false;\n        while(!done){\n            const entry = iterator.next();\n            done = !!entry.done;\n            if (done) continue;\n            const key = entry.value[0];\n            let value = entry.value[1];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError(\"key \" + key + \" must not contain null bytes\");\n                }\n                if (checkKeys) {\n                    if (\"$\" === key[0]) {\n                        throw new BSONError(\"key \" + key + \" must not start with '$'\");\n                    } else if (~key.indexOf(\".\")) {\n                        throw new BSONError(\"key \" + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (type === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (type === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (type === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === null || value === undefined && ignoreUndefined === false) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    } else {\n        if (typeof object?.toBSON === \"function\") {\n            object = object.toBSON();\n            if (object != null && typeof object !== \"object\") {\n                throw new BSONError(\"toBSON function did not return an object\");\n            }\n        }\n        for (const key of Object.keys(object)){\n            let value = object[key];\n            if (typeof value?.toBSON === \"function\") {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === \"string\" && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError(\"key \" + key + \" must not contain null bytes\");\n                }\n                if (checkKeys) {\n                    if (\"$\" === key[0]) {\n                        throw new BSONError(\"key \" + key + \" must not start with '$'\");\n                    } else if (~key.indexOf(\".\")) {\n                        throw new BSONError(\"key \" + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === \"string\") {\n                index = serializeString(buffer, key, value, index);\n            } else if (type === \"number\") {\n                index = serializeNumber(buffer, key, value, index);\n            } else if (type === \"bigint\") {\n                index = serializeBigInt(buffer, key, value, index);\n            } else if (type === \"boolean\") {\n                index = serializeBoolean(buffer, key, value, index);\n            } else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            } else if (value === undefined) {\n                if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n            } else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            } else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            } else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"object\" && value[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            } else if (value._bsontype === \"ObjectId\") {\n                index = serializeObjectId(buffer, key, value, index);\n            } else if (type === \"object\" && value._bsontype === \"Decimal128\") {\n                index = serializeDecimal128(buffer, key, value, index);\n            } else if (value._bsontype === \"Long\" || value._bsontype === \"Timestamp\") {\n                index = serializeLong(buffer, key, value, index);\n            } else if (value._bsontype === \"Double\") {\n                index = serializeDouble(buffer, key, value, index);\n            } else if (value._bsontype === \"Code\") {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            } else if (typeof value === \"function\" && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            } else if (value._bsontype === \"Binary\") {\n                index = serializeBinary(buffer, key, value, index);\n            } else if (value._bsontype === \"BSONSymbol\") {\n                index = serializeSymbol(buffer, key, value, index);\n            } else if (value._bsontype === \"DBRef\") {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            } else if (value._bsontype === \"BSONRegExp\") {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            } else if (value._bsontype === \"Int32\") {\n                index = serializeInt32(buffer, key, value, index);\n            } else if (value._bsontype === \"MinKey\" || value._bsontype === \"MaxKey\") {\n                index = serializeMinMax(buffer, key, value, index);\n            } else if (typeof value._bsontype !== \"undefined\") {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    }\n    path.delete(object);\n    buffer[index++] = 0x00;\n    const size = index - startingIndex;\n    buffer[startingIndex++] = size & 0xff;\n    buffer[startingIndex++] = size >> 8 & 0xff;\n    buffer[startingIndex++] = size >> 16 & 0xff;\n    buffer[startingIndex++] = size >> 24 & 0xff;\n    return index;\n}\nfunction isBSONType(value) {\n    return value != null && typeof value === \"object\" && \"_bsontype\" in value && typeof value._bsontype === \"string\";\n}\nconst keysToCodecs = {\n    $oid: ObjectId,\n    $binary: Binary,\n    $uuid: Binary,\n    $symbol: BSONSymbol,\n    $numberInt: Int32,\n    $numberDecimal: Decimal128,\n    $numberDouble: Double,\n    $numberLong: Long,\n    $minKey: MinKey,\n    $maxKey: MaxKey,\n    $regex: BSONRegExp,\n    $regularExpression: BSONRegExp,\n    $timestamp: Timestamp\n};\nfunction deserializeValue(value, options = {}) {\n    if (typeof value === \"number\") {\n        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;\n        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;\n        if (options.relaxed || options.legacy) {\n            return value;\n        }\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (in32BitRange) {\n                return new Int32(value);\n            }\n            if (in64BitRange) {\n                if (options.useBigInt64) {\n                    return BigInt(value);\n                }\n                return Long.fromNumber(value);\n            }\n        }\n        return new Double(value);\n    }\n    if (value == null || typeof value !== \"object\") return value;\n    if (value.$undefined) return null;\n    const keys = Object.keys(value).filter((k)=>k.startsWith(\"$\") && value[k] != null);\n    for(let i = 0; i < keys.length; i++){\n        const c = keysToCodecs[keys[i]];\n        if (c) return c.fromExtendedJSON(value, options);\n    }\n    if (value.$date != null) {\n        const d = value.$date;\n        const date = new Date();\n        if (options.legacy) {\n            if (typeof d === \"number\") date.setTime(d);\n            else if (typeof d === \"string\") date.setTime(Date.parse(d));\n            else if (typeof d === \"bigint\") date.setTime(Number(d));\n            else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        } else {\n            if (typeof d === \"string\") date.setTime(Date.parse(d));\n            else if (Long.isLong(d)) date.setTime(d.toNumber());\n            else if (typeof d === \"number\" && options.relaxed) date.setTime(d);\n            else if (typeof d === \"bigint\") date.setTime(Number(d));\n            else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        return date;\n    }\n    if (value.$code != null) {\n        const copy = Object.assign({}, value);\n        if (value.$scope) {\n            copy.$scope = deserializeValue(value.$scope);\n        }\n        return Code.fromExtendedJSON(value);\n    }\n    if (isDBRefLike(value) || value.$dbPointer) {\n        const v = value.$ref ? value : value.$dbPointer;\n        if (v instanceof DBRef) return v;\n        const dollarKeys = Object.keys(v).filter((k)=>k.startsWith(\"$\"));\n        let valid = true;\n        dollarKeys.forEach((k)=>{\n            if ([\n                \"$ref\",\n                \"$id\",\n                \"$db\"\n            ].indexOf(k) === -1) valid = false;\n        });\n        if (valid) return DBRef.fromExtendedJSON(v);\n    }\n    return value;\n}\nfunction serializeArray(array, options) {\n    return array.map((v, index)=>{\n        options.seenObjects.push({\n            propertyName: `index ${index}`,\n            obj: null\n        });\n        try {\n            return serializeValue(v, options);\n        } finally{\n            options.seenObjects.pop();\n        }\n    });\n}\nfunction getISOString(date) {\n    const isoStr = date.toISOString();\n    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + \"Z\";\n}\nfunction serializeValue(value, options) {\n    if (value instanceof Map || isMap(value)) {\n        const obj = Object.create(null);\n        for (const [k, v] of value){\n            if (typeof k !== \"string\") {\n                throw new BSONError(\"Can only serialize maps with string keys\");\n            }\n            obj[k] = v;\n        }\n        return serializeValue(obj, options);\n    }\n    if ((typeof value === \"object\" || typeof value === \"function\") && value !== null) {\n        const index = options.seenObjects.findIndex((entry)=>entry.obj === value);\n        if (index !== -1) {\n            const props = options.seenObjects.map((entry)=>entry.propertyName);\n            const leadingPart = props.slice(0, index).map((prop)=>`${prop} -> `).join(\"\");\n            const alreadySeen = props[index];\n            const circularPart = \" -> \" + props.slice(index + 1, props.length - 1).map((prop)=>`${prop} -> `).join(\"\");\n            const current = props[props.length - 1];\n            const leadingSpace = \" \".repeat(leadingPart.length + alreadySeen.length / 2);\n            const dashes = \"-\".repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n            throw new BSONError(\"Converting circular structure to EJSON:\\n\" + `    ${leadingPart}${alreadySeen}${circularPart}${current}\\n` + `    ${leadingSpace}\\\\${dashes}/`);\n        }\n        options.seenObjects[options.seenObjects.length - 1].obj = value;\n    }\n    if (Array.isArray(value)) return serializeArray(value, options);\n    if (value === undefined) return null;\n    if (value instanceof Date || isDate(value)) {\n        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;\n        if (options.legacy) {\n            return options.relaxed && inRange ? {\n                $date: value.getTime()\n            } : {\n                $date: getISOString(value)\n            };\n        }\n        return options.relaxed && inRange ? {\n            $date: getISOString(value)\n        } : {\n            $date: {\n                $numberLong: value.getTime().toString()\n            }\n        };\n    }\n    if (typeof value === \"number\" && (!options.relaxed || !isFinite(value))) {\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                return {\n                    $numberInt: value.toString()\n                };\n            }\n            if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {\n                return {\n                    $numberLong: value.toString()\n                };\n            }\n        }\n        return {\n            $numberDouble: Object.is(value, -0) ? \"-0.0\" : value.toString()\n        };\n    }\n    if (typeof value === \"bigint\") {\n        if (!options.relaxed) {\n            return {\n                $numberLong: BigInt.asIntN(64, value).toString()\n            };\n        }\n        return Number(BigInt.asIntN(64, value));\n    }\n    if (value instanceof RegExp || isRegExp(value)) {\n        let flags = value.flags;\n        if (flags === undefined) {\n            const match = value.toString().match(/[gimuy]*$/);\n            if (match) {\n                flags = match[0];\n            }\n        }\n        const rx = new BSONRegExp(value.source, flags);\n        return rx.toExtendedJSON(options);\n    }\n    if (value != null && typeof value === \"object\") return serializeDocument(value, options);\n    return value;\n}\nconst BSON_TYPE_MAPPINGS = {\n    Binary: (o)=>new Binary(o.value(), o.sub_type),\n    Code: (o)=>new Code(o.code, o.scope),\n    DBRef: (o)=>new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),\n    Decimal128: (o)=>new Decimal128(o.bytes),\n    Double: (o)=>new Double(o.value),\n    Int32: (o)=>new Int32(o.value),\n    Long: (o)=>Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),\n    MaxKey: ()=>new MaxKey(),\n    MinKey: ()=>new MinKey(),\n    ObjectId: (o)=>new ObjectId(o),\n    BSONRegExp: (o)=>new BSONRegExp(o.pattern, o.options),\n    BSONSymbol: (o)=>new BSONSymbol(o.value),\n    Timestamp: (o)=>Timestamp.fromBits(o.low, o.high)\n};\nfunction serializeDocument(doc, options) {\n    if (doc == null || typeof doc !== \"object\") throw new BSONError(\"not an object instance\");\n    const bsontype = doc._bsontype;\n    if (typeof bsontype === \"undefined\") {\n        const _doc = {};\n        for (const name of Object.keys(doc)){\n            options.seenObjects.push({\n                propertyName: name,\n                obj: null\n            });\n            try {\n                const value = serializeValue(doc[name], options);\n                if (name === \"__proto__\") {\n                    Object.defineProperty(_doc, name, {\n                        value,\n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                } else {\n                    _doc[name] = value;\n                }\n            } finally{\n                options.seenObjects.pop();\n            }\n        }\n        return _doc;\n    } else if (doc != null && typeof doc === \"object\" && typeof doc._bsontype === \"string\" && doc[Symbol.for(\"@@mdb.bson.version\")] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n    } else if (isBSONType(doc)) {\n        let outDoc = doc;\n        if (typeof outDoc.toExtendedJSON !== \"function\") {\n            const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n            if (!mapper) {\n                throw new BSONError(\"Unrecognized or invalid _bsontype: \" + doc._bsontype);\n            }\n            outDoc = mapper(outDoc);\n        }\n        if (bsontype === \"Code\" && outDoc.scope) {\n            outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n        } else if (bsontype === \"DBRef\" && outDoc.oid) {\n            outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n        }\n        return outDoc.toExtendedJSON(options);\n    } else {\n        throw new BSONError(\"_bsontype must be a string, but was: \" + typeof bsontype);\n    }\n}\nfunction parse(text, options) {\n    const ejsonOptions = {\n        useBigInt64: options?.useBigInt64 ?? false,\n        relaxed: options?.relaxed ?? true,\n        legacy: options?.legacy ?? false\n    };\n    return JSON.parse(text, (key, value)=>{\n        if (key.indexOf(\"\\x00\") !== -1) {\n            throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);\n        }\n        return deserializeValue(value, ejsonOptions);\n    });\n}\nfunction stringify(value, replacer, space, options) {\n    if (space != null && typeof space === \"object\") {\n        options = space;\n        space = 0;\n    }\n    if (replacer != null && typeof replacer === \"object\" && !Array.isArray(replacer)) {\n        options = replacer;\n        replacer = undefined;\n        space = 0;\n    }\n    const serializeOptions = Object.assign({\n        relaxed: true,\n        legacy: false\n    }, options, {\n        seenObjects: [\n            {\n                propertyName: \"(root)\",\n                obj: null\n            }\n        ]\n    });\n    const doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n}\nfunction EJSONserialize(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n}\nfunction EJSONdeserialize(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n}\nconst EJSON = Object.create(null);\nEJSON.parse = parse;\nEJSON.stringify = stringify;\nEJSON.serialize = EJSONserialize;\nEJSON.deserialize = EJSONdeserialize;\nObject.freeze(EJSON);\nconst MAXSIZE = 1024 * 1024 * 17;\nlet buffer = ByteUtils.allocate(MAXSIZE);\nfunction setInternalBufferSize(size) {\n    if (buffer.length < size) {\n        buffer = ByteUtils.allocate(size);\n    }\n}\nfunction serialize(object, options = {}) {\n    const checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    const minInternalBufferSize = typeof options.minInternalBufferSize === \"number\" ? options.minInternalBufferSize : MAXSIZE;\n    if (buffer.length < minInternalBufferSize) {\n        buffer = ByteUtils.allocate(minInternalBufferSize);\n    }\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    const finishedBuffer = ByteUtils.allocate(serializationIndex);\n    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);\n    return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options = {}) {\n    const checkKeys = typeof options.checkKeys === \"boolean\" ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    const startIndex = typeof options.index === \"number\" ? options.index : 0;\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);\n    return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer, options = {}) {\n    return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);\n}\nfunction calculateObjectSize(object, options = {}) {\n    options = options || {};\n    const serializeFunctions = typeof options.serializeFunctions === \"boolean\" ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === \"boolean\" ? options.ignoreUndefined : true;\n    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n    const internalOptions = Object.assign({\n        allowObjectSmallerThanBufferSize: true,\n        index: 0\n    }, options);\n    const bufferData = ByteUtils.toLocalBufferType(data);\n    let index = startIndex;\n    for(let i = 0; i < numberOfDocuments; i++){\n        const size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;\n        internalOptions.index = index;\n        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);\n        index = index + size;\n    }\n    return index;\n}\nvar bson = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    BSONError: BSONError,\n    BSONRegExp: BSONRegExp,\n    BSONRuntimeError: BSONRuntimeError,\n    BSONSymbol: BSONSymbol,\n    BSONType: BSONType,\n    BSONValue: BSONValue,\n    BSONVersionError: BSONVersionError,\n    Binary: Binary,\n    Code: Code,\n    DBRef: DBRef,\n    Decimal128: Decimal128,\n    Double: Double,\n    EJSON: EJSON,\n    Int32: Int32,\n    Long: Long,\n    MaxKey: MaxKey,\n    MinKey: MinKey,\n    ObjectId: ObjectId,\n    Timestamp: Timestamp,\n    UUID: UUID,\n    calculateObjectSize: calculateObjectSize,\n    deserialize: deserialize,\n    deserializeStream: deserializeStream,\n    serialize: serialize,\n    serializeWithBufferAndIndex: serializeWithBufferAndIndex,\n    setInternalBufferSize: setInternalBufferSize\n});\nexports.BSON = bson;\nexports.BSONError = BSONError;\nexports.BSONRegExp = BSONRegExp;\nexports.BSONRuntimeError = BSONRuntimeError;\nexports.BSONSymbol = BSONSymbol;\nexports.BSONType = BSONType;\nexports.BSONValue = BSONValue;\nexports.BSONVersionError = BSONVersionError;\nexports.Binary = Binary;\nexports.Code = Code;\nexports.DBRef = DBRef;\nexports.Decimal128 = Decimal128;\nexports.Double = Double;\nexports.EJSON = EJSON;\nexports.Int32 = Int32;\nexports.Long = Long;\nexports.MaxKey = MaxKey;\nexports.MinKey = MinKey;\nexports.ObjectId = ObjectId;\nexports.Timestamp = Timestamp;\nexports.UUID = UUID;\nexports.calculateObjectSize = calculateObjectSize;\nexports.deserialize = deserialize;\nexports.deserializeStream = deserializeStream;\nexports.serialize = serialize;\nexports.serializeWithBufferAndIndex = serializeWithBufferAndIndex;\nexports.setInternalBufferSize = setInternalBufferSize; //# sourceMappingURL=bson.cjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYnNvbi9saWIvYnNvbi5janMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxTQUFTQSxpQkFBaUJDLEtBQUs7SUFDM0IsT0FBTztRQUFDO1FBQXdCO0tBQTZCLENBQUNDLFFBQVEsQ0FBQ0MsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0w7QUFDMUc7QUFDQSxTQUFTTSxhQUFhTixLQUFLO0lBQ3ZCLE9BQU9FLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNMLFdBQVc7QUFDckQ7QUFDQSxTQUFTTyxTQUFTQyxDQUFDO0lBQ2YsT0FBT04sT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0csT0FBTztBQUNqRDtBQUNBLFNBQVNDLE1BQU1ELENBQUM7SUFDWixPQUFPTixPQUFPQyxTQUFTLENBQUNDLFFBQVEsQ0FBQ0MsSUFBSSxDQUFDRyxPQUFPO0FBQ2pEO0FBQ0EsU0FBU0UsT0FBT0YsQ0FBQztJQUNiLE9BQU9OLE9BQU9DLFNBQVMsQ0FBQ0MsUUFBUSxDQUFDQyxJQUFJLENBQUNHLE9BQU87QUFDakQ7QUFDQSxTQUFTRyxlQUFlQyxDQUFDLEVBQUVDLFFBQVE7SUFDL0IsT0FBT0MsS0FBS0MsU0FBUyxDQUFDSCxHQUFHLENBQUNJLEdBQUdDO1FBQ3pCLElBQUksT0FBT0EsTUFBTSxVQUFVO1lBQ3ZCLE9BQU87Z0JBQUVDLGFBQWEsQ0FBQyxFQUFFRCxFQUFFLENBQUM7WUFBQztRQUNqQyxPQUNLLElBQUlSLE1BQU1RLElBQUk7WUFDZixPQUFPZixPQUFPaUIsV0FBVyxDQUFDRjtRQUM5QjtRQUNBLE9BQU9BO0lBQ1g7QUFDSjtBQUNBLFNBQVNHLG1CQUFtQkMsT0FBTztJQUMvQixNQUFNQyxnQkFBZ0JELFdBQVcsUUFDN0IsT0FBT0EsWUFBWSxZQUNuQixhQUFhQSxXQUNiLE9BQU9BLFFBQVFFLE9BQU8sS0FBSztJQUMvQixJQUFJRCxlQUFlO1FBQ2YsT0FBT0QsUUFB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QUFHO1FBQUc7UUFBRztRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUs7UUFBRztRQUFHO1FBQUc7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFLO1FBQUc7UUFBRztRQUFHO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUs7UUFBSztRQUFLO1FBQUs7UUFBRztRQUFHO1FBQUk7UUFBSztRQUFHO1FBQUc7UUFBRztRQUFHO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFHO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUc7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBRztRQUFLO1FBQUk7UUFBSTtRQUFLO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUk7UUFBSztRQUFLO1FBQUk7UUFBRztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBRztRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFHO1FBQUs7UUFBSTtRQUFJO1FBQUs7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUc7UUFBSztRQUFJO1FBQUk7UUFBSztR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dU4sWUFBWUE7SUFDWmtELFFBQVFBO0lBQ1JnTyxPQUFPQTtJQUNQdE4sT0FBT0E7SUFDUHZQLE1BQU1BO0lBQ055UCxRQUFRQTtJQUNSRSxRQUFRQTtJQUNSTSxVQUFVQTtJQUNWNkMsV0FBV0E7SUFDWHZYLE1BQU1BO0lBQ05naUIscUJBQXFCQTtJQUNyQlIsYUFBYUE7SUFDYlMsbUJBQW1CQTtJQUNuQlYsV0FBV0E7SUFDWE8sNkJBQTZCQTtJQUM3QkosdUJBQXVCQTtBQUMzQjtBQUVBM2QsWUFBWSxHQUFHd2U7QUFDZnhlLGlCQUFpQixHQUFHdE47QUFDcEJzTixrQkFBa0IsR0FBRytTO0FBQ3JCL1Msd0JBQXdCLEdBQUc5TTtBQUMzQjhNLGtCQUFrQixHQUFHcVQ7QUFDckJyVCxnQkFBZ0IsR0FBRzdPO0FBQ25CNk8saUJBQWlCLEdBQUczRjtBQUNwQjJGLHdCQUF3QixHQUFHL007QUFDM0IrTSxjQUFjLEdBQUd2RjtBQUNqQnVGLFlBQVksR0FBRzlCO0FBQ2Y4QixhQUFhLEdBQUdsQjtBQUNoQmtCLGtCQUFrQixHQUFHcU07QUFDckJyTSxjQUFjLEdBQUd1UDtBQUNqQnZQLGFBQWEsR0FBR3VkO0FBQ2hCdmQsYUFBYSxHQUFHaVE7QUFDaEJqUSxZQUFZLEdBQUdVO0FBQ2ZWLGNBQWMsR0FBR21RO0FBQ2pCblEsY0FBYyxHQUFHcVE7QUFDakJyUSxnQkFBZ0IsR0FBRzJRO0FBQ25CM1EsaUJBQWlCLEdBQUd3VDtBQUNwQnhULFlBQVksR0FBRy9EO0FBQ2YrRCwyQkFBMkIsR0FBR2llO0FBQzlCamUsbUJBQW1CLEdBQUd5ZDtBQUN0QnpkLHlCQUF5QixHQUFHa2U7QUFDNUJsZSxpQkFBaUIsR0FBR3dkO0FBQ3BCeGQsbUNBQW1DLEdBQUcrZDtBQUN0Qy9kLDZCQUE2QixHQUFHMmQsdUJBQ2hDLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3VzZXItZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvYnNvbi9saWIvYnNvbi5janM/M2ZiMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpIHtcbiAgICByZXR1cm4gWydbb2JqZWN0IEFycmF5QnVmZmVyXScsICdbb2JqZWN0IFNoYXJlZEFycmF5QnVmZmVyXSddLmluY2x1ZGVzKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkpO1xufVxuZnVuY3Rpb24gaXNVaW50OEFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFVpbnQ4QXJyYXldJztcbn1cbmZ1bmN0aW9uIGlzUmVnRXhwKGQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmZ1bmN0aW9uIGlzTWFwKGQpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGQpID09PSAnW29iamVjdCBNYXBdJztcbn1cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZnVuY3Rpb24gZGVmYXVsdEluc3BlY3QoeCwgX29wdGlvbnMpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeCwgKGssIHYpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckxvbmc6IGAke3Z9YCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTWFwKHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0U3R5bGl6ZUZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsaXplRXhpc3RzID0gb3B0aW9ucyAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnc3R5bGl6ZScgaW4gb3B0aW9ucyAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5zdHlsaXplID09PSAnZnVuY3Rpb24nO1xuICAgIGlmIChzdHlsaXplRXhpc3RzKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnN0eWxpemU7XG4gICAgfVxufVxuXG5jb25zdCBCU09OX01BSk9SX1ZFUlNJT04gPSA2O1xuY29uc3QgQlNPTl9JTlQzMl9NQVggPSAweDdmZmZmZmZmO1xuY29uc3QgQlNPTl9JTlQzMl9NSU4gPSAtMHg4MDAwMDAwMDtcbmNvbnN0IEJTT05fSU5UNjRfTUFYID0gTWF0aC5wb3coMiwgNjMpIC0gMTtcbmNvbnN0IEJTT05fSU5UNjRfTUlOID0gLU1hdGgucG93KDIsIDYzKTtcbmNvbnN0IEpTX0lOVF9NQVggPSBNYXRoLnBvdygyLCA1Myk7XG5jb25zdCBKU19JTlRfTUlOID0gLU1hdGgucG93KDIsIDUzKTtcbmNvbnN0IEJTT05fREFUQV9OVU1CRVIgPSAxO1xuY29uc3QgQlNPTl9EQVRBX1NUUklORyA9IDI7XG5jb25zdCBCU09OX0RBVEFfT0JKRUNUID0gMztcbmNvbnN0IEJTT05fREFUQV9BUlJBWSA9IDQ7XG5jb25zdCBCU09OX0RBVEFfQklOQVJZID0gNTtcbmNvbnN0IEJTT05fREFUQV9VTkRFRklORUQgPSA2O1xuY29uc3QgQlNPTl9EQVRBX09JRCA9IDc7XG5jb25zdCBCU09OX0RBVEFfQk9PTEVBTiA9IDg7XG5jb25zdCBCU09OX0RBVEFfREFURSA9IDk7XG5jb25zdCBCU09OX0RBVEFfTlVMTCA9IDEwO1xuY29uc3QgQlNPTl9EQVRBX1JFR0VYUCA9IDExO1xuY29uc3QgQlNPTl9EQVRBX0RCUE9JTlRFUiA9IDEyO1xuY29uc3QgQlNPTl9EQVRBX0NPREUgPSAxMztcbmNvbnN0IEJTT05fREFUQV9TWU1CT0wgPSAxNDtcbmNvbnN0IEJTT05fREFUQV9DT0RFX1dfU0NPUEUgPSAxNTtcbmNvbnN0IEJTT05fREFUQV9JTlQgPSAxNjtcbmNvbnN0IEJTT05fREFUQV9USU1FU1RBTVAgPSAxNztcbmNvbnN0IEJTT05fREFUQV9MT05HID0gMTg7XG5jb25zdCBCU09OX0RBVEFfREVDSU1BTDEyOCA9IDE5O1xuY29uc3QgQlNPTl9EQVRBX01JTl9LRVkgPSAweGZmO1xuY29uc3QgQlNPTl9EQVRBX01BWF9LRVkgPSAweDdmO1xuY29uc3QgQlNPTl9CSU5BUllfU1VCVFlQRV9ERUZBVUxUID0gMDtcbmNvbnN0IEJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVcgPSA0O1xuY29uc3QgQlNPTlR5cGUgPSBPYmplY3QuZnJlZXplKHtcbiAgICBkb3VibGU6IDEsXG4gICAgc3RyaW5nOiAyLFxuICAgIG9iamVjdDogMyxcbiAgICBhcnJheTogNCxcbiAgICBiaW5EYXRhOiA1LFxuICAgIHVuZGVmaW5lZDogNixcbiAgICBvYmplY3RJZDogNyxcbiAgICBib29sOiA4LFxuICAgIGRhdGU6IDksXG4gICAgbnVsbDogMTAsXG4gICAgcmVnZXg6IDExLFxuICAgIGRiUG9pbnRlcjogMTIsXG4gICAgamF2YXNjcmlwdDogMTMsXG4gICAgc3ltYm9sOiAxNCxcbiAgICBqYXZhc2NyaXB0V2l0aFNjb3BlOiAxNSxcbiAgICBpbnQ6IDE2LFxuICAgIHRpbWVzdGFtcDogMTcsXG4gICAgbG9uZzogMTgsXG4gICAgZGVjaW1hbDogMTksXG4gICAgbWluS2V5OiAtMSxcbiAgICBtYXhLZXk6IDEyN1xufSk7XG5cbmNsYXNzIEJTT05FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBnZXQgYnNvbkVycm9yKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQlNPTkVycm9yJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgc3RhdGljIGlzQlNPTkVycm9yKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ2Jzb25FcnJvcicgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgIHZhbHVlLmJzb25FcnJvciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgJ25hbWUnIGluIHZhbHVlICYmXG4gICAgICAgICAgICAnbWVzc2FnZScgaW4gdmFsdWUgJiZcbiAgICAgICAgICAgICdzdGFjaycgaW4gdmFsdWUpO1xuICAgIH1cbn1cbmNsYXNzIEJTT05WZXJzaW9uRXJyb3IgZXh0ZW5kcyBCU09ORXJyb3Ige1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0JTT05WZXJzaW9uRXJyb3InO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYFVuc3VwcG9ydGVkIEJTT04gdmVyc2lvbiwgYnNvbiB0eXBlcyBtdXN0IGJlIGZyb20gYnNvbiAke0JTT05fTUFKT1JfVkVSU0lPTn0ueC54YCk7XG4gICAgfVxufVxuY2xhc3MgQlNPTlJ1bnRpbWVFcnJvciBleHRlbmRzIEJTT05FcnJvciB7XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQlNPTlJ1bnRpbWVFcnJvcic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgfVxufVxuXG5jb25zdCBGSVJTVF9CSVQgPSAweDgwO1xuY29uc3QgRklSU1RfVFdPX0JJVFMgPSAweGMwO1xuY29uc3QgRklSU1RfVEhSRUVfQklUUyA9IDB4ZTA7XG5jb25zdCBGSVJTVF9GT1VSX0JJVFMgPSAweGYwO1xuY29uc3QgRklSU1RfRklWRV9CSVRTID0gMHhmODtcbmNvbnN0IFRXT19CSVRfQ0hBUiA9IDB4YzA7XG5jb25zdCBUSFJFRV9CSVRfQ0hBUiA9IDB4ZTA7XG5jb25zdCBGT1VSX0JJVF9DSEFSID0gMHhmMDtcbmNvbnN0IENPTlRJTlVJTkdfQ0hBUiA9IDB4ODA7XG5mdW5jdGlvbiB2YWxpZGF0ZVV0ZjgoYnl0ZXMsIHN0YXJ0LCBlbmQpIHtcbiAgICBsZXQgY29udGludWF0aW9uID0gMDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCBieXRlID0gYnl0ZXNbaV07XG4gICAgICAgIGlmIChjb250aW51YXRpb24pIHtcbiAgICAgICAgICAgIGlmICgoYnl0ZSAmIEZJUlNUX1RXT19CSVRTKSAhPT0gQ09OVElOVUlOR19DSEFSKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWF0aW9uIC09IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYnl0ZSAmIEZJUlNUX0JJVCkge1xuICAgICAgICAgICAgaWYgKChieXRlICYgRklSU1RfVEhSRUVfQklUUykgPT09IFRXT19CSVRfQ0hBUikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVhdGlvbiA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoYnl0ZSAmIEZJUlNUX0ZPVVJfQklUUykgPT09IFRIUkVFX0JJVF9DSEFSKSB7XG4gICAgICAgICAgICAgICAgY29udGludWF0aW9uID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChieXRlICYgRklSU1RfRklWRV9CSVRTKSA9PT0gRk9VUl9CSVRfQ0hBUikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVhdGlvbiA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICFjb250aW51YXRpb247XG59XG5cbmZ1bmN0aW9uIHRyeUxhdGluKHVpbnQ4YXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICBpZiAodWludDhhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBjb25zdCBzdHJpbmdCeXRlTGVuZ3RoID0gZW5kIC0gc3RhcnQ7XG4gICAgaWYgKHN0cmluZ0J5dGVMZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nQnl0ZUxlbmd0aCA+IDIwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoc3RyaW5nQnl0ZUxlbmd0aCA9PT0gMSAmJiB1aW50OGFycmF5W3N0YXJ0XSA8IDEyOCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OGFycmF5W3N0YXJ0XSk7XG4gICAgfVxuICAgIGlmIChzdHJpbmdCeXRlTGVuZ3RoID09PSAyICYmIHVpbnQ4YXJyYXlbc3RhcnRdIDwgMTI4ICYmIHVpbnQ4YXJyYXlbc3RhcnQgKyAxXSA8IDEyOCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OGFycmF5W3N0YXJ0XSkgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4YXJyYXlbc3RhcnQgKyAxXSk7XG4gICAgfVxuICAgIGlmIChzdHJpbmdCeXRlTGVuZ3RoID09PSAzICYmXG4gICAgICAgIHVpbnQ4YXJyYXlbc3RhcnRdIDwgMTI4ICYmXG4gICAgICAgIHVpbnQ4YXJyYXlbc3RhcnQgKyAxXSA8IDEyOCAmJlxuICAgICAgICB1aW50OGFycmF5W3N0YXJ0ICsgMl0gPCAxMjgpIHtcbiAgICAgICAgcmV0dXJuIChTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4YXJyYXlbc3RhcnRdKSArXG4gICAgICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKHVpbnQ4YXJyYXlbc3RhcnQgKyAxXSkgK1xuICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSh1aW50OGFycmF5W3N0YXJ0ICsgMl0pKTtcbiAgICB9XG4gICAgY29uc3QgbGF0aW5CeXRlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJ5dGUgPSB1aW50OGFycmF5W2ldO1xuICAgICAgICBpZiAoYnl0ZSA+IDEyNykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbGF0aW5CeXRlcy5wdXNoKGJ5dGUpO1xuICAgIH1cbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5sYXRpbkJ5dGVzKTtcbn1cblxuZnVuY3Rpb24gbm9kZWpzTWF0aFJhbmRvbUJ5dGVzKGJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShBcnJheS5mcm9tKHsgbGVuZ3RoOiBieXRlTGVuZ3RoIH0sICgpID0+IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikpKTtcbn1cbmNvbnN0IG5vZGVqc1JhbmRvbUJ5dGVzID0gKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZSgnY3J5cHRvJykucmFuZG9tQnl0ZXM7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIG5vZGVqc01hdGhSYW5kb21CeXRlcztcbiAgICB9XG59KSgpO1xuY29uc3Qgbm9kZUpzQnl0ZVV0aWxzID0ge1xuICAgIHRvTG9jYWxCdWZmZXJUeXBlKHBvdGVudGlhbEJ1ZmZlcikge1xuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBvdGVudGlhbEJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBwb3RlbnRpYWxCdWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhwb3RlbnRpYWxCdWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocG90ZW50aWFsQnVmZmVyLmJ1ZmZlciwgcG90ZW50aWFsQnVmZmVyLmJ5dGVPZmZzZXQsIHBvdGVudGlhbEJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpbmdUYWcgPSBwb3RlbnRpYWxCdWZmZXI/LltTeW1ib2wudG9TdHJpbmdUYWddID8/IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwb3RlbnRpYWxCdWZmZXIpO1xuICAgICAgICBpZiAoc3RyaW5nVGFnID09PSAnQXJyYXlCdWZmZXInIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdTaGFyZWRBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20ocG90ZW50aWFsQnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBDYW5ub3QgY3JlYXRlIEJ1ZmZlciBmcm9tICR7U3RyaW5nKHBvdGVudGlhbEJ1ZmZlcil9YCk7XG4gICAgfSxcbiAgICBhbGxvY2F0ZShzaXplKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuYWxsb2Moc2l6ZSk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGEpLmVxdWFscyhiKTtcbiAgICB9LFxuICAgIGZyb21OdW1iZXJBcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oYXJyYXkpO1xuICAgIH0sXG4gICAgZnJvbUJhc2U2NChiYXNlNjQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJhc2U2NCwgJ2Jhc2U2NCcpO1xuICAgIH0sXG4gICAgdG9CYXNlNjQoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBub2RlSnNCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfSxcbiAgICBmcm9tSVNPODg1OTEoY29kZVBvaW50cykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oY29kZVBvaW50cywgJ2JpbmFyeScpO1xuICAgIH0sXG4gICAgdG9JU084ODU5MShidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLnRvU3RyaW5nKCdiaW5hcnknKTtcbiAgICB9LFxuICAgIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgsICdoZXgnKTtcbiAgICB9LFxuICAgIHRvSGV4KGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gbm9kZUpzQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlcikudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0sXG4gICAgZnJvbVVURjgodGV4dCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGV4dCwgJ3V0ZjgnKTtcbiAgICB9LFxuICAgIHRvVVRGOChidWZmZXIsIHN0YXJ0LCBlbmQsIGZhdGFsKSB7XG4gICAgICAgIGNvbnN0IGJhc2ljTGF0aW4gPSBlbmQgLSBzdGFydCA8PSAyMCA/IHRyeUxhdGluKGJ1ZmZlciwgc3RhcnQsIGVuZCkgOiBudWxsO1xuICAgICAgICBpZiAoYmFzaWNMYXRpbiAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzaWNMYXRpbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJpbmcgPSBub2RlSnNCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoYnVmZmVyKS50b1N0cmluZygndXRmOCcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAoZmF0YWwpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09PSAweGZmZmQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZVV0ZjgoYnVmZmVyLCBzdGFydCwgZW5kKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCBzdHJpbmcgaW4gQlNPTiBkb2N1bWVudCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH0sXG4gICAgdXRmOEJ5dGVMZW5ndGgoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKGlucHV0LCAndXRmOCcpO1xuICAgIH0sXG4gICAgZW5jb2RlVVRGOEludG8oYnVmZmVyLCBzb3VyY2UsIGJ5dGVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVKc0J5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLndyaXRlKHNvdXJjZSwgYnl0ZU9mZnNldCwgdW5kZWZpbmVkLCAndXRmOCcpO1xuICAgIH0sXG4gICAgcmFuZG9tQnl0ZXM6IG5vZGVqc1JhbmRvbUJ5dGVzXG59O1xuXG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xuICAgIGNvbnN0IHsgbmF2aWdhdG9yIH0gPSBnbG9iYWxUaGlzO1xuICAgIHJldHVybiB0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJztcbn1cbmZ1bmN0aW9uIHdlYk1hdGhSYW5kb21CeXRlcyhieXRlTGVuZ3RoKSB7XG4gICAgaWYgKGJ5dGVMZW5ndGggPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGUgYXJndW1lbnQgJ2J5dGVMZW5ndGgnIGlzIGludmFsaWQuIFJlY2VpdmVkICR7Ynl0ZUxlbmd0aH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHdlYkJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoQXJyYXkuZnJvbSh7IGxlbmd0aDogYnl0ZUxlbmd0aCB9LCAoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpKSk7XG59XG5jb25zdCB3ZWJSYW5kb21CeXRlcyA9ICgoKSA9PiB7XG4gICAgY29uc3QgeyBjcnlwdG8gfSA9IGdsb2JhbFRoaXM7XG4gICAgaWYgKGNyeXB0byAhPSBudWxsICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiAoYnl0ZUxlbmd0aCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMod2ViQnl0ZVV0aWxzLmFsbG9jYXRlKGJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY29uc29sZSB9ID0gZ2xvYmFsVGhpcztcbiAgICAgICAgICAgIGNvbnNvbGU/Lndhcm4/LignQlNPTjogRm9yIFJlYWN0IE5hdGl2ZSBwbGVhc2UgcG9seWZpbGwgY3J5cHRvLmdldFJhbmRvbVZhbHVlcywgZS5nLiB1c2luZzogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvcmVhY3QtbmF0aXZlLWdldC1yYW5kb20tdmFsdWVzLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ZWJNYXRoUmFuZG9tQnl0ZXM7XG4gICAgfVxufSkoKTtcbmNvbnN0IEhFWF9ESUdJVCA9IC8oXFxkfFthLWZdKS9pO1xuY29uc3Qgd2ViQnl0ZVV0aWxzID0ge1xuICAgIHRvTG9jYWxCdWZmZXJUeXBlKHBvdGVudGlhbFVpbnQ4YXJyYXkpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5nVGFnID0gcG90ZW50aWFsVWludDhhcnJheT8uW1N5bWJvbC50b1N0cmluZ1RhZ10gPz9cbiAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwb3RlbnRpYWxVaW50OGFycmF5KTtcbiAgICAgICAgaWYgKHN0cmluZ1RhZyA9PT0gJ1VpbnQ4QXJyYXknKSB7XG4gICAgICAgICAgICByZXR1cm4gcG90ZW50aWFsVWludDhhcnJheTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHBvdGVudGlhbFVpbnQ4YXJyYXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocG90ZW50aWFsVWludDhhcnJheS5idWZmZXIuc2xpY2UocG90ZW50aWFsVWludDhhcnJheS5ieXRlT2Zmc2V0LCBwb3RlbnRpYWxVaW50OGFycmF5LmJ5dGVPZmZzZXQgKyBwb3RlbnRpYWxVaW50OGFycmF5LmJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyaW5nVGFnID09PSAnQXJyYXlCdWZmZXInIHx8XG4gICAgICAgICAgICBzdHJpbmdUYWcgPT09ICdTaGFyZWRBcnJheUJ1ZmZlcicgfHxcbiAgICAgICAgICAgIHN0cmluZ1RhZyA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyB8fFxuICAgICAgICAgICAgc3RyaW5nVGFnID09PSAnW29iamVjdCBTaGFyZWRBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkocG90ZW50aWFsVWludDhhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQ2Fubm90IG1ha2UgYSBVaW50OEFycmF5IGZyb20gJHtTdHJpbmcocG90ZW50aWFsVWludDhhcnJheSl9YCk7XG4gICAgfSxcbiAgICBhbGxvY2F0ZShzaXplKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCAke1N0cmluZyhzaXplKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgfSxcbiAgICBlcXVhbHMoYSwgYikge1xuICAgICAgICBpZiAoYS5ieXRlTGVuZ3RoICE9PSBiLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGZyb21OdW1iZXJBcnJheShhcnJheSkge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5mcm9tKGFycmF5KTtcbiAgICB9LFxuICAgIGZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYXRvYihiYXNlNjQpLCBjID0+IGMuY2hhckNvZGVBdCgwKSk7XG4gICAgfSxcbiAgICB0b0Jhc2U2NCh1aW50OGFycmF5KSB7XG4gICAgICAgIHJldHVybiBidG9hKHdlYkJ5dGVVdGlscy50b0lTTzg4NTkxKHVpbnQ4YXJyYXkpKTtcbiAgICB9LFxuICAgIGZyb21JU084ODU5MShjb2RlUG9pbnRzKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oY29kZVBvaW50cywgYyA9PiBjLmNoYXJDb2RlQXQoMCkgJiAweGZmKTtcbiAgICB9LFxuICAgIHRvSVNPODg1OTEodWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShVaW50MTZBcnJheS5mcm9tKHVpbnQ4YXJyYXkpLCBiID0+IFN0cmluZy5mcm9tQ2hhckNvZGUoYikpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgZnJvbUhleChoZXgpIHtcbiAgICAgICAgY29uc3QgZXZlbkxlbmd0aEhleCA9IGhleC5sZW5ndGggJSAyID09PSAwID8gaGV4IDogaGV4LnNsaWNlKDAsIGhleC5sZW5ndGggLSAxKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbkxlbmd0aEhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3QgZmlyc3REaWdpdCA9IGV2ZW5MZW5ndGhIZXhbaV07XG4gICAgICAgICAgICBjb25zdCBzZWNvbmREaWdpdCA9IGV2ZW5MZW5ndGhIZXhbaSArIDFdO1xuICAgICAgICAgICAgaWYgKCFIRVhfRElHSVQudGVzdChmaXJzdERpZ2l0KSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFIRVhfRElHSVQudGVzdChzZWNvbmREaWdpdCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhleERpZ2l0ID0gTnVtYmVyLnBhcnNlSW50KGAke2ZpcnN0RGlnaXR9JHtzZWNvbmREaWdpdH1gLCAxNik7XG4gICAgICAgICAgICBidWZmZXIucHVzaChoZXhEaWdpdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShidWZmZXIpO1xuICAgIH0sXG4gICAgdG9IZXgodWludDhhcnJheSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh1aW50OGFycmF5LCBieXRlID0+IGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpLmpvaW4oJycpO1xuICAgIH0sXG4gICAgZnJvbVVURjgodGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHRleHQpO1xuICAgIH0sXG4gICAgdG9VVEY4KHVpbnQ4YXJyYXksIHN0YXJ0LCBlbmQsIGZhdGFsKSB7XG4gICAgICAgIGNvbnN0IGJhc2ljTGF0aW4gPSBlbmQgLSBzdGFydCA8PSAyMCA/IHRyeUxhdGluKHVpbnQ4YXJyYXksIHN0YXJ0LCBlbmQpIDogbnVsbDtcbiAgICAgICAgaWYgKGJhc2ljTGF0aW4gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2ljTGF0aW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZhdGFsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGZhdGFsIH0pLmRlY29kZSh1aW50OGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChjYXVzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0ludmFsaWQgVVRGLTggc3RyaW5nIGluIEJTT04gZG9jdW1lbnQnLCB7IGNhdXNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoJ3V0ZjgnLCB7IGZhdGFsIH0pLmRlY29kZSh1aW50OGFycmF5LnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICB9LFxuICAgIHV0ZjhCeXRlTGVuZ3RoKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB3ZWJCeXRlVXRpbHMuZnJvbVVURjgoaW5wdXQpLmJ5dGVMZW5ndGg7XG4gICAgfSxcbiAgICBlbmNvZGVVVEY4SW50byhidWZmZXIsIHNvdXJjZSwgYnl0ZU9mZnNldCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IHdlYkJ5dGVVdGlscy5mcm9tVVRGOChzb3VyY2UpO1xuICAgICAgICBidWZmZXIuc2V0KGJ5dGVzLCBieXRlT2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgfSxcbiAgICByYW5kb21CeXRlczogd2ViUmFuZG9tQnl0ZXNcbn07XG5cbmNvbnN0IGhhc0dsb2JhbEJ1ZmZlciA9IHR5cGVvZiBCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgQnVmZmVyLnByb3RvdHlwZT8uX2lzQnVmZmVyICE9PSB0cnVlO1xuY29uc3QgQnl0ZVV0aWxzID0gaGFzR2xvYmFsQnVmZmVyID8gbm9kZUpzQnl0ZVV0aWxzIDogd2ViQnl0ZVV0aWxzO1xuY2xhc3MgQlNPTkRhdGFWaWV3IGV4dGVuZHMgRGF0YVZpZXcge1xuICAgIHN0YXRpYyBmcm9tVWludDhBcnJheShpbnB1dCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGFWaWV3KGlucHV0LmJ1ZmZlciwgaW5wdXQuYnl0ZU9mZnNldCwgaW5wdXQuYnl0ZUxlbmd0aCk7XG4gICAgfVxufVxuXG5jbGFzcyBCU09OVmFsdWUge1xuICAgIGdldCBbU3ltYm9sLmZvcignQEBtZGIuYnNvbi52ZXJzaW9uJyldKCkge1xuICAgICAgICByZXR1cm4gQlNPTl9NQUpPUl9WRVJTSU9OO1xuICAgIH1cbiAgICBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0oZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCk7XG4gICAgfVxufVxuXG5jbGFzcyBCaW5hcnkgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnQmluYXJ5JztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBzdWJUeXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICghKGJ1ZmZlciA9PSBudWxsKSAmJlxuICAgICAgICAgICAgdHlwZW9mIGJ1ZmZlciA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgICFBcnJheUJ1ZmZlci5pc1ZpZXcoYnVmZmVyKSAmJlxuICAgICAgICAgICAgIWlzQW55QXJyYXlCdWZmZXIoYnVmZmVyKSAmJlxuICAgICAgICAgICAgIUFycmF5LmlzQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmluYXJ5IGNhbiBvbmx5IGJlIGNvbnN0cnVjdGVkIGZyb20gVWludDhBcnJheSBvciBudW1iZXJbXScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3ViX3R5cGUgPSBzdWJUeXBlID8/IEJpbmFyeS5CU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFQ7XG4gICAgICAgIGlmIChidWZmZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoQmluYXJ5LkJVRkZFUl9TSVpFKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBBcnJheS5pc0FycmF5KGJ1ZmZlcilcbiAgICAgICAgICAgICAgICA/IEJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoYnVmZmVyKVxuICAgICAgICAgICAgICAgIDogQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwdXQoYnl0ZVZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYnl0ZVZhbHVlID09PSAnc3RyaW5nJyAmJiBieXRlVmFsdWUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdvbmx5IGFjY2VwdHMgc2luZ2xlIGNoYXJhY3RlciBTdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYnl0ZVZhbHVlICE9PSAnbnVtYmVyJyAmJiBieXRlVmFsdWUubGVuZ3RoICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignb25seSBhY2NlcHRzIHNpbmdsZSBjaGFyYWN0ZXIgVWludDhBcnJheSBvciBBcnJheScpO1xuICAgICAgICBsZXQgZGVjb2RlZEJ5dGU7XG4gICAgICAgIGlmICh0eXBlb2YgYnl0ZVZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZGVjb2RlZEJ5dGUgPSBieXRlVmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYnl0ZVZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZGVjb2RlZEJ5dGUgPSBieXRlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWNvZGVkQnl0ZSA9IGJ5dGVWYWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVjb2RlZEJ5dGUgPCAwIHx8IGRlY29kZWRCeXRlID4gMjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdvbmx5IGFjY2VwdHMgbnVtYmVyIGluIGEgdmFsaWQgdW5zaWduZWQgYnl0ZSByYW5nZSAwLTI1NScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJ1ZmZlci5ieXRlTGVuZ3RoID4gdGhpcy5wb3NpdGlvbikge1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IGRlY29kZWRCeXRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U3BhY2UgPSBCeXRlVXRpbHMuYWxsb2NhdGUoQmluYXJ5LkJVRkZFUl9TSVpFICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgICAgIG5ld1NwYWNlLnNldCh0aGlzLmJ1ZmZlciwgMCk7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ld1NwYWNlO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJbdGhpcy5wb3NpdGlvbisrXSA9IGRlY29kZWRCeXRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlKHNlcXVlbmNlLCBvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gdHlwZW9mIG9mZnNldCA9PT0gJ251bWJlcicgPyBvZmZzZXQgOiB0aGlzLnBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCA8IG9mZnNldCArIHNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U3BhY2UgPSBCeXRlVXRpbHMuYWxsb2NhdGUodGhpcy5idWZmZXIuYnl0ZUxlbmd0aCArIHNlcXVlbmNlLmxlbmd0aCk7XG4gICAgICAgICAgICBuZXdTcGFjZS5zZXQodGhpcy5idWZmZXIsIDApO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIgPSBuZXdTcGFjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHNlcXVlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy5idWZmZXIuc2V0KEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShzZXF1ZW5jZSksIG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uID1cbiAgICAgICAgICAgICAgICBvZmZzZXQgKyBzZXF1ZW5jZS5ieXRlTGVuZ3RoID4gdGhpcy5wb3NpdGlvbiA/IG9mZnNldCArIHNlcXVlbmNlLmxlbmd0aCA6IHRoaXMucG9zaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNlcXVlbmNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaW5wdXQgY2Fubm90IGJlIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWQocG9zaXRpb24sIGxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSBsZW5ndGggJiYgbGVuZ3RoID4gMCA/IGxlbmd0aCA6IHRoaXMucG9zaXRpb247XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zbGljZShwb3NpdGlvbiwgcG9zaXRpb24gKyBsZW5ndGgpO1xuICAgIH1cbiAgICB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyLmxlbmd0aCA9PT0gdGhpcy5wb3NpdGlvblxuICAgICAgICAgICAgPyB0aGlzLmJ1ZmZlclxuICAgICAgICAgICAgOiB0aGlzLmJ1ZmZlci5zdWJhcnJheSgwLCB0aGlzLnBvc2l0aW9uKTtcbiAgICB9XG4gICAgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NpdGlvbjtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvQmFzZTY0KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoZW5jb2RpbmcpIHtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnaGV4JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0Jhc2U2NCh0aGlzLmJ1ZmZlcik7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ3V0ZjgnIHx8IGVuY29kaW5nID09PSAndXRmLTgnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b1VURjgodGhpcy5idWZmZXIsIDAsIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b1VURjgodGhpcy5idWZmZXIsIDAsIHRoaXMuYnVmZmVyLmJ5dGVMZW5ndGgsIGZhbHNlKTtcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgY29uc3QgYmFzZTY0U3RyaW5nID0gQnl0ZVV0aWxzLnRvQmFzZTY0KHRoaXMuYnVmZmVyKTtcbiAgICAgICAgY29uc3Qgc3ViVHlwZSA9IE51bWJlcih0aGlzLnN1Yl90eXBlKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAkYmluYXJ5OiBiYXNlNjRTdHJpbmcsXG4gICAgICAgICAgICAgICAgJHR5cGU6IHN1YlR5cGUubGVuZ3RoID09PSAxID8gJzAnICsgc3ViVHlwZSA6IHN1YlR5cGVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRiaW5hcnk6IHtcbiAgICAgICAgICAgICAgICBiYXNlNjQ6IGJhc2U2NFN0cmluZyxcbiAgICAgICAgICAgICAgICBzdWJUeXBlOiBzdWJUeXBlLmxlbmd0aCA9PT0gMSA/ICcwJyArIHN1YlR5cGUgOiBzdWJUeXBlXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvVVVJRCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3ViX3R5cGUgPT09IEJpbmFyeS5TVUJUWVBFX1VVSUQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVVVJRCh0aGlzLmJ1ZmZlci5zbGljZSgwLCB0aGlzLnBvc2l0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQmluYXJ5IHN1Yl90eXBlIFwiJHt0aGlzLnN1Yl90eXBlfVwiIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGNvbnZlcnRpbmcgdG8gVVVJRC4gT25seSBcIiR7QmluYXJ5LlNVQlRZUEVfVVVJRH1cIiBpcyBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbUhleFN0cmluZyhoZXgsIHN1YlR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkoQnl0ZVV0aWxzLmZyb21IZXgoaGV4KSwgc3ViVHlwZSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tQmFzZTY0KGJhc2U2NCwgc3ViVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpbmFyeShCeXRlVXRpbHMuZnJvbUJhc2U2NChiYXNlNjQpLCBzdWJUeXBlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgbGV0IHR5cGU7XG4gICAgICAgIGlmICgnJGJpbmFyeScgaW4gZG9jKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sZWdhY3kgJiYgdHlwZW9mIGRvYy4kYmluYXJ5ID09PSAnc3RyaW5nJyAmJiAnJHR5cGUnIGluIGRvYykge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBkb2MuJHR5cGUgPyBwYXJzZUludChkb2MuJHR5cGUsIDE2KSA6IDA7XG4gICAgICAgICAgICAgICAgZGF0YSA9IEJ5dGVVdGlscy5mcm9tQmFzZTY0KGRvYy4kYmluYXJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jLiRiaW5hcnkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBkb2MuJGJpbmFyeS5zdWJUeXBlID8gcGFyc2VJbnQoZG9jLiRiaW5hcnkuc3ViVHlwZSwgMTYpIDogMDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9IEJ5dGVVdGlscy5mcm9tQmFzZTY0KGRvYy4kYmluYXJ5LmJhc2U2NCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCckdXVpZCcgaW4gZG9jKSB7XG4gICAgICAgICAgICB0eXBlID0gNDtcbiAgICAgICAgICAgIGRhdGEgPSBVVUlELmJ5dGVzRnJvbVN0cmluZyhkb2MuJHV1aWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgVW5leHBlY3RlZCBCaW5hcnkgRXh0ZW5kZWQgSlNPTiBmb3JtYXQgJHtKU09OLnN0cmluZ2lmeShkb2MpfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlID09PSBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXID8gbmV3IFVVSUQoZGF0YSkgOiBuZXcgQmluYXJ5KGRhdGEsIHR5cGUpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBiYXNlNjQgPSBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgdGhpcy5wb3NpdGlvbikpO1xuICAgICAgICBjb25zdCBiYXNlNjRBcmcgPSBpbnNwZWN0KGJhc2U2NCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHN1YlR5cGVBcmcgPSBpbnNwZWN0KHRoaXMuc3ViX3R5cGUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYEJpbmFyeS5jcmVhdGVGcm9tQmFzZTY0KCR7YmFzZTY0QXJnfSwgJHtzdWJUeXBlQXJnfSlgO1xuICAgIH1cbn1cbkJpbmFyeS5CU09OX0JJTkFSWV9TVUJUWVBFX0RFRkFVTFQgPSAwO1xuQmluYXJ5LkJVRkZFUl9TSVpFID0gMjU2O1xuQmluYXJ5LlNVQlRZUEVfREVGQVVMVCA9IDA7XG5CaW5hcnkuU1VCVFlQRV9GVU5DVElPTiA9IDE7XG5CaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZID0gMjtcbkJpbmFyeS5TVUJUWVBFX1VVSURfT0xEID0gMztcbkJpbmFyeS5TVUJUWVBFX1VVSUQgPSA0O1xuQmluYXJ5LlNVQlRZUEVfTUQ1ID0gNTtcbkJpbmFyeS5TVUJUWVBFX0VOQ1JZUFRFRCA9IDY7XG5CaW5hcnkuU1VCVFlQRV9DT0xVTU4gPSA3O1xuQmluYXJ5LlNVQlRZUEVfVVNFUl9ERUZJTkVEID0gMTI4O1xuY29uc3QgVVVJRF9CWVRFX0xFTkdUSCA9IDE2O1xuY29uc3QgVVVJRF9XSVRIT1VUX0RBU0hFUyA9IC9eWzAtOUEtRl17MzJ9JC9pO1xuY29uc3QgVVVJRF9XSVRIX0RBU0hFUyA9IC9eWzAtOUEtRl17OH0tWzAtOUEtRl17NH0tWzAtOUEtRl17NH0tWzAtOUEtRl17NH0tWzAtOUEtRl17MTJ9JC9pO1xuY2xhc3MgVVVJRCBleHRlbmRzIEJpbmFyeSB7XG4gICAgY29uc3RydWN0b3IoaW5wdXQpIHtcbiAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICBpZiAoaW5wdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgYnl0ZXMgPSBVVUlELmdlbmVyYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBVVUlEKSB7XG4gICAgICAgICAgICBieXRlcyA9IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShuZXcgVWludDhBcnJheShpbnB1dC5idWZmZXIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoaW5wdXQpICYmIGlucHV0LmJ5dGVMZW5ndGggPT09IFVVSURfQllURV9MRU5HVEgpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gQnl0ZVV0aWxzLnRvTG9jYWxCdWZmZXJUeXBlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBieXRlcyA9IFVVSUQuYnl0ZXNGcm9tU3RyaW5nKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0FyZ3VtZW50IHBhc3NlZCBpbiBVVUlEIGNvbnN0cnVjdG9yIG11c3QgYmUgYSBVVUlELCBhIDE2IGJ5dGUgQnVmZmVyIG9yIGEgMzIvMzYgY2hhcmFjdGVyIGhleCBzdHJpbmcgKGRhc2hlcyBleGNsdWRlZC9pbmNsdWRlZCwgZm9ybWF0OiB4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHgpLicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKGJ5dGVzLCBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXKTtcbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gICAgfVxuICAgIHNldCBpZCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0hleFN0cmluZyhpbmNsdWRlRGFzaGVzID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5jbHVkZURhc2hlcykge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoMCwgNCkpLFxuICAgICAgICAgICAgICAgIEJ5dGVVdGlscy50b0hleCh0aGlzLmJ1ZmZlci5zdWJhcnJheSg0LCA2KSksXG4gICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnRvSGV4KHRoaXMuYnVmZmVyLnN1YmFycmF5KDYsIDgpKSxcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoOCwgMTApKSxcbiAgICAgICAgICAgICAgICBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIuc3ViYXJyYXkoMTAsIDE2KSlcbiAgICAgICAgICAgIF0uam9pbignLScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9IZXgodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB0b1N0cmluZyhlbmNvZGluZykge1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKVxuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy50b0hleCh0aGlzLmlkKTtcbiAgICAgICAgaWYgKGVuY29kaW5nID09PSAnYmFzZTY0JylcbiAgICAgICAgICAgIHJldHVybiBCeXRlVXRpbHMudG9CYXNlNjQodGhpcy5pZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVySWQpIHtcbiAgICAgICAgaWYgKCFvdGhlcklkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVySWQgaW5zdGFuY2VvZiBVVUlEKSB7XG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLmVxdWFscyhvdGhlcklkLmlkLCB0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJ5dGVVdGlscy5lcXVhbHMobmV3IFVVSUQob3RoZXJJZCkuaWQsIHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0JpbmFyeSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaW5hcnkodGhpcy5pZCwgQmluYXJ5LlNVQlRZUEVfVVVJRCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZW5lcmF0ZSgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBCeXRlVXRpbHMucmFuZG9tQnl0ZXMoVVVJRF9CWVRFX0xFTkdUSCk7XG4gICAgICAgIGJ5dGVzWzZdID0gKGJ5dGVzWzZdICYgMHgwZikgfCAweDQwO1xuICAgICAgICBieXRlc1s4XSA9IChieXRlc1s4XSAmIDB4M2YpIHwgMHg4MDtcbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZChpbnB1dCkge1xuICAgICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiBVVUlELmlzVmFsaWRVVUlEU3RyaW5nKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVaW50OEFycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0LmJ5dGVMZW5ndGggPT09IFVVSURfQllURV9MRU5HVEg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChpbnB1dC5fYnNvbnR5cGUgPT09ICdCaW5hcnknICYmXG4gICAgICAgICAgICBpbnB1dC5zdWJfdHlwZSA9PT0gdGhpcy5TVUJUWVBFX1VVSUQgJiZcbiAgICAgICAgICAgIGlucHV0LmJ1ZmZlci5ieXRlTGVuZ3RoID09PSAxNik7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSGV4U3RyaW5nKGhleFN0cmluZykge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBVVUlELmJ5dGVzRnJvbVN0cmluZyhoZXhTdHJpbmcpO1xuICAgICAgICByZXR1cm4gbmV3IFVVSUQoYnVmZmVyKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgICAgIHJldHVybiBuZXcgVVVJRChCeXRlVXRpbHMuZnJvbUJhc2U2NChiYXNlNjQpKTtcbiAgICB9XG4gICAgc3RhdGljIGJ5dGVzRnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbikge1xuICAgICAgICBpZiAoIVVVSUQuaXNWYWxpZFVVSURTdHJpbmcocmVwcmVzZW50YXRpb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdVVUlEIHN0cmluZyByZXByZXNlbnRhdGlvbiBtdXN0IGJlIDMyIGhleCBkaWdpdHMgb3IgY2Fub25pY2FsIGh5cGhlbmF0ZWQgcmVwcmVzZW50YXRpb24nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLmZyb21IZXgocmVwcmVzZW50YXRpb24ucmVwbGFjZSgvLS9nLCAnJykpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNWYWxpZFVVSURTdHJpbmcocmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFVVSURfV0lUSE9VVF9EQVNIRVMudGVzdChyZXByZXNlbnRhdGlvbikgfHwgVVVJRF9XSVRIX0RBU0hFUy50ZXN0KHJlcHJlc2VudGF0aW9uKTtcbiAgICB9XG4gICAgaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICBpbnNwZWN0ID8/PSBkZWZhdWx0SW5zcGVjdDtcbiAgICAgICAgcmV0dXJuIGBuZXcgVVVJRCgke2luc3BlY3QodGhpcy50b0hleFN0cmluZygpLCBvcHRpb25zKX0pYDtcbiAgICB9XG59XG5cbmNsYXNzIENvZGUgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnQ29kZSc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvZGUsIHNjb3BlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGUudG9TdHJpbmcoKTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlID8/IG51bGw7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29kZTogdGhpcy5jb2RlLCBzY29wZTogdGhpcy5zY29wZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvZGU6IHRoaXMuY29kZSB9O1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7ICRjb2RlOiB0aGlzLmNvZGUsICRzY29wZTogdGhpcy5zY29wZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7ICRjb2RlOiB0aGlzLmNvZGUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29kZShkb2MuJGNvZGUsIGRvYy4kc2NvcGUpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBsZXQgcGFyYW1ldGVyc1N0cmluZyA9IGluc3BlY3QodGhpcy5jb2RlLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbXVsdGlMaW5lRm4gPSBwYXJhbWV0ZXJzU3RyaW5nLmluY2x1ZGVzKCdcXG4nKTtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1ldGVyc1N0cmluZyArPSBgLCR7bXVsdGlMaW5lRm4gPyAnXFxuJyA6ICcgJ30ke2luc3BlY3QodGhpcy5zY29wZSwgb3B0aW9ucyl9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmRpbmdOZXdsaW5lID0gbXVsdGlMaW5lRm4gJiYgdGhpcy5zY29wZSA9PT0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGBuZXcgQ29kZSgke211bHRpTGluZUZuID8gJ1xcbicgOiAnJ30ke3BhcmFtZXRlcnNTdHJpbmd9JHtlbmRpbmdOZXdsaW5lID8gJ1xcbicgOiAnJ30pYDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGlzREJSZWZMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgJyRpZCcgaW4gdmFsdWUgJiZcbiAgICAgICAgdmFsdWUuJGlkICE9IG51bGwgJiZcbiAgICAgICAgJyRyZWYnIGluIHZhbHVlICYmXG4gICAgICAgIHR5cGVvZiB2YWx1ZS4kcmVmID09PSAnc3RyaW5nJyAmJlxuICAgICAgICAoISgnJGRiJyBpbiB2YWx1ZSkgfHwgKCckZGInIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS4kZGIgPT09ICdzdHJpbmcnKSkpO1xufVxuY2xhc3MgREJSZWYgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnREJSZWYnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihjb2xsZWN0aW9uLCBvaWQsIGRiLCBmaWVsZHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBjb2xsZWN0aW9uLnNwbGl0KCcuJyk7XG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIGRiID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb24gPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IGNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMub2lkID0gb2lkO1xuICAgICAgICB0aGlzLmRiID0gZGI7XG4gICAgICAgIHRoaXMuZmllbGRzID0gZmllbGRzIHx8IHt9O1xuICAgIH1cbiAgICBnZXQgbmFtZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uO1xuICAgIH1cbiAgICBzZXQgbmFtZXNwYWNlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGNvbnN0IG8gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICRyZWY6IHRoaXMuY29sbGVjdGlvbixcbiAgICAgICAgICAgICRpZDogdGhpcy5vaWRcbiAgICAgICAgfSwgdGhpcy5maWVsZHMpO1xuICAgICAgICBpZiAodGhpcy5kYiAhPSBudWxsKVxuICAgICAgICAgICAgby4kZGIgPSB0aGlzLmRiO1xuICAgICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04ob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgbGV0IG8gPSB7XG4gICAgICAgICAgICAkcmVmOiB0aGlzLmNvbGxlY3Rpb24sXG4gICAgICAgICAgICAkaWQ6IHRoaXMub2lkXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIG87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGIpXG4gICAgICAgICAgICBvLiRkYiA9IHRoaXMuZGI7XG4gICAgICAgIG8gPSBPYmplY3QuYXNzaWduKG8sIHRoaXMuZmllbGRzKTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYykge1xuICAgICAgICBjb25zdCBjb3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgZG9jKTtcbiAgICAgICAgZGVsZXRlIGNvcHkuJHJlZjtcbiAgICAgICAgZGVsZXRlIGNvcHkuJGlkO1xuICAgICAgICBkZWxldGUgY29weS4kZGI7XG4gICAgICAgIHJldHVybiBuZXcgREJSZWYoZG9jLiRyZWYsIGRvYy4kaWQsIGRvYy4kZGIsIGNvcHkpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBhcmdzID0gW1xuICAgICAgICAgICAgaW5zcGVjdCh0aGlzLm5hbWVzcGFjZSwgb3B0aW9ucyksXG4gICAgICAgICAgICBpbnNwZWN0KHRoaXMub2lkLCBvcHRpb25zKSxcbiAgICAgICAgICAgIC4uLih0aGlzLmRiID8gW2luc3BlY3QodGhpcy5kYiwgb3B0aW9ucyldIDogW10pLFxuICAgICAgICAgICAgLi4uKE9iamVjdC5rZXlzKHRoaXMuZmllbGRzKS5sZW5ndGggPiAwID8gW2luc3BlY3QodGhpcy5maWVsZHMsIG9wdGlvbnMpXSA6IFtdKVxuICAgICAgICBdO1xuICAgICAgICBhcmdzWzFdID0gaW5zcGVjdCA9PT0gZGVmYXVsdEluc3BlY3QgPyBgbmV3IE9iamVjdElkKCR7YXJnc1sxXX0pYCA6IGFyZ3NbMV07XG4gICAgICAgIHJldHVybiBgbmV3IERCUmVmKCR7YXJncy5qb2luKCcsICcpfSlgO1xuICAgIH1cbn1cblxubGV0IHdhc20gPSB1bmRlZmluZWQ7XG50cnkge1xuICAgIHdhc20gPSBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShuZXcgVWludDhBcnJheShbMCwgOTcsIDExNSwgMTA5LCAxLCAwLCAwLCAwLCAxLCAxMywgMiwgOTYsIDAsIDEsIDEyNywgOTYsIDQsIDEyNywgMTI3LCAxMjcsIDEyNywgMSwgMTI3LCAzLCA3LCA2LCAwLCAxLCAxLCAxLCAxLCAxLCA2LCA2LCAxLCAxMjcsIDEsIDY1LCAwLCAxMSwgNywgNTAsIDYsIDMsIDEwOSwgMTE3LCAxMDgsIDAsIDEsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTUsIDAsIDIsIDUsIDEwMCwgMTA1LCAxMTgsIDk1LCAxMTcsIDAsIDMsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTUsIDAsIDQsIDUsIDExNCwgMTAxLCAxMDksIDk1LCAxMTcsIDAsIDUsIDgsIDEwMywgMTAxLCAxMTYsIDk1LCAxMDQsIDEwNSwgMTAzLCAxMDQsIDAsIDAsIDEwLCAxOTEsIDEsIDYsIDQsIDAsIDM1LCAwLCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI2LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMjcsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTEsIDM2LCAxLCAxLCAxMjYsIDMyLCAwLCAxNzMsIDMyLCAxLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDMyLCAyLCAxNzMsIDMyLCAzLCAxNzMsIDY2LCAzMiwgMTM0LCAxMzIsIDEyOCwgMzQsIDQsIDY2LCAzMiwgMTM1LCAxNjcsIDM2LCAwLCAzMiwgNCwgMTY3LCAxMSwgMzYsIDEsIDEsIDEyNiwgMzIsIDAsIDE3MywgMzIsIDEsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMzIsIDIsIDE3MywgMzIsIDMsIDE3MywgNjYsIDMyLCAxMzQsIDEzMiwgMTI5LCAzNCwgNCwgNjYsIDMyLCAxMzUsIDE2NywgMzYsIDAsIDMyLCA0LCAxNjcsIDExLCAzNiwgMSwgMSwgMTI2LCAzMiwgMCwgMTczLCAzMiwgMSwgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAzMiwgMiwgMTczLCAzMiwgMywgMTczLCA2NiwgMzIsIDEzNCwgMTMyLCAxMzAsIDM0LCA0LCA2NiwgMzIsIDEzNSwgMTY3LCAzNiwgMCwgMzIsIDQsIDE2NywgMTFdKSksIHt9KS5leHBvcnRzO1xufVxuY2F0Y2gge1xufVxuY29uc3QgVFdPX1BXUl8xNl9EQkwgPSAxIDw8IDE2O1xuY29uc3QgVFdPX1BXUl8yNF9EQkwgPSAxIDw8IDI0O1xuY29uc3QgVFdPX1BXUl8zMl9EQkwgPSBUV09fUFdSXzE2X0RCTCAqIFRXT19QV1JfMTZfREJMO1xuY29uc3QgVFdPX1BXUl82NF9EQkwgPSBUV09fUFdSXzMyX0RCTCAqIFRXT19QV1JfMzJfREJMO1xuY29uc3QgVFdPX1BXUl82M19EQkwgPSBUV09fUFdSXzY0X0RCTCAvIDI7XG5jb25zdCBJTlRfQ0FDSEUgPSB7fTtcbmNvbnN0IFVJTlRfQ0FDSEUgPSB7fTtcbmNvbnN0IE1BWF9JTlQ2NF9TVFJJTkdfTEVOR1RIID0gMjA7XG5jb25zdCBERUNJTUFMX1JFR19FWCA9IC9eKFxcKz8wfChcXCt8LSk/WzEtOV1bMC05XSopJC87XG5jbGFzcyBMb25nIGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ0xvbmcnO1xuICAgIH1cbiAgICBnZXQgX19pc0xvbmdfXygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGxvdyA9IDAsIGhpZ2gsIHVuc2lnbmVkKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh0eXBlb2YgbG93ID09PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBMb25nLmZyb21CaWdJbnQobG93LCAhIWhpZ2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBMb25nLmZyb21TdHJpbmcobG93LCAhIWhpZ2gpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG93ID0gbG93IHwgMDtcbiAgICAgICAgICAgIHRoaXMuaGlnaCA9IGhpZ2ggfCAwO1xuICAgICAgICAgICAgdGhpcy51bnNpZ25lZCA9ICEhdW5zaWduZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGZyb21CaXRzKGxvd0JpdHMsIGhpZ2hCaXRzLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMsIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21JbnQodmFsdWUsIHVuc2lnbmVkKSB7XG4gICAgICAgIGxldCBvYmosIGNhY2hlZE9iaiwgY2FjaGU7XG4gICAgICAgIGlmICh1bnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPj4+PSAwO1xuICAgICAgICAgICAgaWYgKChjYWNoZSA9IDAgPD0gdmFsdWUgJiYgdmFsdWUgPCAyNTYpKSB7XG4gICAgICAgICAgICAgICAgY2FjaGVkT2JqID0gVUlOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IExvbmcuZnJvbUJpdHModmFsdWUsICh2YWx1ZSB8IDApIDwgMCA/IC0xIDogMCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoY2FjaGUpXG4gICAgICAgICAgICAgICAgVUlOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgfD0gMDtcbiAgICAgICAgICAgIGlmICgoY2FjaGUgPSAtMTI4IDw9IHZhbHVlICYmIHZhbHVlIDwgMTI4KSkge1xuICAgICAgICAgICAgICAgIGNhY2hlZE9iaiA9IElOVF9DQUNIRVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZE9iailcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZE9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9iaiA9IExvbmcuZnJvbUJpdHModmFsdWUsIHZhbHVlIDwgMCA/IC0xIDogMCwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGNhY2hlKVxuICAgICAgICAgICAgICAgIElOVF9DQUNIRVt2YWx1ZV0gPSBvYmo7XG4gICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTnVtYmVyKHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHVuc2lnbmVkID8gTG9uZy5VWkVSTyA6IExvbmcuWkVSTztcbiAgICAgICAgaWYgKHVuc2lnbmVkKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLlVaRVJPO1xuICAgICAgICAgICAgaWYgKHZhbHVlID49IFRXT19QV1JfNjRfREJMKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLk1BWF9VTlNJR05FRF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8PSAtVFdPX1BXUl82M19EQkwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1ZBTFVFO1xuICAgICAgICAgICAgaWYgKHZhbHVlICsgMSA+PSBUV09fUFdSXzYzX0RCTClcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMClcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIoLXZhbHVlLCB1bnNpZ25lZCkubmVnKCk7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHZhbHVlICUgVFdPX1BXUl8zMl9EQkwgfCAwLCAodmFsdWUgLyBUV09fUFdSXzMyX0RCTCkgfCAwLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmlnSW50KHZhbHVlLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tU3RyaW5nKHZhbHVlLnRvU3RyaW5nKCksIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcoc3RyLCB1bnNpZ25lZCwgcmFkaXgpIHtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdlbXB0eSBzdHJpbmcnKTtcbiAgICAgICAgaWYgKHN0ciA9PT0gJ05hTicgfHwgc3RyID09PSAnSW5maW5pdHknIHx8IHN0ciA9PT0gJytJbmZpbml0eScgfHwgc3RyID09PSAnLUluZmluaXR5JylcbiAgICAgICAgICAgIHJldHVybiBMb25nLlpFUk87XG4gICAgICAgIGlmICh0eXBlb2YgdW5zaWduZWQgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAocmFkaXggPSB1bnNpZ25lZCksICh1bnNpZ25lZCA9IGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVuc2lnbmVkID0gISF1bnNpZ25lZDtcbiAgICAgICAgfVxuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdyYWRpeCcpO1xuICAgICAgICBsZXQgcDtcbiAgICAgICAgaWYgKChwID0gc3RyLmluZGV4T2YoJy0nKSkgPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaW50ZXJpb3IgaHlwaGVuJyk7XG4gICAgICAgIGVsc2UgaWYgKHAgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcoc3RyLnN1YnN0cmluZygxKSwgdW5zaWduZWQsIHJhZGl4KS5uZWcoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYWRpeFRvUG93ZXIgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIDgpKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IExvbmcuWkVSTztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpICs9IDgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBNYXRoLm1pbig4LCBzdHIubGVuZ3RoIC0gaSksIHZhbHVlID0gcGFyc2VJbnQoc3RyLnN1YnN0cmluZyhpLCBpICsgc2l6ZSksIHJhZGl4KTtcbiAgICAgICAgICAgIGlmIChzaXplIDwgOCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBvd2VyID0gTG9uZy5mcm9tTnVtYmVyKE1hdGgucG93KHJhZGl4LCBzaXplKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChwb3dlcikuYWRkKExvbmcuZnJvbU51bWJlcih2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0Lm11bChyYWRpeFRvUG93ZXIpO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5hZGQoTG9uZy5mcm9tTnVtYmVyKHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnVuc2lnbmVkID0gdW5zaWduZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMsIHVuc2lnbmVkLCBsZSkge1xuICAgICAgICByZXR1cm4gbGUgPyBMb25nLmZyb21CeXRlc0xFKGJ5dGVzLCB1bnNpZ25lZCkgOiBMb25nLmZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXNMRShieXRlcywgdW5zaWduZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMb25nKGJ5dGVzWzBdIHwgKGJ5dGVzWzFdIDw8IDgpIHwgKGJ5dGVzWzJdIDw8IDE2KSB8IChieXRlc1szXSA8PCAyNCksIGJ5dGVzWzRdIHwgKGJ5dGVzWzVdIDw8IDgpIHwgKGJ5dGVzWzZdIDw8IDE2KSB8IChieXRlc1s3XSA8PCAyNCksIHVuc2lnbmVkKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlc0JFKGJ5dGVzLCB1bnNpZ25lZCkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmcoKGJ5dGVzWzRdIDw8IDI0KSB8IChieXRlc1s1XSA8PCAxNikgfCAoYnl0ZXNbNl0gPDwgOCkgfCBieXRlc1s3XSwgKGJ5dGVzWzBdIDw8IDI0KSB8IChieXRlc1sxXSA8PCAxNikgfCAoYnl0ZXNbMl0gPDwgOCkgfCBieXRlc1szXSwgdW5zaWduZWQpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNMb25nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgJ19faXNMb25nX18nIGluIHZhbHVlICYmXG4gICAgICAgICAgICB2YWx1ZS5fX2lzTG9uZ19fID09PSB0cnVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21WYWx1ZSh2YWwsIHVuc2lnbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21OdW1iZXIodmFsLCB1bnNpZ25lZCk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21TdHJpbmcodmFsLCB1bnNpZ25lZCk7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHZhbC5sb3csIHZhbC5oaWdoLCB0eXBlb2YgdW5zaWduZWQgPT09ICdib29sZWFuJyA/IHVuc2lnbmVkIDogdmFsLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgYWRkKGFkZGVuZCkge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKGFkZGVuZCkpXG4gICAgICAgICAgICBhZGRlbmQgPSBMb25nLmZyb21WYWx1ZShhZGRlbmQpO1xuICAgICAgICBjb25zdCBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICAgICAgY29uc3QgYTAwID0gdGhpcy5sb3cgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGI0OCA9IGFkZGVuZC5oaWdoID4+PiAxNjtcbiAgICAgICAgY29uc3QgYjMyID0gYWRkZW5kLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGIxNiA9IGFkZGVuZC5sb3cgPj4+IDE2O1xuICAgICAgICBjb25zdCBiMDAgPSBhZGRlbmQubG93ICYgMHhmZmZmO1xuICAgICAgICBsZXQgYzQ4ID0gMCwgYzMyID0gMCwgYzE2ID0gMCwgYzAwID0gMDtcbiAgICAgICAgYzAwICs9IGEwMCArIGIwMDtcbiAgICAgICAgYzE2ICs9IGMwMCA+Pj4gMTY7XG4gICAgICAgIGMwMCAmPSAweGZmZmY7XG4gICAgICAgIGMxNiArPSBhMTYgKyBiMTY7XG4gICAgICAgIGMzMiArPSBjMTYgPj4+IDE2O1xuICAgICAgICBjMTYgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTMyICsgYjMyO1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzQ4ICs9IGE0OCArIGI0ODtcbiAgICAgICAgYzQ4ICY9IDB4ZmZmZjtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoKGMxNiA8PCAxNikgfCBjMDAsIChjNDggPDwgMTYpIHwgYzMyLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgYW5kKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93ICYgb3RoZXIubG93LCB0aGlzLmhpZ2ggJiBvdGhlci5oaWdoLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgY29tcGFyZShvdGhlcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY29uc3QgdGhpc05lZyA9IHRoaXMuaXNOZWdhdGl2ZSgpLCBvdGhlck5lZyA9IG90aGVyLmlzTmVnYXRpdmUoKTtcbiAgICAgICAgaWYgKHRoaXNOZWcgJiYgIW90aGVyTmVnKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoIXRoaXNOZWcgJiYgb3RoZXJOZWcpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKCF0aGlzLnVuc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ViKG90aGVyKS5pc05lZ2F0aXZlKCkgPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiBvdGhlci5oaWdoID4+PiAwID4gdGhpcy5oaWdoID4+PiAwIHx8XG4gICAgICAgICAgICAob3RoZXIuaGlnaCA9PT0gdGhpcy5oaWdoICYmIG90aGVyLmxvdyA+Pj4gMCA+IHRoaXMubG93ID4+PiAwKVxuICAgICAgICAgICAgPyAtMVxuICAgICAgICAgICAgOiAxO1xuICAgIH1cbiAgICBjb21wKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUob3RoZXIpO1xuICAgIH1cbiAgICBkaXZpZGUoZGl2aXNvcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKGRpdmlzb3IpKVxuICAgICAgICAgICAgZGl2aXNvciA9IExvbmcuZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgICAgICBpZiAoZGl2aXNvci5pc1plcm8oKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2RpdmlzaW9uIGJ5IHplcm8nKTtcbiAgICAgICAgaWYgKHdhc20pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaGlnaCA9PT0gLTB4ODAwMDAwMDAgJiZcbiAgICAgICAgICAgICAgICBkaXZpc29yLmxvdyA9PT0gLTEgJiZcbiAgICAgICAgICAgICAgICBkaXZpc29yLmhpZ2ggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsb3cgPSAodGhpcy51bnNpZ25lZCA/IHdhc20uZGl2X3UgOiB3YXNtLmRpdl9zKSh0aGlzLmxvdywgdGhpcy5oaWdoLCBkaXZpc29yLmxvdywgZGl2aXNvci5oaWdoKTtcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGxvdywgd2FzbS5nZXRfaGlnaCgpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnVuc2lnbmVkID8gTG9uZy5VWkVSTyA6IExvbmcuWkVSTztcbiAgICAgICAgbGV0IGFwcHJveCwgcmVtLCByZXM7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuZXEoTG9uZy5PTkUpIHx8IGRpdmlzb3IuZXEoTG9uZy5ORUdfT05FKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuTUlOX1ZBTFVFO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpdmlzb3IuZXEoTG9uZy5NSU5fVkFMVUUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5PTkU7XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbGZUaGlzID0gdGhpcy5zaHIoMSk7XG4gICAgICAgICAgICAgICAgICAgIGFwcHJveCA9IGhhbGZUaGlzLmRpdihkaXZpc29yKS5zaGwoMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcHByb3guZXEoTG9uZy5aRVJPKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpdmlzb3IuaXNOZWdhdGl2ZSgpID8gTG9uZy5PTkUgOiBMb25nLk5FR19PTkU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW0gPSB0aGlzLnN1YihkaXZpc29yLm11bChhcHByb3gpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGFwcHJveC5hZGQocmVtLmRpdihkaXZpc29yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyBMb25nLlVaRVJPIDogTG9uZy5aRVJPO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpdmlzb3IuaXNOZWdhdGl2ZSgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5kaXYoZGl2aXNvci5uZWcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmVnKCkuZGl2KGRpdmlzb3IpLm5lZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGl2aXNvci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGl2KGRpdmlzb3IubmVnKCkpLm5lZygpO1xuICAgICAgICAgICAgcmVzID0gTG9uZy5aRVJPO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFkaXZpc29yLnVuc2lnbmVkKVxuICAgICAgICAgICAgICAgIGRpdmlzb3IgPSBkaXZpc29yLnRvVW5zaWduZWQoKTtcbiAgICAgICAgICAgIGlmIChkaXZpc29yLmd0KHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLlVaRVJPO1xuICAgICAgICAgICAgaWYgKGRpdmlzb3IuZ3QodGhpcy5zaHJ1KDEpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gTG9uZy5VT05FO1xuICAgICAgICAgICAgcmVzID0gTG9uZy5VWkVSTztcbiAgICAgICAgfVxuICAgICAgICByZW0gPSB0aGlzO1xuICAgICAgICB3aGlsZSAocmVtLmd0ZShkaXZpc29yKSkge1xuICAgICAgICAgICAgYXBwcm94ID0gTWF0aC5tYXgoMSwgTWF0aC5mbG9vcihyZW0udG9OdW1iZXIoKSAvIGRpdmlzb3IudG9OdW1iZXIoKSkpO1xuICAgICAgICAgICAgY29uc3QgbG9nMiA9IE1hdGguY2VpbChNYXRoLmxvZyhhcHByb3gpIC8gTWF0aC5MTjIpO1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBsb2cyIDw9IDQ4ID8gMSA6IE1hdGgucG93KDIsIGxvZzIgLSA0OCk7XG4gICAgICAgICAgICBsZXQgYXBwcm94UmVzID0gTG9uZy5mcm9tTnVtYmVyKGFwcHJveCk7XG4gICAgICAgICAgICBsZXQgYXBwcm94UmVtID0gYXBwcm94UmVzLm11bChkaXZpc29yKTtcbiAgICAgICAgICAgIHdoaWxlIChhcHByb3hSZW0uaXNOZWdhdGl2ZSgpIHx8IGFwcHJveFJlbS5ndChyZW0pKSB7XG4gICAgICAgICAgICAgICAgYXBwcm94IC09IGRlbHRhO1xuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IExvbmcuZnJvbU51bWJlcihhcHByb3gsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgICAgICAgIGFwcHJveFJlbSA9IGFwcHJveFJlcy5tdWwoZGl2aXNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXBwcm94UmVzLmlzWmVybygpKVxuICAgICAgICAgICAgICAgIGFwcHJveFJlcyA9IExvbmcuT05FO1xuICAgICAgICAgICAgcmVzID0gcmVzLmFkZChhcHByb3hSZXMpO1xuICAgICAgICAgICAgcmVtID0gcmVtLnN1YihhcHByb3hSZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGRpdihkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdmlkZShkaXZpc29yKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGlmICghTG9uZy5pc0xvbmcob3RoZXIpKVxuICAgICAgICAgICAgb3RoZXIgPSBMb25nLmZyb21WYWx1ZShvdGhlcik7XG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkICE9PSBvdGhlci51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPj4+IDMxID09PSAxICYmIG90aGVyLmhpZ2ggPj4+IDMxID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSBvdGhlci5oaWdoICYmIHRoaXMubG93ID09PSBvdGhlci5sb3c7XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhvdGhlcik7XG4gICAgfVxuICAgIGdldEhpZ2hCaXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoO1xuICAgIH1cbiAgICBnZXRIaWdoQml0c1Vuc2lnbmVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID4+PiAwO1xuICAgIH1cbiAgICBnZXRMb3dCaXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb3c7XG4gICAgfVxuICAgIGdldExvd0JpdHNVbnNpZ25lZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG93ID4+PiAwO1xuICAgIH1cbiAgICBnZXROdW1CaXRzQWJzKCkge1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxKExvbmcuTUlOX1ZBTFVFKSA/IDY0IDogdGhpcy5uZWcoKS5nZXROdW1CaXRzQWJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5oaWdoICE9PSAwID8gdGhpcy5oaWdoIDogdGhpcy5sb3c7XG4gICAgICAgIGxldCBiaXQ7XG4gICAgICAgIGZvciAoYml0ID0gMzE7IGJpdCA+IDA7IGJpdC0tKVxuICAgICAgICAgICAgaWYgKCh2YWwgJiAoMSA8PCBiaXQpKSAhPT0gMClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlnaCAhPT0gMCA/IGJpdCArIDMzIDogYml0ICsgMTtcbiAgICB9XG4gICAgZ3JlYXRlclRoYW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcChvdGhlcikgPiAwO1xuICAgIH1cbiAgICBndChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmVhdGVyVGhhbihvdGhlcik7XG4gICAgfVxuICAgIGdyZWF0ZXJUaGFuT3JFcXVhbChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA+PSAwO1xuICAgIH1cbiAgICBndGUob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKTtcbiAgICB9XG4gICAgZ2Uob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JlYXRlclRoYW5PckVxdWFsKG90aGVyKTtcbiAgICB9XG4gICAgaXNFdmVuKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMubG93ICYgMSkgPT09IDA7XG4gICAgfVxuICAgIGlzTmVnYXRpdmUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy51bnNpZ25lZCAmJiB0aGlzLmhpZ2ggPCAwO1xuICAgIH1cbiAgICBpc09kZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxvdyAmIDEpID09PSAxO1xuICAgIH1cbiAgICBpc1Bvc2l0aXZlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy51bnNpZ25lZCB8fCB0aGlzLmhpZ2ggPj0gMDtcbiAgICB9XG4gICAgaXNaZXJvKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oaWdoID09PSAwICYmIHRoaXMubG93ID09PSAwO1xuICAgIH1cbiAgICBsZXNzVGhhbihvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21wKG90aGVyKSA8IDA7XG4gICAgfVxuICAgIGx0KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlc3NUaGFuKG90aGVyKTtcbiAgICB9XG4gICAgbGVzc1RoYW5PckVxdWFsKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXAob3RoZXIpIDw9IDA7XG4gICAgfVxuICAgIGx0ZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXNzVGhhbk9yRXF1YWwob3RoZXIpO1xuICAgIH1cbiAgICBtb2R1bG8oZGl2aXNvcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKGRpdmlzb3IpKVxuICAgICAgICAgICAgZGl2aXNvciA9IExvbmcuZnJvbVZhbHVlKGRpdmlzb3IpO1xuICAgICAgICBpZiAod2FzbSkge1xuICAgICAgICAgICAgY29uc3QgbG93ID0gKHRoaXMudW5zaWduZWQgPyB3YXNtLnJlbV91IDogd2FzbS5yZW1fcykodGhpcy5sb3csIHRoaXMuaGlnaCwgZGl2aXNvci5sb3csIGRpdmlzb3IuaGlnaCk7XG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyhsb3csIHdhc20uZ2V0X2hpZ2goKSwgdGhpcy51bnNpZ25lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKHRoaXMuZGl2KGRpdmlzb3IpLm11bChkaXZpc29yKSk7XG4gICAgfVxuICAgIG1vZChkaXZpc29yKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsbyhkaXZpc29yKTtcbiAgICB9XG4gICAgcmVtKGRpdmlzb3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9kdWxvKGRpdmlzb3IpO1xuICAgIH1cbiAgICBtdWx0aXBseShtdWx0aXBsaWVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhtdWx0aXBsaWVyKSlcbiAgICAgICAgICAgIG11bHRpcGxpZXIgPSBMb25nLmZyb21WYWx1ZShtdWx0aXBsaWVyKTtcbiAgICAgICAgaWYgKHdhc20pIHtcbiAgICAgICAgICAgIGNvbnN0IGxvdyA9IHdhc20ubXVsKHRoaXMubG93LCB0aGlzLmhpZ2gsIG11bHRpcGxpZXIubG93LCBtdWx0aXBsaWVyLmhpZ2gpO1xuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMobG93LCB3YXNtLmdldF9oaWdoKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdWx0aXBsaWVyLmlzWmVybygpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuWkVSTztcbiAgICAgICAgaWYgKHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKVxuICAgICAgICAgICAgcmV0dXJuIG11bHRpcGxpZXIuaXNPZGQoKSA/IExvbmcuTUlOX1ZBTFVFIDogTG9uZy5aRVJPO1xuICAgICAgICBpZiAobXVsdGlwbGllci5lcShMb25nLk1JTl9WQUxVRSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pc09kZCgpID8gTG9uZy5NSU5fVkFMVUUgOiBMb25nLlpFUk87XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgaWYgKG11bHRpcGxpZXIuaXNOZWdhdGl2ZSgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5lZygpLm11bChtdWx0aXBsaWVyLm5lZygpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZWcoKS5tdWwobXVsdGlwbGllcikubmVnKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobXVsdGlwbGllci5pc05lZ2F0aXZlKCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWwobXVsdGlwbGllci5uZWcoKSkubmVnKCk7XG4gICAgICAgIGlmICh0aGlzLmx0KExvbmcuVFdPX1BXUl8yNCkgJiYgbXVsdGlwbGllci5sdChMb25nLlRXT19QV1JfMjQpKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcih0aGlzLnRvTnVtYmVyKCkgKiBtdWx0aXBsaWVyLnRvTnVtYmVyKCksIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBjb25zdCBhNDggPSB0aGlzLmhpZ2ggPj4+IDE2O1xuICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmhpZ2ggJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGExNiA9IHRoaXMubG93ID4+PiAxNjtcbiAgICAgICAgY29uc3QgYTAwID0gdGhpcy5sb3cgJiAweGZmZmY7XG4gICAgICAgIGNvbnN0IGI0OCA9IG11bHRpcGxpZXIuaGlnaCA+Pj4gMTY7XG4gICAgICAgIGNvbnN0IGIzMiA9IG11bHRpcGxpZXIuaGlnaCAmIDB4ZmZmZjtcbiAgICAgICAgY29uc3QgYjE2ID0gbXVsdGlwbGllci5sb3cgPj4+IDE2O1xuICAgICAgICBjb25zdCBiMDAgPSBtdWx0aXBsaWVyLmxvdyAmIDB4ZmZmZjtcbiAgICAgICAgbGV0IGM0OCA9IDAsIGMzMiA9IDAsIGMxNiA9IDAsIGMwMCA9IDA7XG4gICAgICAgIGMwMCArPSBhMDAgKiBiMDA7XG4gICAgICAgIGMxNiArPSBjMDAgPj4+IDE2O1xuICAgICAgICBjMDAgJj0gMHhmZmZmO1xuICAgICAgICBjMTYgKz0gYTE2ICogYjAwO1xuICAgICAgICBjMzIgKz0gYzE2ID4+PiAxNjtcbiAgICAgICAgYzE2ICY9IDB4ZmZmZjtcbiAgICAgICAgYzE2ICs9IGEwMCAqIGIxNjtcbiAgICAgICAgYzMyICs9IGMxNiA+Pj4gMTY7XG4gICAgICAgIGMxNiAmPSAweGZmZmY7XG4gICAgICAgIGMzMiArPSBhMzIgKiBiMDA7XG4gICAgICAgIGM0OCArPSBjMzIgPj4+IDE2O1xuICAgICAgICBjMzIgJj0gMHhmZmZmO1xuICAgICAgICBjMzIgKz0gYTE2ICogYjE2O1xuICAgICAgICBjNDggKz0gYzMyID4+PiAxNjtcbiAgICAgICAgYzMyICY9IDB4ZmZmZjtcbiAgICAgICAgYzMyICs9IGEwMCAqIGIzMjtcbiAgICAgICAgYzQ4ICs9IGMzMiA+Pj4gMTY7XG4gICAgICAgIGMzMiAmPSAweGZmZmY7XG4gICAgICAgIGM0OCArPSBhNDggKiBiMDAgKyBhMzIgKiBiMTYgKyBhMTYgKiBiMzIgKyBhMDAgKiBiNDg7XG4gICAgICAgIGM0OCAmPSAweGZmZmY7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChjMTYgPDwgMTYpIHwgYzAwLCAoYzQ4IDw8IDE2KSB8IGMzMiwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIG11bChtdWx0aXBsaWVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KG11bHRpcGxpZXIpO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGlmICghdGhpcy51bnNpZ25lZCAmJiB0aGlzLmVxKExvbmcuTUlOX1ZBTFVFKSlcbiAgICAgICAgICAgIHJldHVybiBMb25nLk1JTl9WQUxVRTtcbiAgICAgICAgcmV0dXJuIHRoaXMubm90KCkuYWRkKExvbmcuT05FKTtcbiAgICB9XG4gICAgbmVnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGUoKTtcbiAgICB9XG4gICAgbm90KCkge1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh+dGhpcy5sb3csIH50aGlzLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBub3RFcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmVxdWFscyhvdGhlcik7XG4gICAgfVxuICAgIG5lcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RFcXVhbHMob3RoZXIpO1xuICAgIH1cbiAgICBuZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5ub3RFcXVhbHMob3RoZXIpO1xuICAgIH1cbiAgICBvcihvdGhlcikge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKG90aGVyKSlcbiAgICAgICAgICAgIG90aGVyID0gTG9uZy5mcm9tVmFsdWUob3RoZXIpO1xuICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmxvdyB8IG90aGVyLmxvdywgdGhpcy5oaWdoIHwgb3RoZXIuaGlnaCwgdGhpcy51bnNpZ25lZCk7XG4gICAgfVxuICAgIHNoaWZ0TGVmdChudW1CaXRzKSB7XG4gICAgICAgIGlmIChMb25nLmlzTG9uZyhudW1CaXRzKSlcbiAgICAgICAgICAgIG51bUJpdHMgPSBudW1CaXRzLnRvSW50KCk7XG4gICAgICAgIGlmICgobnVtQml0cyAmPSA2MykgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSBpZiAobnVtQml0cyA8IDMyKVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgPDwgbnVtQml0cywgKHRoaXMuaGlnaCA8PCBudW1CaXRzKSB8ICh0aGlzLmxvdyA+Pj4gKDMyIC0gbnVtQml0cykpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHMoMCwgdGhpcy5sb3cgPDwgKG51bUJpdHMgLSAzMiksIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBzaGwobnVtQml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5zaGlmdExlZnQobnVtQml0cyk7XG4gICAgfVxuICAgIHNoaWZ0UmlnaHQobnVtQml0cykge1xuICAgICAgICBpZiAoTG9uZy5pc0xvbmcobnVtQml0cykpXG4gICAgICAgICAgICBudW1CaXRzID0gbnVtQml0cy50b0ludCgpO1xuICAgICAgICBpZiAoKG51bUJpdHMgJj0gNjMpID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPCAzMilcbiAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKCh0aGlzLmxvdyA+Pj4gbnVtQml0cykgfCAodGhpcy5oaWdoIDw8ICgzMiAtIG51bUJpdHMpKSwgdGhpcy5oaWdoID4+IG51bUJpdHMsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gTG9uZy5mcm9tQml0cyh0aGlzLmhpZ2ggPj4gKG51bUJpdHMgLSAzMiksIHRoaXMuaGlnaCA+PSAwID8gMCA6IC0xLCB0aGlzLnVuc2lnbmVkKTtcbiAgICB9XG4gICAgc2hyKG51bUJpdHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hpZnRSaWdodChudW1CaXRzKTtcbiAgICB9XG4gICAgc2hpZnRSaWdodFVuc2lnbmVkKG51bUJpdHMpIHtcbiAgICAgICAgaWYgKExvbmcuaXNMb25nKG51bUJpdHMpKVxuICAgICAgICAgICAgbnVtQml0cyA9IG51bUJpdHMudG9JbnQoKTtcbiAgICAgICAgbnVtQml0cyAmPSA2MztcbiAgICAgICAgaWYgKG51bUJpdHMgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBoaWdoID0gdGhpcy5oaWdoO1xuICAgICAgICAgICAgaWYgKG51bUJpdHMgPCAzMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvdyA9IHRoaXMubG93O1xuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKChsb3cgPj4+IG51bUJpdHMpIHwgKGhpZ2ggPDwgKDMyIC0gbnVtQml0cykpLCBoaWdoID4+PiBudW1CaXRzLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG51bUJpdHMgPT09IDMyKVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGhpZ2gsIDAsIHRoaXMudW5zaWduZWQpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKGhpZ2ggPj4+IChudW1CaXRzIC0gMzIpLCAwLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzaHJfdShudW1CaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKTtcbiAgICB9XG4gICAgc2hydShudW1CaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNoaWZ0UmlnaHRVbnNpZ25lZChudW1CaXRzKTtcbiAgICB9XG4gICAgc3VidHJhY3Qoc3VidHJhaGVuZCkge1xuICAgICAgICBpZiAoIUxvbmcuaXNMb25nKHN1YnRyYWhlbmQpKVxuICAgICAgICAgICAgc3VidHJhaGVuZCA9IExvbmcuZnJvbVZhbHVlKHN1YnRyYWhlbmQpO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoc3VidHJhaGVuZC5uZWcoKSk7XG4gICAgfVxuICAgIHN1YihzdWJ0cmFoZW5kKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnRyYWN0KHN1YnRyYWhlbmQpO1xuICAgIH1cbiAgICB0b0ludCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5zaWduZWQgPyB0aGlzLmxvdyA+Pj4gMCA6IHRoaXMubG93O1xuICAgIH1cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgaWYgKHRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaGlnaCA+Pj4gMCkgKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmhpZ2ggKiBUV09fUFdSXzMyX0RCTCArICh0aGlzLmxvdyA+Pj4gMCk7XG4gICAgfVxuICAgIHRvQmlnSW50KCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KHRoaXMudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHRvQnl0ZXMobGUpIHtcbiAgICAgICAgcmV0dXJuIGxlID8gdGhpcy50b0J5dGVzTEUoKSA6IHRoaXMudG9CeXRlc0JFKCk7XG4gICAgfVxuICAgIHRvQnl0ZXNMRSgpIHtcbiAgICAgICAgY29uc3QgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBsbyAmIDB4ZmYsXG4gICAgICAgICAgICAobG8gPj4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIGxvID4+PiAyNCxcbiAgICAgICAgICAgIGhpICYgMHhmZixcbiAgICAgICAgICAgIChoaSA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgKGhpID4+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgaGkgPj4+IDI0XG4gICAgICAgIF07XG4gICAgfVxuICAgIHRvQnl0ZXNCRSgpIHtcbiAgICAgICAgY29uc3QgaGkgPSB0aGlzLmhpZ2gsIGxvID0gdGhpcy5sb3c7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBoaSA+Pj4gMjQsXG4gICAgICAgICAgICAoaGkgPj4+IDE2KSAmIDB4ZmYsXG4gICAgICAgICAgICAoaGkgPj4+IDgpICYgMHhmZixcbiAgICAgICAgICAgIGhpICYgMHhmZixcbiAgICAgICAgICAgIGxvID4+PiAyNCxcbiAgICAgICAgICAgIChsbyA+Pj4gMTYpICYgMHhmZixcbiAgICAgICAgICAgIChsbyA+Pj4gOCkgJiAweGZmLFxuICAgICAgICAgICAgbG8gJiAweGZmXG4gICAgICAgIF07XG4gICAgfVxuICAgIHRvU2lnbmVkKCkge1xuICAgICAgICBpZiAoIXRoaXMudW5zaWduZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3csIHRoaXMuaGlnaCwgZmFsc2UpO1xuICAgIH1cbiAgICB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgICByYWRpeCA9IHJhZGl4IHx8IDEwO1xuICAgICAgICBpZiAocmFkaXggPCAyIHx8IDM2IDwgcmFkaXgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdyYWRpeCcpO1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSlcbiAgICAgICAgICAgIHJldHVybiAnMCc7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXEoTG9uZy5NSU5fVkFMVUUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmFkaXhMb25nID0gTG9uZy5mcm9tTnVtYmVyKHJhZGl4KSwgZGl2ID0gdGhpcy5kaXYocmFkaXhMb25nKSwgcmVtMSA9IGRpdi5tdWwocmFkaXhMb25nKS5zdWIodGhpcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpdi50b1N0cmluZyhyYWRpeCkgKyByZW0xLnRvSW50KCkudG9TdHJpbmcocmFkaXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiAnLScgKyB0aGlzLm5lZygpLnRvU3RyaW5nKHJhZGl4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYWRpeFRvUG93ZXIgPSBMb25nLmZyb21OdW1iZXIoTWF0aC5wb3cocmFkaXgsIDYpLCB0aGlzLnVuc2lnbmVkKTtcbiAgICAgICAgbGV0IHJlbSA9IHRoaXM7XG4gICAgICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlbURpdiA9IHJlbS5kaXYocmFkaXhUb1Bvd2VyKTtcbiAgICAgICAgICAgIGNvbnN0IGludHZhbCA9IHJlbS5zdWIocmVtRGl2Lm11bChyYWRpeFRvUG93ZXIpKS50b0ludCgpID4+PiAwO1xuICAgICAgICAgICAgbGV0IGRpZ2l0cyA9IGludHZhbC50b1N0cmluZyhyYWRpeCk7XG4gICAgICAgICAgICByZW0gPSByZW1EaXY7XG4gICAgICAgICAgICBpZiAocmVtLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZ2l0cyArIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdoaWxlIChkaWdpdHMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzID0gJzAnICsgZGlnaXRzO1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9ICcnICsgZGlnaXRzICsgcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRvVW5zaWduZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLnVuc2lnbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBMb25nLmZyb21CaXRzKHRoaXMubG93LCB0aGlzLmhpZ2gsIHRydWUpO1xuICAgIH1cbiAgICB4b3Iob3RoZXIpIHtcbiAgICAgICAgaWYgKCFMb25nLmlzTG9uZyhvdGhlcikpXG4gICAgICAgICAgICBvdGhlciA9IExvbmcuZnJvbVZhbHVlKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIExvbmcuZnJvbUJpdHModGhpcy5sb3cgXiBvdGhlci5sb3csIHRoaXMuaGlnaCBeIG90aGVyLmhpZ2gsIHRoaXMudW5zaWduZWQpO1xuICAgIH1cbiAgICBlcXooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzWmVybygpO1xuICAgIH1cbiAgICBsZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXNzVGhhbk9yRXF1YWwob3RoZXIpO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVsYXhlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvTnVtYmVyKCk7XG4gICAgICAgIHJldHVybiB7ICRudW1iZXJMb25nOiB0aGlzLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlQmlnSW50NjQgPSBmYWxzZSwgcmVsYXhlZCA9IHRydWUgfSA9IHsgLi4ub3B0aW9ucyB9O1xuICAgICAgICBpZiAoZG9jLiRudW1iZXJMb25nLmxlbmd0aCA+IE1BWF9JTlQ2NF9TVFJJTkdfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCckbnVtYmVyTG9uZyBzdHJpbmcgaXMgdG9vIGxvbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIURFQ0lNQUxfUkVHX0VYLnRlc3QoZG9jLiRudW1iZXJMb25nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgJG51bWJlckxvbmcgc3RyaW5nIFwiJHtkb2MuJG51bWJlckxvbmd9XCIgaXMgaW4gYW4gaW52YWxpZCBmb3JtYXRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXNlQmlnSW50NjQpIHtcbiAgICAgICAgICAgIGNvbnN0IGJpZ0ludFJlc3VsdCA9IEJpZ0ludChkb2MuJG51bWJlckxvbmcpO1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludC5hc0ludE4oNjQsIGJpZ0ludFJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9uZ1Jlc3VsdCA9IExvbmcuZnJvbVN0cmluZyhkb2MuJG51bWJlckxvbmcpO1xuICAgICAgICBpZiAocmVsYXhlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvbmdSZXN1bHQudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9uZ1Jlc3VsdDtcbiAgICB9XG4gICAgaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICBpbnNwZWN0ID8/PSBkZWZhdWx0SW5zcGVjdDtcbiAgICAgICAgY29uc3QgbG9uZ1ZhbCA9IGluc3BlY3QodGhpcy50b1N0cmluZygpLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgdW5zaWduZWRWYWwgPSB0aGlzLnVuc2lnbmVkID8gYCwgJHtpbnNwZWN0KHRoaXMudW5zaWduZWQsIG9wdGlvbnMpfWAgOiAnJztcbiAgICAgICAgcmV0dXJuIGBuZXcgTG9uZygke2xvbmdWYWx9JHt1bnNpZ25lZFZhbH0pYDtcbiAgICB9XG59XG5Mb25nLlRXT19QV1JfMjQgPSBMb25nLmZyb21JbnQoVFdPX1BXUl8yNF9EQkwpO1xuTG9uZy5NQVhfVU5TSUdORURfVkFMVUUgPSBMb25nLmZyb21CaXRzKDB4ZmZmZmZmZmYgfCAwLCAweGZmZmZmZmZmIHwgMCwgdHJ1ZSk7XG5Mb25nLlpFUk8gPSBMb25nLmZyb21JbnQoMCk7XG5Mb25nLlVaRVJPID0gTG9uZy5mcm9tSW50KDAsIHRydWUpO1xuTG9uZy5PTkUgPSBMb25nLmZyb21JbnQoMSk7XG5Mb25nLlVPTkUgPSBMb25nLmZyb21JbnQoMSwgdHJ1ZSk7XG5Mb25nLk5FR19PTkUgPSBMb25nLmZyb21JbnQoLTEpO1xuTG9uZy5NQVhfVkFMVUUgPSBMb25nLmZyb21CaXRzKDB4ZmZmZmZmZmYgfCAwLCAweDdmZmZmZmZmIHwgMCwgZmFsc2UpO1xuTG9uZy5NSU5fVkFMVUUgPSBMb25nLmZyb21CaXRzKDAsIDB4ODAwMDAwMDAgfCAwLCBmYWxzZSk7XG5cbmNvbnN0IFBBUlNFX1NUUklOR19SRUdFWFAgPSAvXihcXCt8LSk/KFxcZCt8KFxcZCpcXC5cXGQqKSk/KEV8ZSk/KFstK10pPyhcXGQrKT8kLztcbmNvbnN0IFBBUlNFX0lORl9SRUdFWFAgPSAvXihcXCt8LSk/KEluZmluaXR5fGluZikkL2k7XG5jb25zdCBQQVJTRV9OQU5fUkVHRVhQID0gL14oXFwrfC0pP05hTiQvaTtcbmNvbnN0IEVYUE9ORU5UX01BWCA9IDYxMTE7XG5jb25zdCBFWFBPTkVOVF9NSU4gPSAtNjE3NjtcbmNvbnN0IEVYUE9ORU5UX0JJQVMgPSA2MTc2O1xuY29uc3QgTUFYX0RJR0lUUyA9IDM0O1xuY29uc3QgTkFOX0JVRkZFUiA9IEJ5dGVVdGlscy5mcm9tTnVtYmVyQXJyYXkoW1xuICAgIDB4N2MsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDAsIDB4MDBcbl0ucmV2ZXJzZSgpKTtcbmNvbnN0IElORl9ORUdBVElWRV9CVUZGRVIgPSBCeXRlVXRpbHMuZnJvbU51bWJlckFycmF5KFtcbiAgICAweGY4LCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwLCAweDAwXG5dLnJldmVyc2UoKSk7XG5jb25zdCBJTkZfUE9TSVRJVkVfQlVGRkVSID0gQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShbXG4gICAgMHg3OCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMFxuXS5yZXZlcnNlKCkpO1xuY29uc3QgRVhQT05FTlRfUkVHRVggPSAvXihbLStdKT8oXFxkKyk/JC87XG5jb25zdCBDT01CSU5BVElPTl9NQVNLID0gMHgxZjtcbmNvbnN0IEVYUE9ORU5UX01BU0sgPSAweDNmZmY7XG5jb25zdCBDT01CSU5BVElPTl9JTkZJTklUWSA9IDMwO1xuY29uc3QgQ09NQklOQVRJT05fTkFOID0gMzE7XG5mdW5jdGlvbiBpc0RpZ2l0KHZhbHVlKSB7XG4gICAgcmV0dXJuICFpc05hTihwYXJzZUludCh2YWx1ZSwgMTApKTtcbn1cbmZ1bmN0aW9uIGRpdmlkZXUxMjgodmFsdWUpIHtcbiAgICBjb25zdCBESVZJU09SID0gTG9uZy5mcm9tTnVtYmVyKDEwMDAgKiAxMDAwICogMTAwMCk7XG4gICAgbGV0IF9yZW0gPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgaWYgKCF2YWx1ZS5wYXJ0c1swXSAmJiAhdmFsdWUucGFydHNbMV0gJiYgIXZhbHVlLnBhcnRzWzJdICYmICF2YWx1ZS5wYXJ0c1szXSkge1xuICAgICAgICByZXR1cm4geyBxdW90aWVudDogdmFsdWUsIHJlbTogX3JlbSB9O1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAzOyBpKyspIHtcbiAgICAgICAgX3JlbSA9IF9yZW0uc2hpZnRMZWZ0KDMyKTtcbiAgICAgICAgX3JlbSA9IF9yZW0uYWRkKG5ldyBMb25nKHZhbHVlLnBhcnRzW2ldLCAwKSk7XG4gICAgICAgIHZhbHVlLnBhcnRzW2ldID0gX3JlbS5kaXYoRElWSVNPUikubG93O1xuICAgICAgICBfcmVtID0gX3JlbS5tb2R1bG8oRElWSVNPUik7XG4gICAgfVxuICAgIHJldHVybiB7IHF1b3RpZW50OiB2YWx1ZSwgcmVtOiBfcmVtIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseTY0eDIobGVmdCwgcmlnaHQpIHtcbiAgICBpZiAoIWxlZnQgJiYgIXJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB7IGhpZ2g6IExvbmcuZnJvbU51bWJlcigwKSwgbG93OiBMb25nLmZyb21OdW1iZXIoMCkgfTtcbiAgICB9XG4gICAgY29uc3QgbGVmdEhpZ2ggPSBsZWZ0LnNoaWZ0UmlnaHRVbnNpZ25lZCgzMik7XG4gICAgY29uc3QgbGVmdExvdyA9IG5ldyBMb25nKGxlZnQuZ2V0TG93Qml0cygpLCAwKTtcbiAgICBjb25zdCByaWdodEhpZ2ggPSByaWdodC5zaGlmdFJpZ2h0VW5zaWduZWQoMzIpO1xuICAgIGNvbnN0IHJpZ2h0TG93ID0gbmV3IExvbmcocmlnaHQuZ2V0TG93Qml0cygpLCAwKTtcbiAgICBsZXQgcHJvZHVjdEhpZ2ggPSBsZWZ0SGlnaC5tdWx0aXBseShyaWdodEhpZ2gpO1xuICAgIGxldCBwcm9kdWN0TWlkID0gbGVmdEhpZ2gubXVsdGlwbHkocmlnaHRMb3cpO1xuICAgIGNvbnN0IHByb2R1Y3RNaWQyID0gbGVmdExvdy5tdWx0aXBseShyaWdodEhpZ2gpO1xuICAgIGxldCBwcm9kdWN0TG93ID0gbGVmdExvdy5tdWx0aXBseShyaWdodExvdyk7XG4gICAgcHJvZHVjdEhpZ2ggPSBwcm9kdWN0SGlnaC5hZGQocHJvZHVjdE1pZC5zaGlmdFJpZ2h0VW5zaWduZWQoMzIpKTtcbiAgICBwcm9kdWN0TWlkID0gbmV3IExvbmcocHJvZHVjdE1pZC5nZXRMb3dCaXRzKCksIDApXG4gICAgICAgIC5hZGQocHJvZHVjdE1pZDIpXG4gICAgICAgIC5hZGQocHJvZHVjdExvdy5zaGlmdFJpZ2h0VW5zaWduZWQoMzIpKTtcbiAgICBwcm9kdWN0SGlnaCA9IHByb2R1Y3RIaWdoLmFkZChwcm9kdWN0TWlkLnNoaWZ0UmlnaHRVbnNpZ25lZCgzMikpO1xuICAgIHByb2R1Y3RMb3cgPSBwcm9kdWN0TWlkLnNoaWZ0TGVmdCgzMikuYWRkKG5ldyBMb25nKHByb2R1Y3RMb3cuZ2V0TG93Qml0cygpLCAwKSk7XG4gICAgcmV0dXJuIHsgaGlnaDogcHJvZHVjdEhpZ2gsIGxvdzogcHJvZHVjdExvdyB9O1xufVxuZnVuY3Rpb24gbGVzc1RoYW4obGVmdCwgcmlnaHQpIHtcbiAgICBjb25zdCB1aGxlZnQgPSBsZWZ0LmhpZ2ggPj4+IDA7XG4gICAgY29uc3QgdWhyaWdodCA9IHJpZ2h0LmhpZ2ggPj4+IDA7XG4gICAgaWYgKHVobGVmdCA8IHVocmlnaHQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHVobGVmdCA9PT0gdWhyaWdodCkge1xuICAgICAgICBjb25zdCB1bGxlZnQgPSBsZWZ0LmxvdyA+Pj4gMDtcbiAgICAgICAgY29uc3QgdWxyaWdodCA9IHJpZ2h0LmxvdyA+Pj4gMDtcbiAgICAgICAgaWYgKHVsbGVmdCA8IHVscmlnaHQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaW52YWxpZEVycihzdHJpbmcsIG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBcIiR7c3RyaW5nfVwiIGlzIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nIC0gJHttZXNzYWdlfWApO1xufVxuY2xhc3MgRGVjaW1hbDEyOCBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdEZWNpbWFsMTI4JztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXMgPSBEZWNpbWFsMTI4LmZyb21TdHJpbmcoYnl0ZXMpLmJ5dGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVWludDhBcnJheShieXRlcykpIHtcbiAgICAgICAgICAgIGlmIChieXRlcy5ieXRlTGVuZ3RoICE9PSAxNikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0RlY2ltYWwxMjggbXVzdCB0YWtlIGEgQnVmZmVyIG9mIDE2IGJ5dGVzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmJ5dGVzID0gYnl0ZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdEZWNpbWFsMTI4IG11c3QgdGFrZSBhIEJ1ZmZlciBvciBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gRGVjaW1hbDEyOC5fZnJvbVN0cmluZyhyZXByZXNlbnRhdGlvbiwgeyBhbGxvd1JvdW5kaW5nOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmdXaXRoUm91bmRpbmcocmVwcmVzZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIERlY2ltYWwxMjguX2Zyb21TdHJpbmcocmVwcmVzZW50YXRpb24sIHsgYWxsb3dSb3VuZGluZzogdHJ1ZSB9KTtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tU3RyaW5nKHJlcHJlc2VudGF0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBpc05lZ2F0aXZlID0gZmFsc2U7XG4gICAgICAgIGxldCBzYXdTaWduID0gZmFsc2U7XG4gICAgICAgIGxldCBzYXdSYWRpeCA9IGZhbHNlO1xuICAgICAgICBsZXQgZm91bmROb25aZXJvID0gZmFsc2U7XG4gICAgICAgIGxldCBzaWduaWZpY2FudERpZ2l0cyA9IDA7XG4gICAgICAgIGxldCBuRGlnaXRzUmVhZCA9IDA7XG4gICAgICAgIGxldCBuRGlnaXRzID0gMDtcbiAgICAgICAgbGV0IHJhZGl4UG9zaXRpb24gPSAwO1xuICAgICAgICBsZXQgZmlyc3ROb25aZXJvID0gMDtcbiAgICAgICAgY29uc3QgZGlnaXRzID0gWzBdO1xuICAgICAgICBsZXQgbkRpZ2l0c1N0b3JlZCA9IDA7XG4gICAgICAgIGxldCBkaWdpdHNJbnNlcnQgPSAwO1xuICAgICAgICBsZXQgbGFzdERpZ2l0ID0gMDtcbiAgICAgICAgbGV0IGV4cG9uZW50ID0gMDtcbiAgICAgICAgbGV0IHNpZ25pZmljYW5kSGlnaCA9IG5ldyBMb25nKDAsIDApO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRMb3cgPSBuZXcgTG9uZygwLCAwKTtcbiAgICAgICAgbGV0IGJpYXNlZEV4cG9uZW50ID0gMDtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uLmxlbmd0aCA+PSA3MDAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCcnICsgcmVwcmVzZW50YXRpb24gKyAnIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyaW5nTWF0Y2ggPSByZXByZXNlbnRhdGlvbi5tYXRjaChQQVJTRV9TVFJJTkdfUkVHRVhQKTtcbiAgICAgICAgY29uc3QgaW5mTWF0Y2ggPSByZXByZXNlbnRhdGlvbi5tYXRjaChQQVJTRV9JTkZfUkVHRVhQKTtcbiAgICAgICAgY29uc3QgbmFuTWF0Y2ggPSByZXByZXNlbnRhdGlvbi5tYXRjaChQQVJTRV9OQU5fUkVHRVhQKTtcbiAgICAgICAgaWYgKCghc3RyaW5nTWF0Y2ggJiYgIWluZk1hdGNoICYmICFuYW5NYXRjaCkgfHwgcmVwcmVzZW50YXRpb24ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCcnICsgcmVwcmVzZW50YXRpb24gKyAnIG5vdCBhIHZhbGlkIERlY2ltYWwxMjggc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZ01hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZE51bWJlciA9IHN0cmluZ01hdGNoWzJdO1xuICAgICAgICAgICAgY29uc3QgZSA9IHN0cmluZ01hdGNoWzRdO1xuICAgICAgICAgICAgY29uc3QgZXhwU2lnbiA9IHN0cmluZ01hdGNoWzVdO1xuICAgICAgICAgICAgY29uc3QgZXhwTnVtYmVyID0gc3RyaW5nTWF0Y2hbNl07XG4gICAgICAgICAgICBpZiAoZSAmJiBleHBOdW1iZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnbWlzc2luZyBleHBvbmVudCBwb3dlcicpO1xuICAgICAgICAgICAgaWYgKGUgJiYgdW5zaWduZWROdW1iZXIgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnbWlzc2luZyBleHBvbmVudCBiYXNlJyk7XG4gICAgICAgICAgICBpZiAoZSA9PT0gdW5kZWZpbmVkICYmIChleHBTaWduIHx8IGV4cE51bWJlcikpIHtcbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnbWlzc2luZyBlIGJlZm9yZSBleHBvbmVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICcrJyB8fCByZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICctJykge1xuICAgICAgICAgICAgc2F3U2lnbiA9IHRydWU7XG4gICAgICAgICAgICBpc05lZ2F0aXZlID0gcmVwcmVzZW50YXRpb25baW5kZXgrK10gPT09ICctJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzRGlnaXQocmVwcmVzZW50YXRpb25baW5kZXhdKSAmJiByZXByZXNlbnRhdGlvbltpbmRleF0gIT09ICcuJykge1xuICAgICAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJ2knIHx8IHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJ0knKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KGlzTmVnYXRpdmUgPyBJTkZfTkVHQVRJVkVfQlVGRkVSIDogSU5GX1BPU0lUSVZFX0JVRkZFUik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXByZXNlbnRhdGlvbltpbmRleF0gPT09ICdOJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChOQU5fQlVGRkVSKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaXNEaWdpdChyZXByZXNlbnRhdGlvbltpbmRleF0pIHx8IHJlcHJlc2VudGF0aW9uW2luZGV4XSA9PT0gJy4nKSB7XG4gICAgICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnLicpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2F3UmFkaXgpXG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdjb250YWlucyBtdWx0aXBsZSBwZXJpb2RzJyk7XG4gICAgICAgICAgICAgICAgc2F3UmFkaXggPSB0cnVlO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5EaWdpdHNTdG9yZWQgPCBNQVhfRElHSVRTKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSAhPT0gJzAnIHx8IGZvdW5kTm9uWmVybykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZvdW5kTm9uWmVybykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gbkRpZ2l0c1JlYWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZm91bmROb25aZXJvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGlnaXRzW2RpZ2l0c0luc2VydCsrXSA9IHBhcnNlSW50KHJlcHJlc2VudGF0aW9uW2luZGV4XSwgMTApO1xuICAgICAgICAgICAgICAgICAgICBuRGlnaXRzU3RvcmVkID0gbkRpZ2l0c1N0b3JlZCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvdW5kTm9uWmVybylcbiAgICAgICAgICAgICAgICBuRGlnaXRzID0gbkRpZ2l0cyArIDE7XG4gICAgICAgICAgICBpZiAoc2F3UmFkaXgpXG4gICAgICAgICAgICAgICAgcmFkaXhQb3NpdGlvbiA9IHJhZGl4UG9zaXRpb24gKyAxO1xuICAgICAgICAgICAgbkRpZ2l0c1JlYWQgPSBuRGlnaXRzUmVhZCArIDE7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2F3UmFkaXggJiYgIW5EaWdpdHNSZWFkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignJyArIHJlcHJlc2VudGF0aW9uICsgJyBub3QgYSB2YWxpZCBEZWNpbWFsMTI4IHN0cmluZycpO1xuICAgICAgICBpZiAocmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnZScgfHwgcmVwcmVzZW50YXRpb25baW5kZXhdID09PSAnRScpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gcmVwcmVzZW50YXRpb24uc3Vic3RyKCsraW5kZXgpLm1hdGNoKEVYUE9ORU5UX1JFR0VYKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoWzJdKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChOQU5fQlVGRkVSKTtcbiAgICAgICAgICAgIGV4cG9uZW50ID0gcGFyc2VJbnQobWF0Y2hbMF0sIDEwKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcHJlc2VudGF0aW9uW2luZGV4XSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGVjaW1hbDEyOChOQU5fQlVGRkVSKTtcbiAgICAgICAgaWYgKCFuRGlnaXRzU3RvcmVkKSB7XG4gICAgICAgICAgICBkaWdpdHNbMF0gPSAwO1xuICAgICAgICAgICAgbkRpZ2l0cyA9IDE7XG4gICAgICAgICAgICBuRGlnaXRzU3RvcmVkID0gMTtcbiAgICAgICAgICAgIHNpZ25pZmljYW50RGlnaXRzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxhc3REaWdpdCA9IG5EaWdpdHNTdG9yZWQgLSAxO1xuICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSBuRGlnaXRzO1xuICAgICAgICAgICAgaWYgKHNpZ25pZmljYW50RGlnaXRzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJlcHJlc2VudGF0aW9uW2ZpcnN0Tm9uWmVybyArIHNpZ25pZmljYW50RGlnaXRzIC0gMSArIE51bWJlcihzYXdTaWduKSArIE51bWJlcihzYXdSYWRpeCldID09PSAnMCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbnREaWdpdHMgPSBzaWduaWZpY2FudERpZ2l0cyAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChleHBvbmVudCA8PSByYWRpeFBvc2l0aW9uICYmIHJhZGl4UG9zaXRpb24gPiBleHBvbmVudCArICgxIDw8IDE0KSkge1xuICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NSU47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleHBvbmVudCA9IGV4cG9uZW50IC0gcmFkaXhQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoZXhwb25lbnQgPiBFWFBPTkVOVF9NQVgpIHtcbiAgICAgICAgICAgIGxhc3REaWdpdCA9IGxhc3REaWdpdCArIDE7XG4gICAgICAgICAgICBpZiAobGFzdERpZ2l0ID49IE1BWF9ESUdJVFMpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2lnbmlmaWNhbnREaWdpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBFWFBPTkVOVF9NQVg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmFsbG93Um91bmRpbmcpIHtcbiAgICAgICAgICAgIHdoaWxlIChleHBvbmVudCA8IEVYUE9ORU5UX01JTiB8fCBuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgPT09IDAgJiYgc2lnbmlmaWNhbnREaWdpdHMgPCBuRGlnaXRzU3RvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gRVhQT05FTlRfTUlOO1xuICAgICAgICAgICAgICAgICAgICBzaWduaWZpY2FudERpZ2l0cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobkRpZ2l0c1N0b3JlZCA8IG5EaWdpdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgbkRpZ2l0cyA9IG5EaWdpdHMgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdERpZ2l0ID0gbGFzdERpZ2l0IC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50IDwgRVhQT05FTlRfTUFYKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlnaXRzU3RyaW5nID0gZGlnaXRzLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlnaXRzU3RyaW5nLm1hdGNoKC9eMCskLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9uZW50ID0gRVhQT05FTlRfTUFYO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ292ZXJmbG93Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3REaWdpdCArIDEgPCBzaWduaWZpY2FudERpZ2l0cykge1xuICAgICAgICAgICAgICAgIGxldCBlbmRPZlN0cmluZyA9IG5EaWdpdHNSZWFkO1xuICAgICAgICAgICAgICAgIGlmIChzYXdSYWRpeCkge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vblplcm8gPSBmaXJzdE5vblplcm8gKyAxO1xuICAgICAgICAgICAgICAgICAgICBlbmRPZlN0cmluZyA9IGVuZE9mU3RyaW5nICsgMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNhd1NpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb25aZXJvID0gZmlyc3ROb25aZXJvICsgMTtcbiAgICAgICAgICAgICAgICAgICAgZW5kT2ZTdHJpbmcgPSBlbmRPZlN0cmluZyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdW5kRGlnaXQgPSBwYXJzZUludChyZXByZXNlbnRhdGlvbltmaXJzdE5vblplcm8gKyBsYXN0RGlnaXQgKyAxXSwgMTApO1xuICAgICAgICAgICAgICAgIGxldCByb3VuZEJpdCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHJvdW5kRGlnaXQgPj0gNSkge1xuICAgICAgICAgICAgICAgICAgICByb3VuZEJpdCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3VuZERpZ2l0ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3VuZEJpdCA9IGRpZ2l0c1tsYXN0RGlnaXRdICUgMiA9PT0gMSA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGZpcnN0Tm9uWmVybyArIGxhc3REaWdpdCArIDI7IGkgPCBlbmRPZlN0cmluZzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlSW50KHJlcHJlc2VudGF0aW9uW2ldLCAxMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91bmRCaXQgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdW5kQml0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBkSWR4ID0gbGFzdERpZ2l0O1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZElkeCA+PSAwOyBkSWR4LS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgrK2RpZ2l0c1tkSWR4XSA+IDkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHNbZElkeF0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkSWR4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleHBvbmVudCA8IEVYUE9ORU5UX01BWCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHNbZElkeF0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KGlzTmVnYXRpdmUgPyBJTkZfTkVHQVRJVkVfQlVGRkVSIDogSU5GX1BPU0lUSVZFX0JVRkZFUik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlIChleHBvbmVudCA8IEVYUE9ORU5UX01JTiB8fCBuRGlnaXRzU3RvcmVkIDwgbkRpZ2l0cykge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RGlnaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNpZ25pZmljYW50RGlnaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvbmVudCA9IEVYUE9ORU5UX01JTjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdleHBvbmVudCB1bmRlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5EaWdpdHNTdG9yZWQgPCBuRGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXByZXNlbnRhdGlvbltuRGlnaXRzIC0gMSArIE51bWJlcihzYXdTaWduKSArIE51bWJlcihzYXdSYWRpeCldICE9PSAnMCcgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25pZmljYW50RGlnaXRzICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnaW5leGFjdCByb3VuZGluZycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5EaWdpdHMgPSBuRGlnaXRzIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWdpdHNbbGFzdERpZ2l0XSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52YWxpZEVycihyZXByZXNlbnRhdGlvbiwgJ2luZXhhY3Qgcm91bmRpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0RGlnaXQgPSBsYXN0RGlnaXQgLSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhwb25lbnQgPCBFWFBPTkVOVF9NQVgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwb25lbnQgPSBleHBvbmVudCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkRXJyKHJlcHJlc2VudGF0aW9uLCAnb3ZlcmZsb3cnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdERpZ2l0ICsgMSA8IHNpZ25pZmljYW50RGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNhd1JhZGl4KSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybyA9IGZpcnN0Tm9uWmVybyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzYXdTaWduKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0Tm9uWmVybyA9IGZpcnN0Tm9uWmVybyArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJvdW5kRGlnaXQgPSBwYXJzZUludChyZXByZXNlbnRhdGlvbltmaXJzdE5vblplcm8gKyBsYXN0RGlnaXQgKyAxXSwgMTApO1xuICAgICAgICAgICAgICAgIGlmIChyb3VuZERpZ2l0ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmFsaWRFcnIocmVwcmVzZW50YXRpb24sICdpbmV4YWN0IHJvdW5kaW5nJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IExvbmcuZnJvbU51bWJlcigwKTtcbiAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgICAgIGlmIChzaWduaWZpY2FudERpZ2l0cyA9PT0gMCkge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gTG9uZy5mcm9tTnVtYmVyKDApO1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGFzdERpZ2l0IDwgMTcpIHtcbiAgICAgICAgICAgIGxldCBkSWR4ID0gMDtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4KytdKTtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IG5ldyBMb25nKDAsIDApO1xuICAgICAgICAgICAgZm9yICg7IGRJZHggPD0gbGFzdERpZ2l0OyBkSWR4KyspIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IHNpZ25pZmljYW5kTG93Lm11bHRpcGx5KExvbmcuZnJvbU51bWJlcigxMCkpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cuYWRkKExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkSWR4ID0gMDtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeCsrXSk7XG4gICAgICAgICAgICBmb3IgKDsgZElkeCA8PSBsYXN0RGlnaXQgLSAxNzsgZElkeCsrKSB7XG4gICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRIaWdoID0gc2lnbmlmaWNhbmRIaWdoLm11bHRpcGx5KExvbmcuZnJvbU51bWJlcigxMCkpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kSGlnaCA9IHNpZ25pZmljYW5kSGlnaC5hZGQoTG9uZy5mcm9tTnVtYmVyKGRpZ2l0c1tkSWR4XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2lnbmlmaWNhbmRMb3cgPSBMb25nLmZyb21OdW1iZXIoZGlnaXRzW2RJZHgrK10pO1xuICAgICAgICAgICAgZm9yICg7IGRJZHggPD0gbGFzdERpZ2l0OyBkSWR4KyspIHtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZExvdyA9IHNpZ25pZmljYW5kTG93Lm11bHRpcGx5KExvbmcuZnJvbU51bWJlcigxMCkpO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kTG93ID0gc2lnbmlmaWNhbmRMb3cuYWRkKExvbmcuZnJvbU51bWJlcihkaWdpdHNbZElkeF0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduaWZpY2FuZCA9IG11bHRpcGx5NjR4MihzaWduaWZpY2FuZEhpZ2gsIExvbmcuZnJvbVN0cmluZygnMTAwMDAwMDAwMDAwMDAwMDAwJykpO1xuICAgICAgICBzaWduaWZpY2FuZC5sb3cgPSBzaWduaWZpY2FuZC5sb3cuYWRkKHNpZ25pZmljYW5kTG93KTtcbiAgICAgICAgaWYgKGxlc3NUaGFuKHNpZ25pZmljYW5kLmxvdywgc2lnbmlmaWNhbmRMb3cpKSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZC5oaWdoID0gc2lnbmlmaWNhbmQuaGlnaC5hZGQoTG9uZy5mcm9tTnVtYmVyKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBiaWFzZWRFeHBvbmVudCA9IGV4cG9uZW50ICsgRVhQT05FTlRfQklBUztcbiAgICAgICAgY29uc3QgZGVjID0geyBsb3c6IExvbmcuZnJvbU51bWJlcigwKSwgaGlnaDogTG9uZy5mcm9tTnVtYmVyKDApIH07XG4gICAgICAgIGlmIChzaWduaWZpY2FuZC5oaWdoLnNoaWZ0UmlnaHRVbnNpZ25lZCg0OSkuYW5kKExvbmcuZnJvbU51bWJlcigxKSkuZXF1YWxzKExvbmcuZnJvbU51bWJlcigxKSkpIHtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3IoTG9uZy5mcm9tTnVtYmVyKDB4Mykuc2hpZnRMZWZ0KDYxKSk7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKExvbmcuZnJvbU51bWJlcihiaWFzZWRFeHBvbmVudCkuYW5kKExvbmcuZnJvbU51bWJlcigweDNmZmYpLnNoaWZ0TGVmdCg0NykpKTtcbiAgICAgICAgICAgIGRlYy5oaWdoID0gZGVjLmhpZ2gub3Ioc2lnbmlmaWNhbmQuaGlnaC5hbmQoTG9uZy5mcm9tTnVtYmVyKDB4N2ZmZmZmZmZmZmZmKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihMb25nLmZyb21OdW1iZXIoYmlhc2VkRXhwb25lbnQgJiAweDNmZmYpLnNoaWZ0TGVmdCg0OSkpO1xuICAgICAgICAgICAgZGVjLmhpZ2ggPSBkZWMuaGlnaC5vcihzaWduaWZpY2FuZC5oaWdoLmFuZChMb25nLmZyb21OdW1iZXIoMHgxZmZmZmZmZmZmZmZmKSkpO1xuICAgICAgICB9XG4gICAgICAgIGRlYy5sb3cgPSBzaWduaWZpY2FuZC5sb3c7XG4gICAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgICAgICBkZWMuaGlnaCA9IGRlYy5oaWdoLm9yKExvbmcuZnJvbVN0cmluZygnOTIyMzM3MjAzNjg1NDc3NTgwOCcpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSBCeXRlVXRpbHMuYWxsb2NhdGUoMTYpO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IGRlYy5sb3cubG93ICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cubG93ID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cubG93ID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMubG93LmxvdyA+PiAyNCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBkZWMubG93LmhpZ2ggJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5oaWdoID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5sb3cuaGlnaCA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmxvdy5oaWdoID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IGRlYy5oaWdoLmxvdyAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5sb3cgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAoZGVjLmhpZ2gubG93ID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5sb3cgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gZGVjLmhpZ2guaGlnaCAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChkZWMuaGlnaC5oaWdoID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmhpZ2ggPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKGRlYy5oaWdoLmhpZ2ggPj4gMjQpICYgMHhmZjtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNpbWFsMTI4KGJ1ZmZlcik7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgYmlhc2VkX2V4cG9uZW50O1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRfZGlnaXRzID0gMDtcbiAgICAgICAgY29uc3Qgc2lnbmlmaWNhbmQgPSBuZXcgQXJyYXkoMzYpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc2lnbmlmaWNhbmRbaV0gPSAwO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBsZXQgaXNfemVybyA9IGZhbHNlO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmRfbXNiO1xuICAgICAgICBsZXQgc2lnbmlmaWNhbmQxMjggPSB7IHBhcnRzOiBbMCwgMCwgMCwgMF0gfTtcbiAgICAgICAgbGV0IGosIGs7XG4gICAgICAgIGNvbnN0IHN0cmluZyA9IFtdO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHRoaXMuYnl0ZXM7XG4gICAgICAgIGNvbnN0IGxvdyA9IGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICBjb25zdCBtaWRsID0gYnVmZmVyW2luZGV4KytdIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgIGNvbnN0IG1pZGggPSBidWZmZXJbaW5kZXgrK10gfCAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfCAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgY29uc3QgaGlnaCA9IGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IGRlYyA9IHtcbiAgICAgICAgICAgIGxvdzogbmV3IExvbmcobG93LCBtaWRsKSxcbiAgICAgICAgICAgIGhpZ2g6IG5ldyBMb25nKG1pZGgsIGhpZ2gpXG4gICAgICAgIH07XG4gICAgICAgIGlmIChkZWMuaGlnaC5sZXNzVGhhbihMb25nLlpFUk8pKSB7XG4gICAgICAgICAgICBzdHJpbmcucHVzaCgnLScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbWJpbmF0aW9uID0gKGhpZ2ggPj4gMjYpICYgQ09NQklOQVRJT05fTUFTSztcbiAgICAgICAgaWYgKGNvbWJpbmF0aW9uID4+IDMgPT09IDMpIHtcbiAgICAgICAgICAgIGlmIChjb21iaW5hdGlvbiA9PT0gQ09NQklOQVRJT05fSU5GSU5JVFkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oJycpICsgJ0luZmluaXR5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbWJpbmF0aW9uID09PSBDT01CSU5BVElPTl9OQU4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ05hTic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBiaWFzZWRfZXhwb25lbnQgPSAoaGlnaCA+PiAxNSkgJiBFWFBPTkVOVF9NQVNLO1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kX21zYiA9IDB4MDggKyAoKGhpZ2ggPj4gMTQpICYgMHgwMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzaWduaWZpY2FuZF9tc2IgPSAoaGlnaCA+PiAxNCkgJiAweDA3O1xuICAgICAgICAgICAgYmlhc2VkX2V4cG9uZW50ID0gKGhpZ2ggPj4gMTcpICYgRVhQT05FTlRfTUFTSztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHBvbmVudCA9IGJpYXNlZF9leHBvbmVudCAtIEVYUE9ORU5UX0JJQVM7XG4gICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzBdID0gKGhpZ2ggJiAweDNmZmYpICsgKChzaWduaWZpY2FuZF9tc2IgJiAweGYpIDw8IDE0KTtcbiAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbMV0gPSBtaWRoO1xuICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1syXSA9IG1pZGw7XG4gICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzNdID0gbG93O1xuICAgICAgICBpZiAoc2lnbmlmaWNhbmQxMjgucGFydHNbMF0gPT09IDAgJiZcbiAgICAgICAgICAgIHNpZ25pZmljYW5kMTI4LnBhcnRzWzFdID09PSAwICYmXG4gICAgICAgICAgICBzaWduaWZpY2FuZDEyOC5wYXJ0c1syXSA9PT0gMCAmJlxuICAgICAgICAgICAgc2lnbmlmaWNhbmQxMjgucGFydHNbM10gPT09IDApIHtcbiAgICAgICAgICAgIGlzX3plcm8gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChrID0gMzsgayA+PSAwOyBrLS0pIHtcbiAgICAgICAgICAgICAgICBsZXQgbGVhc3RfZGlnaXRzID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkaXZpZGV1MTI4KHNpZ25pZmljYW5kMTI4KTtcbiAgICAgICAgICAgICAgICBzaWduaWZpY2FuZDEyOCA9IHJlc3VsdC5xdW90aWVudDtcbiAgICAgICAgICAgICAgICBsZWFzdF9kaWdpdHMgPSByZXN1bHQucmVtLmxvdztcbiAgICAgICAgICAgICAgICBpZiAoIWxlYXN0X2RpZ2l0cylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gODsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgc2lnbmlmaWNhbmRbayAqIDkgKyBqXSA9IGxlYXN0X2RpZ2l0cyAlIDEwO1xuICAgICAgICAgICAgICAgICAgICBsZWFzdF9kaWdpdHMgPSBNYXRoLmZsb29yKGxlYXN0X2RpZ2l0cyAvIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzX3plcm8pIHtcbiAgICAgICAgICAgIHNpZ25pZmljYW5kX2RpZ2l0cyA9IDE7XG4gICAgICAgICAgICBzaWduaWZpY2FuZFtpbmRleF0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2lnbmlmaWNhbmRfZGlnaXRzID0gMzY7XG4gICAgICAgICAgICB3aGlsZSAoIXNpZ25pZmljYW5kW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIHNpZ25pZmljYW5kX2RpZ2l0cyA9IHNpZ25pZmljYW5kX2RpZ2l0cyAtIDE7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NpZW50aWZpY19leHBvbmVudCA9IHNpZ25pZmljYW5kX2RpZ2l0cyAtIDEgKyBleHBvbmVudDtcbiAgICAgICAgaWYgKHNjaWVudGlmaWNfZXhwb25lbnQgPj0gMzQgfHwgc2NpZW50aWZpY19leHBvbmVudCA8PSAtNyB8fCBleHBvbmVudCA+IDApIHtcbiAgICAgICAgICAgIGlmIChzaWduaWZpY2FuZF9kaWdpdHMgPiAzNCkge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAkezB9YCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cG9uZW50ID4gMClcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYEUrJHtleHBvbmVudH1gKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChleHBvbmVudCA8IDApXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGBFJHtleHBvbmVudH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICBzaWduaWZpY2FuZF9kaWdpdHMgPSBzaWduaWZpY2FuZF9kaWdpdHMgLSAxO1xuICAgICAgICAgICAgaWYgKHNpZ25pZmljYW5kX2RpZ2l0cykge1xuICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKCcuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kX2RpZ2l0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJpbmcucHVzaCgnRScpO1xuICAgICAgICAgICAgaWYgKHNjaWVudGlmaWNfZXhwb25lbnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCske3NjaWVudGlmaWNfZXhwb25lbnR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzY2llbnRpZmljX2V4cG9uZW50fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGV4cG9uZW50ID49IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ25pZmljYW5kX2RpZ2l0czsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZy5wdXNoKGAke3NpZ25pZmljYW5kW2luZGV4KytdfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCByYWRpeF9wb3NpdGlvbiA9IHNpZ25pZmljYW5kX2RpZ2l0cyArIGV4cG9uZW50O1xuICAgICAgICAgICAgICAgIGlmIChyYWRpeF9wb3NpdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYWRpeF9wb3NpdGlvbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcucHVzaChgJHtzaWduaWZpY2FuZFtpbmRleCsrXX1gKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJy4nKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAocmFkaXhfcG9zaXRpb24rKyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goJzAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWduaWZpY2FuZF9kaWdpdHMgLSBNYXRoLm1heChyYWRpeF9wb3NpdGlvbiAtIDEsIDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nLnB1c2goYCR7c2lnbmlmaWNhbmRbaW5kZXgrK119YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmcuam9pbignJyk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckRlY2ltYWw6IHRoaXMudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckRlY2ltYWw6IHRoaXMudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgcmV0dXJuIERlY2ltYWwxMjguZnJvbVN0cmluZyhkb2MuJG51bWJlckRlY2ltYWwpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCBkMTI4c3RyaW5nID0gaW5zcGVjdCh0aGlzLnRvU3RyaW5nKCksIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gYG5ldyBEZWNpbWFsMTI4KCR7ZDEyOHN0cmluZ30pYDtcbiAgICB9XG59XG5cbmNsYXNzIERvdWJsZSBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdEb3VibGUnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBOdW1iZXIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSArdmFsdWU7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMubGVnYWN5IHx8IChvcHRpb25zLnJlbGF4ZWQgJiYgaXNGaW5pdGUodGhpcy52YWx1ZSkpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5pcyhNYXRoLnNpZ24odGhpcy52YWx1ZSksIC0wKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgJG51bWJlckRvdWJsZTogJy0wLjAnIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRudW1iZXJEb3VibGU6IE51bWJlci5pc0ludGVnZXIodGhpcy52YWx1ZSkgPyB0aGlzLnZhbHVlLnRvRml4ZWQoMSkgOiB0aGlzLnZhbHVlLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGRvdWJsZVZhbHVlID0gcGFyc2VGbG9hdChkb2MuJG51bWJlckRvdWJsZSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMucmVsYXhlZCA/IGRvdWJsZVZhbHVlIDogbmV3IERvdWJsZShkb3VibGVWYWx1ZSk7XG4gICAgfVxuICAgIGluc3BlY3QoZGVwdGgsIG9wdGlvbnMsIGluc3BlY3QpIHtcbiAgICAgICAgaW5zcGVjdCA/Pz0gZGVmYXVsdEluc3BlY3Q7XG4gICAgICAgIHJldHVybiBgbmV3IERvdWJsZSgke2luc3BlY3QodGhpcy52YWx1ZSwgb3B0aW9ucyl9KWA7XG4gICAgfVxufVxuXG5jbGFzcyBJbnQzMiBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdJbnQzMic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9ICt2YWx1ZSB8IDA7XG4gICAgfVxuICAgIHZhbHVlT2YoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b1N0cmluZyhyYWRpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZS50b1N0cmluZyhyYWRpeCk7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgKG9wdGlvbnMucmVsYXhlZCB8fCBvcHRpb25zLmxlZ2FjeSkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckludDogdGhpcy52YWx1ZS50b1N0cmluZygpIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKGRvYywgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLnJlbGF4ZWQgPyBwYXJzZUludChkb2MuJG51bWJlckludCwgMTApIDogbmV3IEludDMyKGRvYy4kbnVtYmVySW50KTtcbiAgICB9XG4gICAgaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICBpbnNwZWN0ID8/PSBkZWZhdWx0SW5zcGVjdDtcbiAgICAgICAgcmV0dXJuIGBuZXcgSW50MzIoJHtpbnNwZWN0KHRoaXMudmFsdWUsIG9wdGlvbnMpfSlgO1xuICAgIH1cbn1cblxuY2xhc3MgTWF4S2V5IGV4dGVuZHMgQlNPTlZhbHVlIHtcbiAgICBnZXQgX2Jzb250eXBlKCkge1xuICAgICAgICByZXR1cm4gJ01heEtleSc7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkbWF4S2V5OiAxIH07XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1heEtleSgpO1xuICAgIH1cbiAgICBpbnNwZWN0KCkge1xuICAgICAgICByZXR1cm4gJ25ldyBNYXhLZXkoKSc7XG4gICAgfVxufVxuXG5jbGFzcyBNaW5LZXkgZXh0ZW5kcyBCU09OVmFsdWUge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnTWluS2V5JztcbiAgICB9XG4gICAgdG9FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiB7ICRtaW5LZXk6IDEgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oKSB7XG4gICAgICAgIHJldHVybiBuZXcgTWluS2V5KCk7XG4gICAgfVxuICAgIGluc3BlY3QoKSB7XG4gICAgICAgIHJldHVybiAnbmV3IE1pbktleSgpJztcbiAgICB9XG59XG5cbmNvbnN0IGNoZWNrRm9ySGV4UmVnRXhwID0gbmV3IFJlZ0V4cCgnXlswLTlhLWZBLUZdezI0fSQnKTtcbmxldCBQUk9DRVNTX1VOSVFVRSA9IG51bGw7XG5jb25zdCBrSWQgPSBTeW1ib2woJ2lkJyk7XG5jbGFzcyBPYmplY3RJZCBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdPYmplY3RJZCc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0SWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgbGV0IHdvcmtpbmdJZDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dElkID09PSAnb2JqZWN0JyAmJiBpbnB1dElkICYmICdpZCcgaW4gaW5wdXRJZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dElkLmlkICE9PSAnc3RyaW5nJyAmJiAhQXJyYXlCdWZmZXIuaXNWaWV3KGlucHV0SWQuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQXJndW1lbnQgcGFzc2VkIGluIG11c3QgaGF2ZSBhbiBpZCB0aGF0IGlzIG9mIHR5cGUgc3RyaW5nIG9yIEJ1ZmZlcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCd0b0hleFN0cmluZycgaW4gaW5wdXRJZCAmJiB0eXBlb2YgaW5wdXRJZC50b0hleFN0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHdvcmtpbmdJZCA9IEJ5dGVVdGlscy5mcm9tSGV4KGlucHV0SWQudG9IZXhTdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3b3JraW5nSWQgPSBpbnB1dElkLmlkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd29ya2luZ0lkID0gaW5wdXRJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya2luZ0lkID09IG51bGwgfHwgdHlwZW9mIHdvcmtpbmdJZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXNba0lkXSA9IE9iamVjdElkLmdlbmVyYXRlKHR5cGVvZiB3b3JraW5nSWQgPT09ICdudW1iZXInID8gd29ya2luZ0lkIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcod29ya2luZ0lkKSAmJiB3b3JraW5nSWQuYnl0ZUxlbmd0aCA9PT0gMTIpIHtcbiAgICAgICAgICAgIHRoaXNba0lkXSA9IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZSh3b3JraW5nSWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB3b3JraW5nSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAod29ya2luZ0lkLmxlbmd0aCA9PT0gMjQgJiYgY2hlY2tGb3JIZXhSZWdFeHAudGVzdCh3b3JraW5nSWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trSWRdID0gQnl0ZVV0aWxzLmZyb21IZXgod29ya2luZ0lkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2lucHV0IG11c3QgYmUgYSAyNCBjaGFyYWN0ZXIgaGV4IHN0cmluZywgMTIgYnl0ZSBVaW50OEFycmF5LCBvciBhbiBpbnRlZ2VyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdBcmd1bWVudCBwYXNzZWQgaW4gZG9lcyBub3QgbWF0Y2ggdGhlIGFjY2VwdGVkIHR5cGVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9faWQgPSBCeXRlVXRpbHMudG9IZXgodGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGlkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1trSWRdO1xuICAgIH1cbiAgICBzZXQgaWQodmFsdWUpIHtcbiAgICAgICAgdGhpc1trSWRdID0gdmFsdWU7XG4gICAgICAgIGlmIChPYmplY3RJZC5jYWNoZUhleFN0cmluZykge1xuICAgICAgICAgICAgdGhpcy5fX2lkID0gQnl0ZVV0aWxzLnRvSGV4KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0hleFN0cmluZygpIHtcbiAgICAgICAgaWYgKE9iamVjdElkLmNhY2hlSGV4U3RyaW5nICYmIHRoaXMuX19pZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19pZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoZXhTdHJpbmcgPSBCeXRlVXRpbHMudG9IZXgodGhpcy5pZCk7XG4gICAgICAgIGlmIChPYmplY3RJZC5jYWNoZUhleFN0cmluZyAmJiAhdGhpcy5fX2lkKSB7XG4gICAgICAgICAgICB0aGlzLl9faWQgPSBoZXhTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhleFN0cmluZztcbiAgICB9XG4gICAgc3RhdGljIGdldEluYygpIHtcbiAgICAgICAgcmV0dXJuIChPYmplY3RJZC5pbmRleCA9IChPYmplY3RJZC5pbmRleCArIDEpICUgMHhmZmZmZmYpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2VuZXJhdGUodGltZSkge1xuICAgICAgICBpZiAoJ251bWJlcicgIT09IHR5cGVvZiB0aW1lKSB7XG4gICAgICAgICAgICB0aW1lID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC8gMTAwMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5jID0gT2JqZWN0SWQuZ2V0SW5jKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZSgxMik7XG4gICAgICAgIEJTT05EYXRhVmlldy5mcm9tVWludDhBcnJheShidWZmZXIpLnNldFVpbnQzMigwLCB0aW1lLCBmYWxzZSk7XG4gICAgICAgIGlmIChQUk9DRVNTX1VOSVFVRSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUFJPQ0VTU19VTklRVUUgPSBCeXRlVXRpbHMucmFuZG9tQnl0ZXMoNSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyWzRdID0gUFJPQ0VTU19VTklRVUVbMF07XG4gICAgICAgIGJ1ZmZlcls1XSA9IFBST0NFU1NfVU5JUVVFWzFdO1xuICAgICAgICBidWZmZXJbNl0gPSBQUk9DRVNTX1VOSVFVRVsyXTtcbiAgICAgICAgYnVmZmVyWzddID0gUFJPQ0VTU19VTklRVUVbM107XG4gICAgICAgIGJ1ZmZlcls4XSA9IFBST0NFU1NfVU5JUVVFWzRdO1xuICAgICAgICBidWZmZXJbMTFdID0gaW5jICYgMHhmZjtcbiAgICAgICAgYnVmZmVyWzEwXSA9IChpbmMgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbOV0gPSAoaW5jID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIHJldHVybiBidWZmZXI7XG4gICAgfVxuICAgIHRvU3RyaW5nKGVuY29kaW5nKSB7XG4gICAgICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICAgICAgICByZXR1cm4gQnl0ZVV0aWxzLnRvQmFzZTY0KHRoaXMuaWQpO1xuICAgICAgICBpZiAoZW5jb2RpbmcgPT09ICdoZXgnKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICBzdGF0aWMgaXModmFyaWFibGUpIHtcbiAgICAgICAgcmV0dXJuICh2YXJpYWJsZSAhPSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFyaWFibGUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAnX2Jzb250eXBlJyBpbiB2YXJpYWJsZSAmJlxuICAgICAgICAgICAgdmFyaWFibGUuX2Jzb250eXBlID09PSAnT2JqZWN0SWQnKTtcbiAgICB9XG4gICAgZXF1YWxzKG90aGVySWQpIHtcbiAgICAgICAgaWYgKG90aGVySWQgPT09IHVuZGVmaW5lZCB8fCBvdGhlcklkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdElkLmlzKG90aGVySWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpc1trSWRdWzExXSA9PT0gb3RoZXJJZFtrSWRdWzExXSAmJiBCeXRlVXRpbHMuZXF1YWxzKHRoaXNba0lkXSwgb3RoZXJJZFtrSWRdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90aGVySWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gb3RoZXJJZC50b0xvd2VyQ2FzZSgpID09PSB0aGlzLnRvSGV4U3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdGhlcklkID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3RoZXJJZC50b0hleFN0cmluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJJZFN0cmluZyA9IG90aGVySWQudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgIGNvbnN0IHRoaXNJZFN0cmluZyA9IHRoaXMudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygb3RoZXJJZFN0cmluZyA9PT0gJ3N0cmluZycgJiYgb3RoZXJJZFN0cmluZy50b0xvd2VyQ2FzZSgpID09PSB0aGlzSWRTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRUaW1lc3RhbXAoKSB7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGNvbnN0IHRpbWUgPSBCU09ORGF0YVZpZXcuZnJvbVVpbnQ4QXJyYXkodGhpcy5pZCkuZ2V0VWludDMyKDAsIGZhbHNlKTtcbiAgICAgICAgdGltZXN0YW1wLnNldFRpbWUoTWF0aC5mbG9vcih0aW1lKSAqIDEwMDApO1xuICAgICAgICByZXR1cm4gdGltZXN0YW1wO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlUGsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUZyb21UaW1lKHRpbWUpIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gQnl0ZVV0aWxzLmZyb21OdW1iZXJBcnJheShbMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMF0pO1xuICAgICAgICBCU09ORGF0YVZpZXcuZnJvbVVpbnQ4QXJyYXkoYnVmZmVyKS5zZXRVaW50MzIoMCwgdGltZSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gbmV3IE9iamVjdElkKGJ1ZmZlcik7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tSGV4U3RyaW5nKGhleFN0cmluZykge1xuICAgICAgICBpZiAoaGV4U3RyaW5nPy5sZW5ndGggIT09IDI0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdoZXggc3RyaW5nIG11c3QgYmUgMjQgY2hhcmFjdGVycycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoQnl0ZVV0aWxzLmZyb21IZXgoaGV4U3RyaW5nKSk7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVGcm9tQmFzZTY0KGJhc2U2NCkge1xuICAgICAgICBpZiAoYmFzZTY0Py5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYXNlNjQgc3RyaW5nIG11c3QgYmUgMTYgY2hhcmFjdGVycycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoQnl0ZVV0aWxzLmZyb21CYXNlNjQoYmFzZTY0KSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1ZhbGlkKGlkKSB7XG4gICAgICAgIGlmIChpZCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IE9iamVjdElkKGlkKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgaWYgKHRoaXMudG9IZXhTdHJpbmcpXG4gICAgICAgICAgICByZXR1cm4geyAkb2lkOiB0aGlzLnRvSGV4U3RyaW5nKCkgfTtcbiAgICAgICAgcmV0dXJuIHsgJG9pZDogdGhpcy50b1N0cmluZygnaGV4JykgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIHJldHVybiBuZXcgT2JqZWN0SWQoZG9jLiRvaWQpO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICByZXR1cm4gYG5ldyBPYmplY3RJZCgke2luc3BlY3QodGhpcy50b0hleFN0cmluZygpLCBvcHRpb25zKX0pYDtcbiAgICB9XG59XG5PYmplY3RJZC5pbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4ZmZmZmZmKTtcblxuZnVuY3Rpb24gaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKG9iamVjdCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpIHtcbiAgICBsZXQgdG90YWxMZW5ndGggPSA0ICsgMTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjYWxjdWxhdGVFbGVtZW50KGkudG9TdHJpbmcoKSwgb2JqZWN0W2ldLCBzZXJpYWxpemVGdW5jdGlvbnMsIHRydWUsIGlnbm9yZVVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0Py50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9iamVjdCA9IG9iamVjdC50b0JTT04oKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmplY3QpKSB7XG4gICAgICAgICAgICB0b3RhbExlbmd0aCArPSBjYWxjdWxhdGVFbGVtZW50KGtleSwgb2JqZWN0W2tleV0sIHNlcmlhbGl6ZUZ1bmN0aW9ucywgZmFsc2UsIGlnbm9yZVVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvdGFsTGVuZ3RoO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlRWxlbWVudChuYW1lLCB2YWx1ZSwgc2VyaWFsaXplRnVuY3Rpb25zID0gZmFsc2UsIGlzQXJyYXkgPSBmYWxzZSwgaWdub3JlVW5kZWZpbmVkID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlPy50b0JTT04gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0JTT04oKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIHJldHVybiAxICsgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSArIDQgKyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUpICsgMTtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGlmIChNYXRoLmZsb29yKHZhbHVlKSA9PT0gdmFsdWUgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZSA+PSBKU19JTlRfTUlOICYmXG4gICAgICAgICAgICAgICAgdmFsdWUgPD0gSlNfSU5UX01BWCkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBCU09OX0lOVDMyX01JTiAmJiB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg0ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg4ICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoOCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICAgICAgaWYgKGlzQXJyYXkgfHwgIWlnbm9yZVVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArIDE7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICgxICsgMSk7XG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS5fYnNvbnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgdmFsdWVbU3ltYm9sLmZvcignQEBtZGIuYnNvbi52ZXJzaW9uJyldICE9PSBCU09OX01BSk9SX1ZFUlNJT04pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdNaW5LZXknIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01heEtleScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdPYmplY3RJZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICgxMiArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlIHx8IGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgIGlzQW55QXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDEgKyA0ICsgMSkgKyB2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0xvbmcnIHx8XG4gICAgICAgICAgICAgICAgdmFsdWUuX2Jzb250eXBlID09PSAnRG91YmxlJyB8fFxuICAgICAgICAgICAgICAgIHZhbHVlLl9ic29udHlwZSA9PT0gJ1RpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArICg4ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEZWNpbWFsMTI4Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiAobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICsgKDE2ICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdDb2RlJykge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5zY29wZSAhPSBudWxsICYmIE9iamVjdC5rZXlzKHZhbHVlLnNjb3BlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgICAgICBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUuY29kZS50b1N0cmluZygpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludGVybmFsQ2FsY3VsYXRlT2JqZWN0U2l6ZSh2YWx1ZS5zY29wZSwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgICAgIDQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKHZhbHVlLmNvZGUudG9TdHJpbmcoKSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQmluYXJ5Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpbmFyeSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChiaW5hcnkuc3ViX3R5cGUgPT09IEJpbmFyeS5TVUJUWVBFX0JZVEVfQVJSQVkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChiaW5hcnkucG9zaXRpb24gKyAxICsgNCArIDEgKyA0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgKyAoYmluYXJ5LnBvc2l0aW9uICsgMSArIDQgKyAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnU3ltYm9sJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS52YWx1ZSkgK1xuICAgICAgICAgICAgICAgICAgICA0ICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnREJSZWYnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JkZXJlZF92YWx1ZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICAgICAgJHJlZjogdmFsdWUuY29sbGVjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgJGlkOiB2YWx1ZS5vaWRcbiAgICAgICAgICAgICAgICB9LCB2YWx1ZS5maWVsZHMpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5kYiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9yZGVyZWRfdmFsdWVzWyckZGInXSA9IHZhbHVlLmRiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplKG9yZGVyZWRfdmFsdWVzLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5zb3VyY2UpICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5nbG9iYWwgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAodmFsdWUuaWdub3JlQ2FzZSA/IDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICh2YWx1ZS5tdWx0aWxpbmUgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05SZWdFeHAnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgobmFtZSAhPSBudWxsID8gQnl0ZVV0aWxzLnV0ZjhCeXRlTGVuZ3RoKG5hbWUpICsgMSA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgMSArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS5wYXR0ZXJuKSArXG4gICAgICAgICAgICAgICAgICAgIDEgK1xuICAgICAgICAgICAgICAgICAgICBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgodmFsdWUub3B0aW9ucykgK1xuICAgICAgICAgICAgICAgICAgICAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKG5hbWUgIT0gbnVsbCA/IEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aChuYW1lKSArIDEgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsQ2FsY3VsYXRlT2JqZWN0U2l6ZSh2YWx1ZSwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQpICtcbiAgICAgICAgICAgICAgICAgICAgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICAgIGlmIChzZXJpYWxpemVGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKChuYW1lICE9IG51bGwgPyBCeXRlVXRpbHMudXRmOEJ5dGVMZW5ndGgobmFtZSkgKyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAxICtcbiAgICAgICAgICAgICAgICAgICAgNCArXG4gICAgICAgICAgICAgICAgICAgIEJ5dGVVdGlscy51dGY4Qnl0ZUxlbmd0aCh2YWx1ZS50b1N0cmluZygpKSArXG4gICAgICAgICAgICAgICAgICAgIDEpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWxwaGFiZXRpemUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5zcGxpdCgnJykuc29ydCgpLmpvaW4oJycpO1xufVxuY2xhc3MgQlNPTlJlZ0V4cCBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdCU09OUmVnRXhwJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IocGF0dGVybiwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBhbHBoYWJldGl6ZShvcHRpb25zID8/ICcnKTtcbiAgICAgICAgaWYgKHRoaXMucGF0dGVybi5pbmRleE9mKCdcXHgwMCcpICE9PSAtMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQlNPTiBSZWdleCBwYXR0ZXJucyBjYW5ub3QgY29udGFpbiBudWxsIGJ5dGVzLCBmb3VuZDogJHtKU09OLnN0cmluZ2lmeSh0aGlzLnBhdHRlcm4pfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5kZXhPZignXFx4MDAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYEJTT04gUmVnZXggb3B0aW9ucyBjYW5ub3QgY29udGFpbiBudWxsIGJ5dGVzLCBmb3VuZDogJHtKU09OLnN0cmluZ2lmeSh0aGlzLm9wdGlvbnMpfWApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnNbaV0gPT09ICdpJyB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9PT0gJ20nIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAneCcgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbaV0gPT09ICdsJyB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc1tpXSA9PT0gJ3MnIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zW2ldID09PSAndScpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBvcHRpb24gWyR7dGhpcy5vcHRpb25zW2ldfV0gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gb3B0aW9ucyA/IG9wdGlvbnMuc3BsaXQoJycpLnNvcnQoKS5qb2luKCcnKSA6ICcnO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTihvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBpZiAob3B0aW9ucy5sZWdhY3kpIHtcbiAgICAgICAgICAgIHJldHVybiB7ICRyZWdleDogdGhpcy5wYXR0ZXJuLCAkb3B0aW9uczogdGhpcy5vcHRpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJHJlZ3VsYXJFeHByZXNzaW9uOiB7IHBhdHRlcm46IHRoaXMucGF0dGVybiwgb3B0aW9uczogdGhpcy5vcHRpb25zIH0gfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21FeHRlbmRlZEpTT04oZG9jKSB7XG4gICAgICAgIGlmICgnJHJlZ2V4JyBpbiBkb2MpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZG9jLiRyZWdleCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9jLiRyZWdleC5fYnNvbnR5cGUgPT09ICdCU09OUmVnRXhwJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQlNPTlJlZ0V4cChkb2MuJHJlZ2V4LCBCU09OUmVnRXhwLnBhcnNlT3B0aW9ucyhkb2MuJG9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoJyRyZWd1bGFyRXhwcmVzc2lvbicgaW4gZG9jKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJTT05SZWdFeHAoZG9jLiRyZWd1bGFyRXhwcmVzc2lvbi5wYXR0ZXJuLCBCU09OUmVnRXhwLnBhcnNlT3B0aW9ucyhkb2MuJHJlZ3VsYXJFeHByZXNzaW9uLm9wdGlvbnMpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBVbmV4cGVjdGVkIEJTT05SZWdFeHAgRUpTT04gb2JqZWN0IGZvcm06ICR7SlNPTi5zdHJpbmdpZnkoZG9jKX1gKTtcbiAgICB9XG4gICAgaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICBjb25zdCBzdHlsaXplID0gZ2V0U3R5bGl6ZUZ1bmN0aW9uKG9wdGlvbnMpID8/ICh2ID0+IHYpO1xuICAgICAgICBpbnNwZWN0ID8/PSBkZWZhdWx0SW5zcGVjdDtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHN0eWxpemUoaW5zcGVjdCh0aGlzLnBhdHRlcm4pLCAncmVnZXhwJyk7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gc3R5bGl6ZShpbnNwZWN0KHRoaXMub3B0aW9ucyksICdyZWdleHAnKTtcbiAgICAgICAgcmV0dXJuIGBuZXcgQlNPTlJlZ0V4cCgke3BhdHRlcm59LCAke2ZsYWdzfSlgO1xuICAgIH1cbn1cblxuY2xhc3MgQlNPTlN5bWJvbCBleHRlbmRzIEJTT05WYWx1ZSB7XG4gICAgZ2V0IF9ic29udHlwZSgpIHtcbiAgICAgICAgcmV0dXJuICdCU09OU3ltYm9sJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICB0b0V4dGVuZGVkSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgJHN5bWJvbDogdGhpcy52YWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCU09OU3ltYm9sKGRvYy4kc3ltYm9sKTtcbiAgICB9XG4gICAgaW5zcGVjdChkZXB0aCwgb3B0aW9ucywgaW5zcGVjdCkge1xuICAgICAgICBpbnNwZWN0ID8/PSBkZWZhdWx0SW5zcGVjdDtcbiAgICAgICAgcmV0dXJuIGBuZXcgQlNPTlN5bWJvbCgke2luc3BlY3QodGhpcy52YWx1ZSwgb3B0aW9ucyl9KWA7XG4gICAgfVxufVxuXG5jb25zdCBMb25nV2l0aG91dE92ZXJyaWRlc0NsYXNzID0gTG9uZztcbmNsYXNzIFRpbWVzdGFtcCBleHRlbmRzIExvbmdXaXRob3V0T3ZlcnJpZGVzQ2xhc3Mge1xuICAgIGdldCBfYnNvbnR5cGUoKSB7XG4gICAgICAgIHJldHVybiAnVGltZXN0YW1wJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IobG93KSB7XG4gICAgICAgIGlmIChsb3cgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3VwZXIoMCwgMCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxvdyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIHN1cGVyKGxvdywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoTG9uZy5pc0xvbmcobG93KSkge1xuICAgICAgICAgICAgc3VwZXIobG93LmxvdywgbG93LmhpZ2gsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsb3cgPT09ICdvYmplY3QnICYmICd0JyBpbiBsb3cgJiYgJ2knIGluIGxvdykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsb3cudCAhPT0gJ251bWJlcicgJiYgKHR5cGVvZiBsb3cudCAhPT0gJ29iamVjdCcgfHwgbG93LnQuX2Jzb250eXBlICE9PSAnSW50MzInKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSB0IGFzIGEgbnVtYmVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxvdy5pICE9PSAnbnVtYmVyJyAmJiAodHlwZW9mIGxvdy5pICE9PSAnb2JqZWN0JyB8fCBsb3cuaS5fYnNvbnR5cGUgIT09ICdJbnQzMicpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIGkgYXMgYSBudW1iZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHQgPSBOdW1iZXIobG93LnQpO1xuICAgICAgICAgICAgY29uc3QgaSA9IE51bWJlcihsb3cuaSk7XG4gICAgICAgICAgICBpZiAodCA8IDAgfHwgTnVtYmVyLmlzTmFOKHQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVGltZXN0YW1wIGNvbnN0cnVjdGVkIGZyb20geyB0LCBpIH0gbXVzdCBwcm92aWRlIGEgcG9zaXRpdmUgdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPCAwIHx8IE51bWJlci5pc05hTihpKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSBhIHBvc2l0aXZlIGknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ID4gNDI5NDk2NzI5NSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ1RpbWVzdGFtcCBjb25zdHJ1Y3RlZCBmcm9tIHsgdCwgaSB9IG11c3QgcHJvdmlkZSB0IGVxdWFsIG9yIGxlc3MgdGhhbiB1aW50MzIgbWF4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA+IDQyOTQ5NjcyOTUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdUaW1lc3RhbXAgY29uc3RydWN0ZWQgZnJvbSB7IHQsIGkgfSBtdXN0IHByb3ZpZGUgaSBlcXVhbCBvciBsZXNzIHRoYW4gdWludDMyIG1heCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VwZXIoaSwgdCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdBIFRpbWVzdGFtcCBjYW4gb25seSBiZSBjb25zdHJ1Y3RlZCB3aXRoOiBiaWdpbnQsIExvbmcsIG9yIHsgdDogbnVtYmVyOyBpOiBudW1iZXIgfScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICR0aW1lc3RhbXA6IHRoaXMudG9TdHJpbmcoKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcChMb25nLmZyb21JbnQodmFsdWUsIHRydWUpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21OdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoTG9uZy5mcm9tTnVtYmVyKHZhbHVlLCB0cnVlKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQml0cyhsb3dCaXRzLCBoaWdoQml0cykge1xuICAgICAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCh7IGk6IGxvd0JpdHMsIHQ6IGhpZ2hCaXRzIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyhzdHIsIG9wdFJhZGl4KSB7XG4gICAgICAgIHJldHVybiBuZXcgVGltZXN0YW1wKExvbmcuZnJvbVN0cmluZyhzdHIsIHRydWUsIG9wdFJhZGl4KSk7XG4gICAgfVxuICAgIHRvRXh0ZW5kZWRKU09OKCkge1xuICAgICAgICByZXR1cm4geyAkdGltZXN0YW1wOiB7IHQ6IHRoaXMuaGlnaCA+Pj4gMCwgaTogdGhpcy5sb3cgPj4+IDAgfSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkSlNPTihkb2MpIHtcbiAgICAgICAgY29uc3QgaSA9IExvbmcuaXNMb25nKGRvYy4kdGltZXN0YW1wLmkpXG4gICAgICAgICAgICA/IGRvYy4kdGltZXN0YW1wLmkuZ2V0TG93Qml0c1Vuc2lnbmVkKClcbiAgICAgICAgICAgIDogZG9jLiR0aW1lc3RhbXAuaTtcbiAgICAgICAgY29uc3QgdCA9IExvbmcuaXNMb25nKGRvYy4kdGltZXN0YW1wLnQpXG4gICAgICAgICAgICA/IGRvYy4kdGltZXN0YW1wLnQuZ2V0TG93Qml0c1Vuc2lnbmVkKClcbiAgICAgICAgICAgIDogZG9jLiR0aW1lc3RhbXAudDtcbiAgICAgICAgcmV0dXJuIG5ldyBUaW1lc3RhbXAoeyB0LCBpIH0pO1xuICAgIH1cbiAgICBpbnNwZWN0KGRlcHRoLCBvcHRpb25zLCBpbnNwZWN0KSB7XG4gICAgICAgIGluc3BlY3QgPz89IGRlZmF1bHRJbnNwZWN0O1xuICAgICAgICBjb25zdCB0ID0gaW5zcGVjdCh0aGlzLmhpZ2ggPj4+IDAsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBpID0gaW5zcGVjdCh0aGlzLmxvdyA+Pj4gMCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBgbmV3IFRpbWVzdGFtcCh7IHQ6ICR7dH0sIGk6ICR7aX0gfSlgO1xuICAgIH1cbn1cblRpbWVzdGFtcC5NQVhfVkFMVUUgPSBMb25nLk1BWF9VTlNJR05FRF9WQUxVRTtcblxuY29uc3QgSlNfSU5UX01BWF9MT05HID0gTG9uZy5mcm9tTnVtYmVyKEpTX0lOVF9NQVgpO1xuY29uc3QgSlNfSU5UX01JTl9MT05HID0gTG9uZy5mcm9tTnVtYmVyKEpTX0lOVF9NSU4pO1xuZnVuY3Rpb24gaW50ZXJuYWxEZXNlcmlhbGl6ZShidWZmZXIsIG9wdGlvbnMsIGlzQXJyYXkpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyA9PSBudWxsID8ge30gOiBvcHRpb25zO1xuICAgIGNvbnN0IGluZGV4ID0gb3B0aW9ucyAmJiBvcHRpb25zLmluZGV4ID8gb3B0aW9ucy5pbmRleCA6IDA7XG4gICAgY29uc3Qgc2l6ZSA9IGJ1ZmZlcltpbmRleF0gfFxuICAgICAgICAoYnVmZmVyW2luZGV4ICsgMV0gPDwgOCkgfFxuICAgICAgICAoYnVmZmVyW2luZGV4ICsgMl0gPDwgMTYpIHxcbiAgICAgICAgKGJ1ZmZlcltpbmRleCArIDNdIDw8IDI0KTtcbiAgICBpZiAoc2l6ZSA8IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgYnNvbiBzaXplIG11c3QgYmUgPj0gNSwgaXMgJHtzaXplfWApO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZSAmJiBidWZmZXIubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBidWZmZXIgbGVuZ3RoICR7YnVmZmVyLmxlbmd0aH0gbXVzdCBiZSA+PSBic29uIHNpemUgJHtzaXplfWApO1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMuYWxsb3dPYmplY3RTbWFsbGVyVGhhbkJ1ZmZlclNpemUgJiYgYnVmZmVyLmxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKGBidWZmZXIgbGVuZ3RoICR7YnVmZmVyLmxlbmd0aH0gbXVzdCA9PT0gYnNvbiBzaXplICR7c2l6ZX1gKTtcbiAgICB9XG4gICAgaWYgKHNpemUgKyBpbmRleCA+IGJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYChic29uIHNpemUgJHtzaXplfSArIG9wdGlvbnMuaW5kZXggJHtpbmRleH0gbXVzdCBiZSA8PSBidWZmZXIgbGVuZ3RoICR7YnVmZmVyLmJ5dGVMZW5ndGh9KWApO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyW2luZGV4ICsgc2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoXCJPbmUgb2JqZWN0LCBzaXplZCBjb3JyZWN0bHksIHdpdGggYSBzcG90IGZvciBhbiBFT08sIGJ1dCB0aGUgRU9PIGlzbid0IDB4MDBcIik7XG4gICAgfVxuICAgIHJldHVybiBkZXNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGluZGV4LCBvcHRpb25zLCBpc0FycmF5KTtcbn1cbmNvbnN0IGFsbG93ZWREQlJlZktleXMgPSAvXlxcJHJlZiR8XlxcJGlkJHxeXFwkZGIkLztcbmZ1bmN0aW9uIGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgaW5kZXgsIG9wdGlvbnMsIGlzQXJyYXkgPSBmYWxzZSkge1xuICAgIGNvbnN0IGZpZWxkc0FzUmF3ID0gb3B0aW9uc1snZmllbGRzQXNSYXcnXSA9PSBudWxsID8gbnVsbCA6IG9wdGlvbnNbJ2ZpZWxkc0FzUmF3J107XG4gICAgY29uc3QgcmF3ID0gb3B0aW9uc1sncmF3J10gPT0gbnVsbCA/IGZhbHNlIDogb3B0aW9uc1sncmF3J107XG4gICAgY29uc3QgYnNvblJlZ0V4cCA9IHR5cGVvZiBvcHRpb25zWydic29uUmVnRXhwJ10gPT09ICdib29sZWFuJyA/IG9wdGlvbnNbJ2Jzb25SZWdFeHAnXSA6IGZhbHNlO1xuICAgIGNvbnN0IHByb21vdGVCdWZmZXJzID0gb3B0aW9ucy5wcm9tb3RlQnVmZmVycyA/PyBmYWxzZTtcbiAgICBjb25zdCBwcm9tb3RlTG9uZ3MgPSBvcHRpb25zLnByb21vdGVMb25ncyA/PyB0cnVlO1xuICAgIGNvbnN0IHByb21vdGVWYWx1ZXMgPSBvcHRpb25zLnByb21vdGVWYWx1ZXMgPz8gdHJ1ZTtcbiAgICBjb25zdCB1c2VCaWdJbnQ2NCA9IG9wdGlvbnMudXNlQmlnSW50NjQgPz8gZmFsc2U7XG4gICAgaWYgKHVzZUJpZ0ludDY0ICYmICFwcm9tb3RlVmFsdWVzKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ011c3QgZWl0aGVyIHJlcXVlc3QgYmlnaW50IG9yIExvbmcgZm9yIGludDY0IGRlc2VyaWFsaXphdGlvbicpO1xuICAgIH1cbiAgICBpZiAodXNlQmlnSW50NjQgJiYgIXByb21vdGVMb25ncykge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdNdXN0IGVpdGhlciByZXF1ZXN0IGJpZ2ludCBvciBMb25nIGZvciBpbnQ2NCBkZXNlcmlhbGl6YXRpb24nKTtcbiAgICB9XG4gICAgY29uc3QgdmFsaWRhdGlvbiA9IG9wdGlvbnMudmFsaWRhdGlvbiA9PSBudWxsID8geyB1dGY4OiB0cnVlIH0gOiBvcHRpb25zLnZhbGlkYXRpb247XG4gICAgbGV0IGdsb2JhbFVURlZhbGlkYXRpb24gPSB0cnVlO1xuICAgIGxldCB2YWxpZGF0aW9uU2V0dGluZztcbiAgICBjb25zdCB1dGY4S2V5c1NldCA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1dGY4VmFsaWRhdGVkS2V5cyA9IHZhbGlkYXRpb24udXRmODtcbiAgICBpZiAodHlwZW9mIHV0ZjhWYWxpZGF0ZWRLZXlzID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdmFsaWRhdGlvblNldHRpbmcgPSB1dGY4VmFsaWRhdGVkS2V5cztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGdsb2JhbFVURlZhbGlkYXRpb24gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdXRmOFZhbGlkYXRpb25WYWx1ZXMgPSBPYmplY3Qua2V5cyh1dGY4VmFsaWRhdGVkS2V5cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiB1dGY4VmFsaWRhdGVkS2V5c1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHV0ZjhWYWxpZGF0aW9uVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignVVRGLTggdmFsaWRhdGlvbiBzZXR0aW5nIGNhbm5vdCBiZSBlbXB0eScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXRmOFZhbGlkYXRpb25WYWx1ZXNbMF0gIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCB2YWxpZGF0aW9uIG9wdGlvbiwgbXVzdCBzcGVjaWZ5IGJvb2xlYW4gdmFsdWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsaWRhdGlvblNldHRpbmcgPSB1dGY4VmFsaWRhdGlvblZhbHVlc1swXTtcbiAgICAgICAgaWYgKCF1dGY4VmFsaWRhdGlvblZhbHVlcy5ldmVyeShpdGVtID0+IGl0ZW0gPT09IHZhbGlkYXRpb25TZXR0aW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignSW52YWxpZCBVVEYtOCB2YWxpZGF0aW9uIG9wdGlvbiAtIGtleXMgbXVzdCBiZSBhbGwgdHJ1ZSBvciBhbGwgZmFsc2UnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWdsb2JhbFVURlZhbGlkYXRpb24pIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModXRmOFZhbGlkYXRlZEtleXMpKSB7XG4gICAgICAgICAgICB1dGY4S2V5c1NldC5hZGQoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCA1KVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb3JydXB0IGJzb24gbWVzc2FnZSA8IDUgYnl0ZXMgbG9uZycpO1xuICAgIGNvbnN0IHNpemUgPSBidWZmZXJbaW5kZXgrK10gfCAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHwgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfCAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICBpZiAoc2l6ZSA8IDUgfHwgc2l6ZSA+IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHQgYnNvbiBtZXNzYWdlJyk7XG4gICAgY29uc3Qgb2JqZWN0ID0gaXNBcnJheSA/IFtdIDoge307XG4gICAgbGV0IGFycmF5SW5kZXggPSAwO1xuICAgIGNvbnN0IGRvbmUgPSBmYWxzZTtcbiAgICBsZXQgaXNQb3NzaWJsZURCUmVmID0gaXNBcnJheSA/IGZhbHNlIDogbnVsbDtcbiAgICBjb25zdCBkYXRhdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIuYnVmZmVyLCBidWZmZXIuYnl0ZU9mZnNldCwgYnVmZmVyLmJ5dGVMZW5ndGgpO1xuICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50VHlwZSA9IGJ1ZmZlcltpbmRleCsrXTtcbiAgICAgICAgaWYgKGVsZW1lbnRUeXBlID09PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGxldCBpID0gaW5kZXg7XG4gICAgICAgIHdoaWxlIChidWZmZXJbaV0gIT09IDB4MDAgJiYgaSA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA+PSBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JhZCBCU09OIERvY3VtZW50OiBpbGxlZ2FsIENTdHJpbmcnKTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGlzQXJyYXkgPyBhcnJheUluZGV4KysgOiBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGksIGZhbHNlKTtcbiAgICAgICAgbGV0IHNob3VsZFZhbGlkYXRlS2V5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKGdsb2JhbFVURlZhbGlkYXRpb24gfHwgdXRmOEtleXNTZXQuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBzaG91bGRWYWxpZGF0ZUtleSA9IHZhbGlkYXRpb25TZXR0aW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2hvdWxkVmFsaWRhdGVLZXkgPSAhdmFsaWRhdGlvblNldHRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUG9zc2libGVEQlJlZiAhPT0gZmFsc2UgJiYgbmFtZVswXSA9PT0gJyQnKSB7XG4gICAgICAgICAgICBpc1Bvc3NpYmxlREJSZWYgPSBhbGxvd2VkREJSZWZLZXlzLnRlc3QobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHZhbHVlO1xuICAgICAgICBpbmRleCA9IGkgKyAxO1xuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9TVFJJTkcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmluZ1NpemUgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGlmIChzdHJpbmdTaXplIDw9IDAgfHxcbiAgICAgICAgICAgICAgICBzdHJpbmdTaXplID4gYnVmZmVyLmxlbmd0aCAtIGluZGV4IHx8XG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4ICsgc3RyaW5nU2l6ZSAtIDFdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIHN0cmluZyBsZW5ndGggaW4gYnNvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEsIHNob3VsZFZhbGlkYXRlS2V5KTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBzdHJpbmdTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfT0lEKSB7XG4gICAgICAgICAgICBjb25zdCBvaWQgPSBCeXRlVXRpbHMuYWxsb2NhdGUoMTIpO1xuICAgICAgICAgICAgb2lkLnNldChidWZmZXIuc3ViYXJyYXkoaW5kZXgsIGluZGV4ICsgMTIpKTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IE9iamVjdElkKG9pZCk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9JTlQgJiYgcHJvbW90ZVZhbHVlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEludDMyKGJ1ZmZlcltpbmRleCsrXSB8IChidWZmZXJbaW5kZXgrK10gPDwgOCkgfCAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8IChidWZmZXJbaW5kZXgrK10gPDwgMjQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0lOVCkge1xuICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTlVNQkVSICYmIHByb21vdGVWYWx1ZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEb3VibGUoZGF0YXZpZXcuZ2V0RmxvYXQ2NChpbmRleCwgdHJ1ZSkpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIDg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9OVU1CRVIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZGF0YXZpZXcuZ2V0RmxvYXQ2NChpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgODtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0RBVEUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvd0JpdHMgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hCaXRzID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKG5ldyBMb25nKGxvd0JpdHMsIGhpZ2hCaXRzKS50b051bWJlcigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0JPT0xFQU4pIHtcbiAgICAgICAgICAgIGlmIChidWZmZXJbaW5kZXhdICE9PSAwICYmIGJ1ZmZlcltpbmRleF0gIT09IDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaWxsZWdhbCBib29sZWFuIHR5cGUgdmFsdWUnKTtcbiAgICAgICAgICAgIHZhbHVlID0gYnVmZmVyW2luZGV4KytdID09PSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfT0JKRUNUKSB7XG4gICAgICAgICAgICBjb25zdCBfaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFNpemUgPSBidWZmZXJbaW5kZXhdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAyXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAzXSA8PCAyNCk7XG4gICAgICAgICAgICBpZiAob2JqZWN0U2l6ZSA8PSAwIHx8IG9iamVjdFNpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignYmFkIGVtYmVkZGVkIGRvY3VtZW50IGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICBpZiAocmF3KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBidWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgb2JqZWN0U2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgb2JqZWN0T3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgICAgICAgICAgaWYgKCFnbG9iYWxVVEZWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iamVjdE9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIHZhbGlkYXRpb246IHsgdXRmODogc2hvdWxkVmFsaWRhdGVLZXkgfSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgX2luZGV4LCBvYmplY3RPcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgb2JqZWN0U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0FSUkFZKSB7XG4gICAgICAgICAgICBjb25zdCBfaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFNpemUgPSBidWZmZXJbaW5kZXhdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAyXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAzXSA8PCAyNCk7XG4gICAgICAgICAgICBsZXQgYXJyYXlPcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHN0b3BJbmRleCA9IGluZGV4ICsgb2JqZWN0U2l6ZTtcbiAgICAgICAgICAgIGlmIChmaWVsZHNBc1JhdyAmJiBmaWVsZHNBc1Jhd1tuYW1lXSkge1xuICAgICAgICAgICAgICAgIGFycmF5T3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgcmF3OiB0cnVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWdsb2JhbFVURlZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICBhcnJheU9wdGlvbnMgPSB7IC4uLmFycmF5T3B0aW9ucywgdmFsaWRhdGlvbjogeyB1dGY4OiBzaG91bGRWYWxpZGF0ZUtleSB9IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgX2luZGV4LCBhcnJheU9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIG9iamVjdFNpemU7XG4gICAgICAgICAgICBpZiAoYnVmZmVyW2luZGV4IC0gMV0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignaW52YWxpZCBhcnJheSB0ZXJtaW5hdG9yIGJ5dGUnKTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gc3RvcEluZGV4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHRlZCBhcnJheSBic29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9VTkRFRklORUQpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTlVMTCkge1xuICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTE9ORykge1xuICAgICAgICAgICAgY29uc3QgZGF0YXZpZXcgPSBCU09ORGF0YVZpZXcuZnJvbVVpbnQ4QXJyYXkoYnVmZmVyLnN1YmFycmF5KGluZGV4LCBpbmRleCArIDgpKTtcbiAgICAgICAgICAgIGNvbnN0IGxvd0JpdHMgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGNvbnN0IGhpZ2hCaXRzID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBjb25zdCBsb25nID0gbmV3IExvbmcobG93Qml0cywgaGlnaEJpdHMpO1xuICAgICAgICAgICAgaWYgKHVzZUJpZ0ludDY0KSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBkYXRhdmlldy5nZXRCaWdJbnQ2NCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb21vdGVMb25ncyAmJiBwcm9tb3RlVmFsdWVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPVxuICAgICAgICAgICAgICAgICAgICBsb25nLmxlc3NUaGFuT3JFcXVhbChKU19JTlRfTUFYX0xPTkcpICYmIGxvbmcuZ3JlYXRlclRoYW5PckVxdWFsKEpTX0lOVF9NSU5fTE9ORylcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbG9uZy50b051bWJlcigpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGxvbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxvbmc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9ERUNJTUFMMTI4KSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IEJ5dGVVdGlscy5hbGxvY2F0ZSgxNik7XG4gICAgICAgICAgICBieXRlcy5zZXQoYnVmZmVyLnN1YmFycmF5KGluZGV4LCBpbmRleCArIDE2KSwgMCk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgMTY7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBEZWNpbWFsMTI4KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX0JJTkFSWSkge1xuICAgICAgICAgICAgbGV0IGJpbmFyeVNpemUgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQmluYXJ5U2l6ZSA9IGJpbmFyeVNpemU7XG4gICAgICAgICAgICBjb25zdCBzdWJUeXBlID0gYnVmZmVyW2luZGV4KytdO1xuICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPCAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ05lZ2F0aXZlIGJpbmFyeSB0eXBlIGVsZW1lbnQgc2l6ZSBmb3VuZCcpO1xuICAgICAgICAgICAgaWYgKGJpbmFyeVNpemUgPiBidWZmZXIuYnl0ZUxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdCaW5hcnkgdHlwZSBzaXplIGxhcmdlciB0aGFuIGRvY3VtZW50IHNpemUnKTtcbiAgICAgICAgICAgIGlmIChidWZmZXJbJ3NsaWNlJ10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChzdWJUeXBlID09PSBCaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVNpemUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ05lZ2F0aXZlIGJpbmFyeSB0eXBlIGVsZW1lbnQgc2l6ZSBmb3VuZCBmb3Igc3VidHlwZSAweDAyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplID4gdG90YWxCaW5hcnlTaXplIC0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSB0eXBlIHdpdGggc3VidHlwZSAweDAyIGNvbnRhaW5zIHRvbyBsb25nIGJpbmFyeSBzaXplJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgdG90YWxCaW5hcnlTaXplIC0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSB0eXBlIHdpdGggc3VidHlwZSAweDAyIGNvbnRhaW5zIHRvbyBzaG9ydCBiaW5hcnkgc2l6ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvbW90ZUJ1ZmZlcnMgJiYgcHJvbW90ZVZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIuc2xpY2UoaW5kZXgsIGluZGV4ICsgYmluYXJ5U2l6ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQmluYXJ5KGJ1ZmZlci5zbGljZShpbmRleCwgaW5kZXggKyBiaW5hcnlTaXplKSwgc3ViVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJUeXBlID09PSBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXICYmIFVVSUQuaXNWYWxpZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9VVUlEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBfYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKGJpbmFyeVNpemUpO1xuICAgICAgICAgICAgICAgIGlmIChzdWJUeXBlID09PSBCaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG4gICAgICAgICAgICAgICAgICAgIGJpbmFyeVNpemUgPVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ05lZ2F0aXZlIGJpbmFyeSB0eXBlIGVsZW1lbnQgc2l6ZSBmb3VuZCBmb3Igc3VidHlwZSAweDAyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplID4gdG90YWxCaW5hcnlTaXplIC0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSB0eXBlIHdpdGggc3VidHlwZSAweDAyIGNvbnRhaW5zIHRvbyBsb25nIGJpbmFyeSBzaXplJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiaW5hcnlTaXplIDwgdG90YWxCaW5hcnlTaXplIC0gNClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0JpbmFyeSB0eXBlIHdpdGggc3VidHlwZSAweDAyIGNvbnRhaW5zIHRvbyBzaG9ydCBiaW5hcnkgc2l6ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgYmluYXJ5U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9idWZmZXJbaV0gPSBidWZmZXJbaW5kZXggKyBpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHByb21vdGVCdWZmZXJzICYmIHByb21vdGVWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfYnVmZmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQmluYXJ5KGJ1ZmZlci5zbGljZShpbmRleCwgaW5kZXggKyBiaW5hcnlTaXplKSwgc3ViVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJUeXBlID09PSBCU09OX0JJTkFSWV9TVUJUWVBFX1VVSURfTkVXICYmIFVVSUQuaXNWYWxpZCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9VVUlEKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgYmluYXJ5U2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX1JFR0VYUCAmJiBic29uUmVnRXhwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaSA9IGluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMHgwMCAmJiBpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpLCBmYWxzZSk7XG4gICAgICAgICAgICBpbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgaSA9IGluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMHgwMCAmJiBpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpO1xuICAgICAgICAgICAgY29uc3QgcmVnRXhwT3B0aW9ucyA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSwgZmFsc2UpO1xuICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNBcnJheSA9IG5ldyBBcnJheShyZWdFeHBPcHRpb25zLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmVnRXhwT3B0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAocmVnRXhwT3B0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNBcnJheVtpXSA9ICdtJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNBcnJheVtpXSA9ICdnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdpJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnNBcnJheVtpXSA9ICdpJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbmV3IFJlZ0V4cChzb3VyY2UsIG9wdGlvbnNBcnJheS5qb2luKCcnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9SRUdFWFAgJiYgYnNvblJlZ0V4cCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaSA9IGluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMHgwMCAmJiBpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpLCBmYWxzZSk7XG4gICAgICAgICAgICBpbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgaSA9IGluZGV4O1xuICAgICAgICAgICAgd2hpbGUgKGJ1ZmZlcltpXSAhPT0gMHgwMCAmJiBpIDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID49IGJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQmFkIEJTT04gRG9jdW1lbnQ6IGlsbGVnYWwgQ1N0cmluZycpO1xuICAgICAgICAgICAgY29uc3QgcmVnRXhwT3B0aW9ucyA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaSwgZmFsc2UpO1xuICAgICAgICAgICAgaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IEJTT05SZWdFeHAoc291cmNlLCByZWdFeHBPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX1NZTUJPTCkge1xuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2l6ZSA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ1NpemUgPD0gMCB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1NpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXggfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyBzdHJpbmdTaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzeW1ib2wgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEsIHNob3VsZFZhbGlkYXRlS2V5KTtcbiAgICAgICAgICAgIHZhbHVlID0gcHJvbW90ZVZhbHVlcyA/IHN5bWJvbCA6IG5ldyBCU09OU3ltYm9sKHN5bWJvbCk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgc3RyaW5nU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX1RJTUVTVEFNUCkge1xuICAgICAgICAgICAgY29uc3QgaSA9IGJ1ZmZlcltpbmRleCsrXSArXG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdICogKDEgPDwgOCkgK1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSAqICgxIDw8IDE2KSArXG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdICogKDEgPDwgMjQpO1xuICAgICAgICAgICAgY29uc3QgdCA9IGJ1ZmZlcltpbmRleCsrXSArXG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdICogKDEgPDwgOCkgK1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCsrXSAqICgxIDw8IDE2KSArXG4gICAgICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdICogKDEgPDwgMjQpO1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgVGltZXN0YW1wKHsgaSwgdCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50VHlwZSA9PT0gQlNPTl9EQVRBX01JTl9LRVkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IE1pbktleSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfTUFYX0tFWSkge1xuICAgICAgICAgICAgdmFsdWUgPSBuZXcgTWF4S2V5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudFR5cGUgPT09IEJTT05fREFUQV9DT0RFKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdTaXplID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nU2l6ZSA8PSAwIHx8XG4gICAgICAgICAgICAgICAgc3RyaW5nU2l6ZSA+IGJ1ZmZlci5sZW5ndGggLSBpbmRleCB8fFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIHN0cmluZ1NpemUgLSAxXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2JhZCBzdHJpbmcgbGVuZ3RoIGluIGJzb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gQnl0ZVV0aWxzLnRvVVRGOChidWZmZXIsIGluZGV4LCBpbmRleCArIHN0cmluZ1NpemUgLSAxLCBzaG91bGRWYWxpZGF0ZUtleSk7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ldyBDb2RlKGZ1bmN0aW9uU3RyaW5nKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBzdHJpbmdTaXplO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfQ09ERV9XX1NDT1BFKSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbFNpemUgPSBidWZmZXJbaW5kZXgrK10gfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDI0KTtcbiAgICAgICAgICAgIGlmICh0b3RhbFNpemUgPCA0ICsgNCArIDQgKyAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29kZV93X3Njb3BlIHRvdGFsIHNpemUgc2hvcnRlciBtaW5pbXVtIGV4cGVjdGVkIGxlbmd0aCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RyaW5nU2l6ZSA9IGJ1ZmZlcltpbmRleCsrXSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCA4KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXgrK10gPDwgMjQpO1xuICAgICAgICAgICAgaWYgKHN0cmluZ1NpemUgPD0gMCB8fFxuICAgICAgICAgICAgICAgIHN0cmluZ1NpemUgPiBidWZmZXIubGVuZ3RoIC0gaW5kZXggfHxcbiAgICAgICAgICAgICAgICBidWZmZXJbaW5kZXggKyBzdHJpbmdTaXplIC0gMV0gIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBmdW5jdGlvblN0cmluZyA9IEJ5dGVVdGlscy50b1VURjgoYnVmZmVyLCBpbmRleCwgaW5kZXggKyBzdHJpbmdTaXplIC0gMSwgc2hvdWxkVmFsaWRhdGVLZXkpO1xuICAgICAgICAgICAgaW5kZXggPSBpbmRleCArIHN0cmluZ1NpemU7XG4gICAgICAgICAgICBjb25zdCBfaW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFNpemUgPSBidWZmZXJbaW5kZXhdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4ICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAyXSA8PCAxNikgfFxuICAgICAgICAgICAgICAgIChidWZmZXJbaW5kZXggKyAzXSA8PCAyNCk7XG4gICAgICAgICAgICBjb25zdCBzY29wZU9iamVjdCA9IGRlc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwgX2luZGV4LCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgb2JqZWN0U2l6ZTtcbiAgICAgICAgICAgIGlmICh0b3RhbFNpemUgPCA0ICsgNCArIG9iamVjdFNpemUgKyBzdHJpbmdTaXplKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignY29kZV93X3Njb3BlIHRvdGFsIHNpemUgaXMgdG9vIHNob3J0LCB0cnVuY2F0aW5nIHNjb3BlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG90YWxTaXplID4gNCArIDQgKyBvYmplY3RTaXplICsgc3RyaW5nU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvZGVfd19zY29wZSB0b3RhbCBzaXplIGlzIHRvbyBsb25nLCBjbGlwcyBvdXRlciBkb2N1bWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBuZXcgQ29kZShmdW5jdGlvblN0cmluZywgc2NvcGVPYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnRUeXBlID09PSBCU09OX0RBVEFfREJQT0lOVEVSKSB7XG4gICAgICAgICAgICBjb25zdCBzdHJpbmdTaXplID0gYnVmZmVyW2luZGV4KytdIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAoYnVmZmVyW2luZGV4KytdIDw8IDE2KSB8XG4gICAgICAgICAgICAgICAgKGJ1ZmZlcltpbmRleCsrXSA8PCAyNCk7XG4gICAgICAgICAgICBpZiAoc3RyaW5nU2l6ZSA8PSAwIHx8XG4gICAgICAgICAgICAgICAgc3RyaW5nU2l6ZSA+IGJ1ZmZlci5sZW5ndGggLSBpbmRleCB8fFxuICAgICAgICAgICAgICAgIGJ1ZmZlcltpbmRleCArIHN0cmluZ1NpemUgLSAxXSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdiYWQgc3RyaW5nIGxlbmd0aCBpbiBic29uJyk7XG4gICAgICAgICAgICBpZiAodmFsaWRhdGlvbiAhPSBudWxsICYmIHZhbGlkYXRpb24udXRmOCkge1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVVdGY4KGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ0ludmFsaWQgVVRGLTggc3RyaW5nIGluIEJTT04gZG9jdW1lbnQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSBCeXRlVXRpbHMudG9VVEY4KGJ1ZmZlciwgaW5kZXgsIGluZGV4ICsgc3RyaW5nU2l6ZSAtIDEsIGZhbHNlKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyBzdHJpbmdTaXplO1xuICAgICAgICAgICAgY29uc3Qgb2lkQnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKDEyKTtcbiAgICAgICAgICAgIG9pZEJ1ZmZlci5zZXQoYnVmZmVyLnN1YmFycmF5KGluZGV4LCBpbmRleCArIDEyKSwgMCk7XG4gICAgICAgICAgICBjb25zdCBvaWQgPSBuZXcgT2JqZWN0SWQob2lkQnVmZmVyKTtcbiAgICAgICAgICAgIGluZGV4ID0gaW5kZXggKyAxMjtcbiAgICAgICAgICAgIHZhbHVlID0gbmV3IERCUmVmKG5hbWVzcGFjZSwgb2lkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYERldGVjdGVkIHVua25vd24gQlNPTiB0eXBlICR7ZWxlbWVudFR5cGUudG9TdHJpbmcoMTYpfSBmb3IgZmllbGRuYW1lIFwiJHtuYW1lfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2JqZWN0W25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNpemUgIT09IGluZGV4IC0gc3RhcnRJbmRleCkge1xuICAgICAgICBpZiAoaXNBcnJheSlcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ2NvcnJ1cHQgYXJyYXkgYnNvbicpO1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdjb3JydXB0IG9iamVjdCBic29uJyk7XG4gICAgfVxuICAgIGlmICghaXNQb3NzaWJsZURCUmVmKVxuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIGlmIChpc0RCUmVmTGlrZShvYmplY3QpKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvYmplY3QpO1xuICAgICAgICBkZWxldGUgY29weS4kcmVmO1xuICAgICAgICBkZWxldGUgY29weS4kaWQ7XG4gICAgICAgIGRlbGV0ZSBjb3B5LiRkYjtcbiAgICAgICAgcmV0dXJuIG5ldyBEQlJlZihvYmplY3QuJHJlZiwgb2JqZWN0LiRpZCwgb2JqZWN0LiRkYiwgY29weSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5cbmNvbnN0IHJlZ2V4cCA9IC9cXHgwMC87XG5jb25zdCBpZ25vcmVLZXlzID0gbmV3IFNldChbJyRkYicsICckcmVmJywgJyRpZCcsICckY2x1c3RlclRpbWUnXSk7XG5mdW5jdGlvbiBzZXJpYWxpemVTdHJpbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9TVFJJTkc7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgKyAxO1xuICAgIGJ1ZmZlcltpbmRleCAtIDFdID0gMDtcbiAgICBjb25zdCBzaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUsIGluZGV4ICsgNCk7XG4gICAgYnVmZmVyW2luZGV4ICsgM10gPSAoKHNpemUgKyAxKSA+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDJdID0gKChzaXplICsgMSkgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAxXSA9ICgoc2l6ZSArIDEpID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXhdID0gKHNpemUgKyAxKSAmIDB4ZmY7XG4gICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuY29uc3QgTlVNQkVSX1NQQUNFID0gbmV3IERhdGFWaWV3KG5ldyBBcnJheUJ1ZmZlcig4KSwgMCwgOCk7XG5jb25zdCBGT1VSX0JZVEVfVklFV19PTl9OVU1CRVIgPSBuZXcgVWludDhBcnJheShOVU1CRVJfU1BBQ0UuYnVmZmVyLCAwLCA0KTtcbmNvbnN0IEVJR0hUX0JZVEVfVklFV19PTl9OVU1CRVIgPSBuZXcgVWludDhBcnJheShOVU1CRVJfU1BBQ0UuYnVmZmVyLCAwLCA4KTtcbmZ1bmN0aW9uIHNlcmlhbGl6ZU51bWJlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgY29uc3QgaXNOZWdhdGl2ZVplcm8gPSBPYmplY3QuaXModmFsdWUsIC0wKTtcbiAgICBjb25zdCB0eXBlID0gIWlzTmVnYXRpdmVaZXJvICYmXG4gICAgICAgIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbHVlKSAmJlxuICAgICAgICB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCAmJlxuICAgICAgICB2YWx1ZSA+PSBCU09OX0lOVDMyX01JTlxuICAgICAgICA/IEJTT05fREFUQV9JTlRcbiAgICAgICAgOiBCU09OX0RBVEFfTlVNQkVSO1xuICAgIGlmICh0eXBlID09PSBCU09OX0RBVEFfSU5UKSB7XG4gICAgICAgIE5VTUJFUl9TUEFDRS5zZXRJbnQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBOVU1CRVJfU1BBQ0Uuc2V0RmxvYXQ2NCgwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gdHlwZSA9PT0gQlNPTl9EQVRBX0lOVCA/IEZPVVJfQllURV9WSUVXX09OX05VTUJFUiA6IEVJR0hUX0JZVEVfVklFV19PTl9OVU1CRVI7XG4gICAgYnVmZmVyW2luZGV4KytdID0gdHlwZTtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAweDAwO1xuICAgIGJ1ZmZlci5zZXQoYnl0ZXMsIGluZGV4KTtcbiAgICBpbmRleCArPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJpZ0ludChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0xPTkc7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCArPSBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIE5VTUJFUl9TUEFDRS5zZXRCaWdJbnQ2NCgwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgYnVmZmVyLnNldChFSUdIVF9CWVRFX1ZJRVdfT05fTlVNQkVSLCBpbmRleCk7XG4gICAgaW5kZXggKz0gRUlHSFRfQllURV9WSUVXX09OX05VTUJFUi5ieXRlTGVuZ3RoO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIF8sIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX05VTEw7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVCb29sZWFuKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQk9PTEVBTjtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHZhbHVlID8gMSA6IDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRGF0ZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX0RBVEU7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBjb25zdCBkYXRlSW5NaWxpcyA9IExvbmcuZnJvbU51bWJlcih2YWx1ZS5nZXRUaW1lKCkpO1xuICAgIGNvbnN0IGxvd0JpdHMgPSBkYXRlSW5NaWxpcy5nZXRMb3dCaXRzKCk7XG4gICAgY29uc3QgaGlnaEJpdHMgPSBkYXRlSW5NaWxpcy5nZXRIaWdoQml0cygpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IGxvd0JpdHMgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChsb3dCaXRzID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAobG93Qml0cyA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChsb3dCaXRzID4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gaGlnaEJpdHMgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChoaWdoQml0cyA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGhpZ2hCaXRzID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGhpZ2hCaXRzID4+IDI0KSAmIDB4ZmY7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfUkVHRVhQO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgaWYgKHZhbHVlLnNvdXJjZSAmJiB2YWx1ZS5zb3VyY2UubWF0Y2gocmVnZXhwKSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3ZhbHVlICcgKyB2YWx1ZS5zb3VyY2UgKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgIH1cbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUuc291cmNlLCBpbmRleCk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBpZiAodmFsdWUuaWdub3JlQ2FzZSlcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMHg2OTtcbiAgICBpZiAodmFsdWUuZ2xvYmFsKVxuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSAweDczO1xuICAgIGlmICh2YWx1ZS5tdWx0aWxpbmUpXG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4NmQ7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVCU09OUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfUkVHRVhQO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgaWYgKHZhbHVlLnBhdHRlcm4ubWF0Y2gocmVnZXhwKSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3BhdHRlcm4gJyArIHZhbHVlLnBhdHRlcm4gKyAnIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBieXRlcycpO1xuICAgIH1cbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgdmFsdWUucGF0dGVybiwgaW5kZXgpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgY29uc3Qgc29ydGVkT3B0aW9ucyA9IHZhbHVlLm9wdGlvbnMuc3BsaXQoJycpLnNvcnQoKS5qb2luKCcnKTtcbiAgICBpbmRleCA9IGluZGV4ICsgQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgc29ydGVkT3B0aW9ucywgaW5kZXgpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDB4MDA7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTWluTWF4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX05VTEw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ01pbktleScpIHtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX01JTl9LRVk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfTUFYX0tFWTtcbiAgICB9XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3RJZChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX09JRDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGlkVmFsdWUgPSB2YWx1ZS5pZDtcbiAgICBpZiAoaXNVaW50OEFycmF5KGlkVmFsdWUpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgYnVmZmVyW2luZGV4KytdID0gaWRWYWx1ZVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignb2JqZWN0IFsnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ10gaXMgbm90IGEgdmFsaWQgT2JqZWN0SWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQklOQVJZO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3Qgc2l6ZSA9IHZhbHVlLmxlbmd0aDtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBzaXplICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiAyNCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVDtcbiAgICBidWZmZXIuc2V0KHZhbHVlLCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIHNpemU7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplT2JqZWN0KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKSB7XG4gICAgaWYgKHBhdGguaGFzKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdDYW5ub3QgY29udmVydCBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gQlNPTicpO1xuICAgIH1cbiAgICBwYXRoLmFkZCh2YWx1ZSk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyBCU09OX0RBVEFfQVJSQVkgOiBCU09OX0RBVEFfT0JKRUNUO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzZXJpYWxpemVJbnRvKGJ1ZmZlciwgdmFsdWUsIGNoZWNrS2V5cywgaW5kZXgsIGRlcHRoICsgMSwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgIHBhdGguZGVsZXRlKHZhbHVlKTtcbiAgICByZXR1cm4gZW5kSW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEZWNpbWFsMTI4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfREVDSU1BTDEyODtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGJ1ZmZlci5zZXQodmFsdWUuYnl0ZXMuc3ViYXJyYXkoMCwgMTYpLCBpbmRleCk7XG4gICAgcmV0dXJuIGluZGV4ICsgMTY7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVMb25nKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPVxuICAgICAgICB2YWx1ZS5fYnNvbnR5cGUgPT09ICdMb25nJyA/IEJTT05fREFUQV9MT05HIDogQlNPTl9EQVRBX1RJTUVTVEFNUDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IGxvd0JpdHMgPSB2YWx1ZS5nZXRMb3dCaXRzKCk7XG4gICAgY29uc3QgaGlnaEJpdHMgPSB2YWx1ZS5nZXRIaWdoQml0cygpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IGxvd0JpdHMgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChsb3dCaXRzID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAobG93Qml0cyA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChsb3dCaXRzID4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gaGlnaEJpdHMgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChoaWdoQml0cyA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGhpZ2hCaXRzID4+IDE2KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKGhpZ2hCaXRzID4+IDI0KSAmIDB4ZmY7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplSW50MzIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIHZhbHVlID0gdmFsdWUudmFsdWVPZigpO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9JTlQ7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBidWZmZXJbaW5kZXgrK10gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gKHZhbHVlID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAodmFsdWUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAodmFsdWUgPj4gMjQpICYgMHhmZjtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9OVU1CRVI7XG4gICAgY29uc3QgbnVtYmVyT2ZXcml0dGVuQnl0ZXMgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBrZXksIGluZGV4KTtcbiAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICBOVU1CRVJfU1BBQ0Uuc2V0RmxvYXQ2NCgwLCB2YWx1ZS52YWx1ZSwgdHJ1ZSk7XG4gICAgYnVmZmVyLnNldChFSUdIVF9CWVRFX1ZJRVdfT05fTlVNQkVSLCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIDg7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRnVuY3Rpb24oYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCkge1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9DT0RFO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3QgZnVuY3Rpb25TdHJpbmcgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIGNvbnN0IHNpemUgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCBmdW5jdGlvblN0cmluZywgaW5kZXggKyA0KSArIDE7XG4gICAgYnVmZmVyW2luZGV4XSA9IHNpemUgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDFdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDJdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAzXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUNvZGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzID0gZmFsc2UsIGRlcHRoID0gMCwgc2VyaWFsaXplRnVuY3Rpb25zID0gZmFsc2UsIGlnbm9yZVVuZGVmaW5lZCA9IHRydWUsIHBhdGgpIHtcbiAgICBpZiAodmFsdWUuc2NvcGUgJiYgdHlwZW9mIHZhbHVlLnNjb3BlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQ09ERV9XX1NDT1BFO1xuICAgICAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgICAgIGxldCBzdGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gdmFsdWUuY29kZTtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIDQ7XG4gICAgICAgIGNvbnN0IGNvZGVTaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCkgKyAxO1xuICAgICAgICBidWZmZXJbaW5kZXhdID0gY29kZVNpemUgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAxXSA9IChjb2RlU2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCArIDJdID0gKGNvZGVTaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCArIDNdID0gKGNvZGVTaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCArIDQgKyBjb2RlU2l6ZSAtIDFdID0gMDtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIGNvZGVTaXplICsgNDtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSBzZXJpYWxpemVJbnRvKGJ1ZmZlciwgdmFsdWUuc2NvcGUsIGNoZWNrS2V5cywgaW5kZXgsIGRlcHRoICsgMSwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICBpbmRleCA9IGVuZEluZGV4IC0gMTtcbiAgICAgICAgY29uc3QgdG90YWxTaXplID0gZW5kSW5kZXggLSBzdGFydEluZGV4O1xuICAgICAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9IHRvdGFsU2l6ZSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gKHRvdGFsU2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gKHRvdGFsU2l6ZSA+PiAxNikgJiAweGZmO1xuICAgICAgICBidWZmZXJbc3RhcnRJbmRleCsrXSA9ICh0b3RhbFNpemUgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IEJTT05fREFUQV9DT0RFO1xuICAgICAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4ICsgbnVtYmVyT2ZXcml0dGVuQnl0ZXM7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uU3RyaW5nID0gdmFsdWUuY29kZS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBzaXplID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwgZnVuY3Rpb25TdHJpbmcsIGluZGV4ICsgNCkgKyAxO1xuICAgICAgICBidWZmZXJbaW5kZXhdID0gc2l6ZSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCArIDFdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgICAgICBidWZmZXJbaW5kZXggKyAyXSA9IChzaXplID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCArIDNdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQmluYXJ5KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfQklOQVJZO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgY29uc3QgZGF0YSA9IHZhbHVlLmJ1ZmZlcjtcbiAgICBsZXQgc2l6ZSA9IHZhbHVlLnBvc2l0aW9uO1xuICAgIGlmICh2YWx1ZS5zdWJfdHlwZSA9PT0gQmluYXJ5LlNVQlRZUEVfQllURV9BUlJBWSlcbiAgICAgICAgc2l6ZSA9IHNpemUgKyA0O1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IHNpemUgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgYnVmZmVyW2luZGV4KytdID0gdmFsdWUuc3ViX3R5cGU7XG4gICAgaWYgKHZhbHVlLnN1Yl90eXBlID09PSBCaW5hcnkuU1VCVFlQRV9CWVRFX0FSUkFZKSB7XG4gICAgICAgIHNpemUgPSBzaXplIC0gNDtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG4gICAgICAgIGJ1ZmZlcltpbmRleCsrXSA9IChzaXplID4+IDgpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICAgICAgYnVmZmVyW2luZGV4KytdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICB9XG4gICAgYnVmZmVyLnNldChkYXRhLCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIHZhbHVlLnBvc2l0aW9uO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN5bWJvbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KSB7XG4gICAgYnVmZmVyW2luZGV4KytdID0gQlNPTl9EQVRBX1NZTUJPTDtcbiAgICBjb25zdCBudW1iZXJPZldyaXR0ZW5CeXRlcyA9IEJ5dGVVdGlscy5lbmNvZGVVVEY4SW50byhidWZmZXIsIGtleSwgaW5kZXgpO1xuICAgIGluZGV4ID0gaW5kZXggKyBudW1iZXJPZldyaXR0ZW5CeXRlcztcbiAgICBidWZmZXJbaW5kZXgrK10gPSAwO1xuICAgIGNvbnN0IHNpemUgPSBCeXRlVXRpbHMuZW5jb2RlVVRGOEludG8oYnVmZmVyLCB2YWx1ZS52YWx1ZSwgaW5kZXggKyA0KSArIDE7XG4gICAgYnVmZmVyW2luZGV4XSA9IHNpemUgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDFdID0gKHNpemUgPj4gOCkgJiAweGZmO1xuICAgIGJ1ZmZlcltpbmRleCArIDJdID0gKHNpemUgPj4gMTYpICYgMHhmZjtcbiAgICBidWZmZXJbaW5kZXggKyAzXSA9IChzaXplID4+IDI0KSAmIDB4ZmY7XG4gICAgaW5kZXggPSBpbmRleCArIDQgKyBzaXplIC0gMTtcbiAgICBidWZmZXJbaW5kZXgrK10gPSAweDAwO1xuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZURCUmVmKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIHBhdGgpIHtcbiAgICBidWZmZXJbaW5kZXgrK10gPSBCU09OX0RBVEFfT0JKRUNUO1xuICAgIGNvbnN0IG51bWJlck9mV3JpdHRlbkJ5dGVzID0gQnl0ZVV0aWxzLmVuY29kZVVURjhJbnRvKGJ1ZmZlciwga2V5LCBpbmRleCk7XG4gICAgaW5kZXggPSBpbmRleCArIG51bWJlck9mV3JpdHRlbkJ5dGVzO1xuICAgIGJ1ZmZlcltpbmRleCsrXSA9IDA7XG4gICAgbGV0IHN0YXJ0SW5kZXggPSBpbmRleDtcbiAgICBsZXQgb3V0cHV0ID0ge1xuICAgICAgICAkcmVmOiB2YWx1ZS5jb2xsZWN0aW9uIHx8IHZhbHVlLm5hbWVzcGFjZSxcbiAgICAgICAgJGlkOiB2YWx1ZS5vaWRcbiAgICB9O1xuICAgIGlmICh2YWx1ZS5kYiAhPSBudWxsKSB7XG4gICAgICAgIG91dHB1dC4kZGIgPSB2YWx1ZS5kYjtcbiAgICB9XG4gICAgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbihvdXRwdXQsIHZhbHVlLmZpZWxkcyk7XG4gICAgY29uc3QgZW5kSW5kZXggPSBzZXJpYWxpemVJbnRvKGJ1ZmZlciwgb3V0cHV0LCBmYWxzZSwgaW5kZXgsIGRlcHRoICsgMSwgc2VyaWFsaXplRnVuY3Rpb25zLCB0cnVlLCBwYXRoKTtcbiAgICBjb25zdCBzaXplID0gZW5kSW5kZXggLSBzdGFydEluZGV4O1xuICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG4gICAgYnVmZmVyW3N0YXJ0SW5kZXgrK10gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW3N0YXJ0SW5kZXgrK10gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydEluZGV4KytdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICByZXR1cm4gZW5kSW5kZXg7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVJbnRvKGJ1ZmZlciwgb2JqZWN0LCBjaGVja0tleXMsIHN0YXJ0aW5nSW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCkge1xuICAgIGlmIChwYXRoID09IG51bGwpIHtcbiAgICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBidWZmZXJbMF0gPSAweDA1O1xuICAgICAgICAgICAgYnVmZmVyWzFdID0gMHgwMDtcbiAgICAgICAgICAgIGJ1ZmZlclsyXSA9IDB4MDA7XG4gICAgICAgICAgICBidWZmZXJbM10gPSAweDAwO1xuICAgICAgICAgICAgYnVmZmVyWzRdID0gMHgwMDtcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ3NlcmlhbGl6ZSBkb2VzIG5vdCBzdXBwb3J0IGFuIGFycmF5IGFzIHRoZSByb290IGlucHV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdzZXJpYWxpemUgZG9lcyBub3Qgc3VwcG9ydCBub24tb2JqZWN0IGFzIHRoZSByb290IGlucHV0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ19ic29udHlwZScgaW4gb2JqZWN0ICYmIHR5cGVvZiBvYmplY3QuX2Jzb250eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgQlNPTiB0eXBlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBhcyBhIGRvY3VtZW50YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlKG9iamVjdCkgfHxcbiAgICAgICAgICAgIGlzUmVnRXhwKG9iamVjdCkgfHxcbiAgICAgICAgICAgIGlzVWludDhBcnJheShvYmplY3QpIHx8XG4gICAgICAgICAgICBpc0FueUFycmF5QnVmZmVyKG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYGRhdGUsIHJlZ2V4cCwgdHlwZWRhcnJheSwgYW5kIGFycmF5YnVmZmVyIGNhbm5vdCBiZSBCU09OIGRvY3VtZW50c2ApO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIHBhdGguYWRkKG9iamVjdCk7XG4gICAgbGV0IGluZGV4ID0gc3RhcnRpbmdJbmRleCArIDQ7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7aX1gO1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gb2JqZWN0W2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZT8udG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0JTT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTdHJpbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdW1iZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCaWdJbnQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQm9vbGVhbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCBpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEYXRlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVOdWxsKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNVaW50OEFycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQnVmZmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAgfHwgaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVSZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9ic29udHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlW1N5bWJvbC5mb3IoJ0BAbWRiLmJzb24udmVyc2lvbicpXSAhPT0gQlNPTl9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05WZXJzaW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0SWQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEZWNpbWFsMTI4Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0xvbmcnIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ1RpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUxvbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgc2VyaWFsaXplRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVGdW5jdGlvbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0NvZGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVDb2RlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JpbmFyeScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpbmFyeShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05TeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTeW1ib2woYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURCUmVmKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJTT05SZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdJbnQzMicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUludDMyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTWluS2V5JyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdNYXhLZXknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVNaW5NYXgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuX2Jzb250eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVucmVjb2duaXplZCBvciBpbnZhbGlkIF9ic29udHlwZTogJHtTdHJpbmcodmFsdWUuX2Jzb250eXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChvYmplY3QgaW5zdGFuY2VvZiBNYXAgfHwgaXNNYXAob2JqZWN0KSkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IG9iamVjdC5lbnRyaWVzKCk7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghZG9uZSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnkgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBkb25lID0gISFlbnRyeS5kb25lO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBlbnRyeS52YWx1ZVswXTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVudHJ5LnZhbHVlWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZT8udG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0JTT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIWlnbm9yZUtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lm1hdGNoKHJlZ2V4cCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArICcgbXVzdCBub3QgY29udGFpbiBudWxsIGJ5dGVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja0tleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCckJyA9PT0ga2V5WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArIFwiIG11c3Qgbm90IHN0YXJ0IHdpdGggJyQnXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKH5rZXkuaW5kZXhPZignLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArIFwiIG11c3Qgbm90IGNvbnRhaW4gJy4nXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTdHJpbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVtYmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpZ0ludChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQm9vbGVhbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCBpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEYXRlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IG51bGwgfHwgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgaWdub3JlVW5kZWZpbmVkID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1VpbnQ4QXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVCdWZmZXIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9ic29udHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3QoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgY2hlY2tLZXlzLCBkZXB0aCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgICAgIHZhbHVlW1N5bWJvbC5mb3IoJ0BAbWRiLmJzb24udmVyc2lvbicpXSAhPT0gQlNPTl9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05WZXJzaW9uRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ09iamVjdElkJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplT2JqZWN0SWQoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5fYnNvbnR5cGUgPT09ICdEZWNpbWFsMTI4Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplRGVjaW1hbDEyOChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0xvbmcnIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ1RpbWVzdGFtcCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUxvbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEb3VibGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEb3VibGUoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdDb2RlJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQ29kZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgc2VyaWFsaXplRnVuY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVGdW5jdGlvbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JpbmFyeScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpbmFyeShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0JTT05TeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTeW1ib2woYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdEQlJlZicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURCUmVmKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIHBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlJlZ0V4cCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJTT05SZWdFeHAoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdJbnQzMicpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUludDMyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTWluS2V5JyB8fCB2YWx1ZS5fYnNvbnR5cGUgPT09ICdNYXhLZXknKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVNaW5NYXgoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUuX2Jzb250eXBlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYFVucmVjb2duaXplZCBvciBpbnZhbGlkIF9ic29udHlwZTogJHtTdHJpbmcodmFsdWUuX2Jzb250eXBlKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmplY3Q/LnRvQlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb2JqZWN0ID0gb2JqZWN0LnRvQlNPTigpO1xuICAgICAgICAgICAgaWYgKG9iamVjdCAhPSBudWxsICYmIHR5cGVvZiBvYmplY3QgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcigndG9CU09OIGZ1bmN0aW9uIGRpZCBub3QgcmV0dXJuIGFuIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iamVjdCkpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZT8udG9CU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0JTT04oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIWlnbm9yZUtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5Lm1hdGNoKHJlZ2V4cCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArICcgbXVzdCBub3QgY29udGFpbiBudWxsIGJ5dGVzJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja0tleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCckJyA9PT0ga2V5WzBdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArIFwiIG11c3Qgbm90IHN0YXJ0IHdpdGggJyQnXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKH5rZXkuaW5kZXhPZignLicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdrZXkgJyArIGtleSArIFwiIG11c3Qgbm90IGNvbnRhaW4gJy4nXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVTdHJpbmcoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVtYmVyKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJpZ0ludChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQm9vbGVhbihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCBpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEYXRlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChpZ25vcmVVbmRlZmluZWQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU51bGwoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTnVsbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVWludDhBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUJ1ZmZlcihidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwIHx8IGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplUmVnRXhwKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUuX2Jzb250eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU9iamVjdChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4LCBjaGVja0tleXMsIGRlcHRoLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICAgICAgdmFsdWVbU3ltYm9sLmZvcignQEBtZGIuYnNvbi52ZXJzaW9uJyldICE9PSBCU09OX01BSk9SX1ZFUlNJT04pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlZlcnNpb25FcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnT2JqZWN0SWQnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVPYmplY3RJZChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLl9ic29udHlwZSA9PT0gJ0RlY2ltYWwxMjgnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVEZWNpbWFsMTI4KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnTG9uZycgfHwgdmFsdWUuX2Jzb250eXBlID09PSAnVGltZXN0YW1wJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplTG9uZyhidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RvdWJsZScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZURvdWJsZShidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0NvZGUnKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBzZXJpYWxpemVDb2RlKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgsIGNoZWNrS2V5cywgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkLCBwYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBzZXJpYWxpemVGdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZUZ1bmN0aW9uKGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQmluYXJ5Jykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQmluYXJ5KGJ1ZmZlciwga2V5LCB2YWx1ZSwgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUuX2Jzb250eXBlID09PSAnQlNPTlN5bWJvbCcpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZVN5bWJvbChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0RCUmVmJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplREJSZWYoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCwgZGVwdGgsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgcGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdCU09OUmVnRXhwJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplQlNPTlJlZ0V4cChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbHVlLl9ic29udHlwZSA9PT0gJ0ludDMyJykge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gc2VyaWFsaXplSW50MzIoYnVmZmVyLCBrZXksIHZhbHVlLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZS5fYnNvbnR5cGUgPT09ICdNaW5LZXknIHx8IHZhbHVlLl9ic29udHlwZSA9PT0gJ01heEtleScpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHNlcmlhbGl6ZU1pbk1heChidWZmZXIsIGtleSwgdmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS5fYnNvbnR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcihgVW5yZWNvZ25pemVkIG9yIGludmFsaWQgX2Jzb250eXBlOiAke1N0cmluZyh2YWx1ZS5fYnNvbnR5cGUpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhdGguZGVsZXRlKG9iamVjdCk7XG4gICAgYnVmZmVyW2luZGV4KytdID0gMHgwMDtcbiAgICBjb25zdCBzaXplID0gaW5kZXggLSBzdGFydGluZ0luZGV4O1xuICAgIGJ1ZmZlcltzdGFydGluZ0luZGV4KytdID0gc2l6ZSAmIDB4ZmY7XG4gICAgYnVmZmVyW3N0YXJ0aW5nSW5kZXgrK10gPSAoc2l6ZSA+PiA4KSAmIDB4ZmY7XG4gICAgYnVmZmVyW3N0YXJ0aW5nSW5kZXgrK10gPSAoc2l6ZSA+PiAxNikgJiAweGZmO1xuICAgIGJ1ZmZlcltzdGFydGluZ0luZGV4KytdID0gKHNpemUgPj4gMjQpICYgMHhmZjtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5cbmZ1bmN0aW9uIGlzQlNPTlR5cGUodmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAnX2Jzb250eXBlJyBpbiB2YWx1ZSAmJlxuICAgICAgICB0eXBlb2YgdmFsdWUuX2Jzb250eXBlID09PSAnc3RyaW5nJyk7XG59XG5jb25zdCBrZXlzVG9Db2RlY3MgPSB7XG4gICAgJG9pZDogT2JqZWN0SWQsXG4gICAgJGJpbmFyeTogQmluYXJ5LFxuICAgICR1dWlkOiBCaW5hcnksXG4gICAgJHN5bWJvbDogQlNPTlN5bWJvbCxcbiAgICAkbnVtYmVySW50OiBJbnQzMixcbiAgICAkbnVtYmVyRGVjaW1hbDogRGVjaW1hbDEyOCxcbiAgICAkbnVtYmVyRG91YmxlOiBEb3VibGUsXG4gICAgJG51bWJlckxvbmc6IExvbmcsXG4gICAgJG1pbktleTogTWluS2V5LFxuICAgICRtYXhLZXk6IE1heEtleSxcbiAgICAkcmVnZXg6IEJTT05SZWdFeHAsXG4gICAgJHJlZ3VsYXJFeHByZXNzaW9uOiBCU09OUmVnRXhwLFxuICAgICR0aW1lc3RhbXA6IFRpbWVzdGFtcFxufTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplVmFsdWUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbnN0IGluMzJCaXRSYW5nZSA9IHZhbHVlIDw9IEJTT05fSU5UMzJfTUFYICYmIHZhbHVlID49IEJTT05fSU5UMzJfTUlOO1xuICAgICAgICBjb25zdCBpbjY0Qml0UmFuZ2UgPSB2YWx1ZSA8PSBCU09OX0lOVDY0X01BWCAmJiB2YWx1ZSA+PSBCU09OX0lOVDY0X01JTjtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVsYXhlZCB8fCBvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiAhT2JqZWN0LmlzKHZhbHVlLCAtMCkpIHtcbiAgICAgICAgICAgIGlmIChpbjMyQml0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEludDMyKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbjY0Qml0UmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy51c2VCaWdJbnQ2NCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnSW50KHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIExvbmcuZnJvbU51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBEb3VibGUodmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgaWYgKHZhbHVlLiR1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSkuZmlsdGVyKGsgPT4gay5zdGFydHNXaXRoKCckJykgJiYgdmFsdWVba10gIT0gbnVsbCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBrZXlzVG9Db2RlY3Nba2V5c1tpXV07XG4gICAgICAgIGlmIChjKVxuICAgICAgICAgICAgcmV0dXJuIGMuZnJvbUV4dGVuZGVkSlNPTih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS4kZGF0ZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGQgPSB2YWx1ZS4kZGF0ZTtcbiAgICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmxlZ2FjeSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoZCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKERhdGUucGFyc2UoZCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGQgPT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShOdW1iZXIoZCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBCU09OUnVudGltZUVycm9yKGBVbnJlY29nbml6ZWQgdHlwZSBmb3IgRUpTT04gZGF0ZTogJHt0eXBlb2YgZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZCA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKERhdGUucGFyc2UoZCkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoTG9uZy5pc0xvbmcoZCkpXG4gICAgICAgICAgICAgICAgZGF0ZS5zZXRUaW1lKGQudG9OdW1iZXIoKSk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZCA9PT0gJ251bWJlcicgJiYgb3B0aW9ucy5yZWxheGVkKVxuICAgICAgICAgICAgICAgIGRhdGUuc2V0VGltZShkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBkID09PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICBkYXRlLnNldFRpbWUoTnVtYmVyKGQpKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTlJ1bnRpbWVFcnJvcihgVW5yZWNvZ25pemVkIHR5cGUgZm9yIEVKU09OIGRhdGU6ICR7dHlwZW9mIGR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS4kY29kZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGNvcHkgPSBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZS4kc2NvcGUpIHtcbiAgICAgICAgICAgIGNvcHkuJHNjb3BlID0gZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZS4kc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBDb2RlLmZyb21FeHRlbmRlZEpTT04odmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNEQlJlZkxpa2UodmFsdWUpIHx8IHZhbHVlLiRkYlBvaW50ZXIpIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbHVlLiRyZWYgPyB2YWx1ZSA6IHZhbHVlLiRkYlBvaW50ZXI7XG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgREJSZWYpXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgY29uc3QgZG9sbGFyS2V5cyA9IE9iamVjdC5rZXlzKHYpLmZpbHRlcihrID0+IGsuc3RhcnRzV2l0aCgnJCcpKTtcbiAgICAgICAgbGV0IHZhbGlkID0gdHJ1ZTtcbiAgICAgICAgZG9sbGFyS2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgICAgICAgaWYgKFsnJHJlZicsICckaWQnLCAnJGRiJ10uaW5kZXhPZihrKSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh2YWxpZClcbiAgICAgICAgICAgIHJldHVybiBEQlJlZi5mcm9tRXh0ZW5kZWRKU09OKHYpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVBcnJheShhcnJheSwgb3B0aW9ucykge1xuICAgIHJldHVybiBhcnJheS5tYXAoKHYsIGluZGV4KSA9PiB7XG4gICAgICAgIG9wdGlvbnMuc2Vlbk9iamVjdHMucHVzaCh7IHByb3BlcnR5TmFtZTogYGluZGV4ICR7aW5kZXh9YCwgb2JqOiBudWxsIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVZhbHVlKHYsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgb3B0aW9ucy5zZWVuT2JqZWN0cy5wb3AoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0SVNPU3RyaW5nKGRhdGUpIHtcbiAgICBjb25zdCBpc29TdHIgPSBkYXRlLnRvSVNPU3RyaW5nKCk7XG4gICAgcmV0dXJuIGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgIT09IDAgPyBpc29TdHIgOiBpc29TdHIuc2xpY2UoMCwgLTUpICsgJ1onO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVmFsdWUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgaXNNYXAodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGsgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQ2FuIG9ubHkgc2VyaWFsaXplIG1hcHMgd2l0aCBzdHJpbmcga2V5cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplVmFsdWUob2JqLCBvcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKCh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBvcHRpb25zLnNlZW5PYmplY3RzLmZpbmRJbmRleChlbnRyeSA9PiBlbnRyeS5vYmogPT09IHZhbHVlKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgcHJvcHMgPSBvcHRpb25zLnNlZW5PYmplY3RzLm1hcChlbnRyeSA9PiBlbnRyeS5wcm9wZXJ0eU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbGVhZGluZ1BhcnQgPSBwcm9wc1xuICAgICAgICAgICAgICAgIC5zbGljZSgwLCBpbmRleClcbiAgICAgICAgICAgICAgICAubWFwKHByb3AgPT4gYCR7cHJvcH0gLT4gYClcbiAgICAgICAgICAgICAgICAuam9pbignJyk7XG4gICAgICAgICAgICBjb25zdCBhbHJlYWR5U2VlbiA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGNpcmN1bGFyUGFydCA9ICcgLT4gJyArXG4gICAgICAgICAgICAgICAgcHJvcHNcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKGluZGV4ICsgMSwgcHJvcHMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgLm1hcChwcm9wID0+IGAke3Byb3B9IC0+IGApXG4gICAgICAgICAgICAgICAgICAgIC5qb2luKCcnKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwcm9wc1twcm9wcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGNvbnN0IGxlYWRpbmdTcGFjZSA9ICcgJy5yZXBlYXQobGVhZGluZ1BhcnQubGVuZ3RoICsgYWxyZWFkeVNlZW4ubGVuZ3RoIC8gMik7XG4gICAgICAgICAgICBjb25zdCBkYXNoZXMgPSAnLScucmVwZWF0KGNpcmN1bGFyUGFydC5sZW5ndGggKyAoYWxyZWFkeVNlZW4ubGVuZ3RoICsgY3VycmVudC5sZW5ndGgpIC8gMiAtIDEpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJTT05FcnJvcignQ29udmVydGluZyBjaXJjdWxhciBzdHJ1Y3R1cmUgdG8gRUpTT046XFxuJyArXG4gICAgICAgICAgICAgICAgYCAgICAke2xlYWRpbmdQYXJ0fSR7YWxyZWFkeVNlZW59JHtjaXJjdWxhclBhcnR9JHtjdXJyZW50fVxcbmAgK1xuICAgICAgICAgICAgICAgIGAgICAgJHtsZWFkaW5nU3BhY2V9XFxcXCR7ZGFzaGVzfS9gKTtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzW29wdGlvbnMuc2Vlbk9iamVjdHMubGVuZ3RoIC0gMV0ub2JqID0gdmFsdWU7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZUFycmF5KHZhbHVlLCBvcHRpb25zKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSB8fCBpc0RhdGUodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGRhdGVOdW0gPSB2YWx1ZS5nZXRUaW1lKCksIGluUmFuZ2UgPSBkYXRlTnVtID4gLTEgJiYgZGF0ZU51bSA8IDI1MzQwMjMxODgwMDAwMDtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVnYWN5KSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZWxheGVkICYmIGluUmFuZ2VcbiAgICAgICAgICAgICAgICA/IHsgJGRhdGU6IHZhbHVlLmdldFRpbWUoKSB9XG4gICAgICAgICAgICAgICAgOiB7ICRkYXRlOiBnZXRJU09TdHJpbmcodmFsdWUpIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVsYXhlZCAmJiBpblJhbmdlXG4gICAgICAgICAgICA/IHsgJGRhdGU6IGdldElTT1N0cmluZyh2YWx1ZSkgfVxuICAgICAgICAgICAgOiB7ICRkYXRlOiB7ICRudW1iZXJMb25nOiB2YWx1ZS5nZXRUaW1lKCkudG9TdHJpbmcoKSB9IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICghb3B0aW9ucy5yZWxheGVkIHx8ICFpc0Zpbml0ZSh2YWx1ZSkpKSB7XG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiAhT2JqZWN0LmlzKHZhbHVlLCAtMCkpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBCU09OX0lOVDMyX01JTiAmJiB2YWx1ZSA8PSBCU09OX0lOVDMyX01BWCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7ICRudW1iZXJJbnQ6IHZhbHVlLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA+PSBCU09OX0lOVDY0X01JTiAmJiB2YWx1ZSA8PSBCU09OX0lOVDY0X01BWCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7ICRudW1iZXJMb25nOiB2YWx1ZS50b1N0cmluZygpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgJG51bWJlckRvdWJsZTogT2JqZWN0LmlzKHZhbHVlLCAtMCkgPyAnLTAuMCcgOiB2YWx1ZS50b1N0cmluZygpIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnKSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5yZWxheGVkKSB7XG4gICAgICAgICAgICByZXR1cm4geyAkbnVtYmVyTG9uZzogQmlnSW50LmFzSW50Tig2NCwgdmFsdWUpLnRvU3RyaW5nKCkgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyKEJpZ0ludC5hc0ludE4oNjQsIHZhbHVlKSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCB8fCBpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgICAgbGV0IGZsYWdzID0gdmFsdWUuZmxhZ3M7XG4gICAgICAgIGlmIChmbGFncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnRvU3RyaW5nKCkubWF0Y2goL1tnaW11eV0qJC8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgPSBtYXRjaFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCByeCA9IG5ldyBCU09OUmVnRXhwKHZhbHVlLnNvdXJjZSwgZmxhZ3MpO1xuICAgICAgICByZXR1cm4gcngudG9FeHRlbmRlZEpTT04ob3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpXG4gICAgICAgIHJldHVybiBzZXJpYWxpemVEb2N1bWVudCh2YWx1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuY29uc3QgQlNPTl9UWVBFX01BUFBJTkdTID0ge1xuICAgIEJpbmFyeTogKG8pID0+IG5ldyBCaW5hcnkoby52YWx1ZSgpLCBvLnN1Yl90eXBlKSxcbiAgICBDb2RlOiAobykgPT4gbmV3IENvZGUoby5jb2RlLCBvLnNjb3BlKSxcbiAgICBEQlJlZjogKG8pID0+IG5ldyBEQlJlZihvLmNvbGxlY3Rpb24gfHwgby5uYW1lc3BhY2UsIG8ub2lkLCBvLmRiLCBvLmZpZWxkcyksXG4gICAgRGVjaW1hbDEyODogKG8pID0+IG5ldyBEZWNpbWFsMTI4KG8uYnl0ZXMpLFxuICAgIERvdWJsZTogKG8pID0+IG5ldyBEb3VibGUoby52YWx1ZSksXG4gICAgSW50MzI6IChvKSA9PiBuZXcgSW50MzIoby52YWx1ZSksXG4gICAgTG9uZzogKG8pID0+IExvbmcuZnJvbUJpdHMoby5sb3cgIT0gbnVsbCA/IG8ubG93IDogby5sb3dfLCBvLmxvdyAhPSBudWxsID8gby5oaWdoIDogby5oaWdoXywgby5sb3cgIT0gbnVsbCA/IG8udW5zaWduZWQgOiBvLnVuc2lnbmVkXyksXG4gICAgTWF4S2V5OiAoKSA9PiBuZXcgTWF4S2V5KCksXG4gICAgTWluS2V5OiAoKSA9PiBuZXcgTWluS2V5KCksXG4gICAgT2JqZWN0SWQ6IChvKSA9PiBuZXcgT2JqZWN0SWQobyksXG4gICAgQlNPTlJlZ0V4cDogKG8pID0+IG5ldyBCU09OUmVnRXhwKG8ucGF0dGVybiwgby5vcHRpb25zKSxcbiAgICBCU09OU3ltYm9sOiAobykgPT4gbmV3IEJTT05TeW1ib2woby52YWx1ZSksXG4gICAgVGltZXN0YW1wOiAobykgPT4gVGltZXN0YW1wLmZyb21CaXRzKG8ubG93LCBvLmhpZ2gpXG59O1xuZnVuY3Rpb24gc2VyaWFsaXplRG9jdW1lbnQoZG9jLCBvcHRpb25zKSB7XG4gICAgaWYgKGRvYyA9PSBudWxsIHx8IHR5cGVvZiBkb2MgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdub3QgYW4gb2JqZWN0IGluc3RhbmNlJyk7XG4gICAgY29uc3QgYnNvbnR5cGUgPSBkb2MuX2Jzb250eXBlO1xuICAgIGlmICh0eXBlb2YgYnNvbnR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnN0IF9kb2MgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIE9iamVjdC5rZXlzKGRvYykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuc2Vlbk9iamVjdHMucHVzaCh7IHByb3BlcnR5TmFtZTogbmFtZSwgb2JqOiBudWxsIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHNlcmlhbGl6ZVZhbHVlKGRvY1tuYW1lXSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT09ICdfX3Byb3RvX18nKSB7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfZG9jLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9kb2NbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnNlZW5PYmplY3RzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfZG9jO1xuICAgIH1cbiAgICBlbHNlIGlmIChkb2MgIT0gbnVsbCAmJlxuICAgICAgICB0eXBlb2YgZG9jID09PSAnb2JqZWN0JyAmJlxuICAgICAgICB0eXBlb2YgZG9jLl9ic29udHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgZG9jW1N5bWJvbC5mb3IoJ0BAbWRiLmJzb24udmVyc2lvbicpXSAhPT0gQlNPTl9NQUpPUl9WRVJTSU9OKSB7XG4gICAgICAgIHRocm93IG5ldyBCU09OVmVyc2lvbkVycm9yKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQlNPTlR5cGUoZG9jKSkge1xuICAgICAgICBsZXQgb3V0RG9jID0gZG9jO1xuICAgICAgICBpZiAodHlwZW9mIG91dERvYy50b0V4dGVuZGVkSlNPTiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3QgbWFwcGVyID0gQlNPTl9UWVBFX01BUFBJTkdTW2RvYy5fYnNvbnR5cGVdO1xuICAgICAgICAgICAgaWYgKCFtYXBwZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQlNPTkVycm9yKCdVbnJlY29nbml6ZWQgb3IgaW52YWxpZCBfYnNvbnR5cGU6ICcgKyBkb2MuX2Jzb250eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dERvYyA9IG1hcHBlcihvdXREb2MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChic29udHlwZSA9PT0gJ0NvZGUnICYmIG91dERvYy5zY29wZSkge1xuICAgICAgICAgICAgb3V0RG9jID0gbmV3IENvZGUob3V0RG9jLmNvZGUsIHNlcmlhbGl6ZVZhbHVlKG91dERvYy5zY29wZSwgb3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJzb250eXBlID09PSAnREJSZWYnICYmIG91dERvYy5vaWQpIHtcbiAgICAgICAgICAgIG91dERvYyA9IG5ldyBEQlJlZihzZXJpYWxpemVWYWx1ZShvdXREb2MuY29sbGVjdGlvbiwgb3B0aW9ucyksIHNlcmlhbGl6ZVZhbHVlKG91dERvYy5vaWQsIG9wdGlvbnMpLCBzZXJpYWxpemVWYWx1ZShvdXREb2MuZGIsIG9wdGlvbnMpLCBzZXJpYWxpemVWYWx1ZShvdXREb2MuZmllbGRzLCBvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dERvYy50b0V4dGVuZGVkSlNPTihvcHRpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoJ19ic29udHlwZSBtdXN0IGJlIGEgc3RyaW5nLCBidXQgd2FzOiAnICsgdHlwZW9mIGJzb250eXBlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZSh0ZXh0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZWpzb25PcHRpb25zID0ge1xuICAgICAgICB1c2VCaWdJbnQ2NDogb3B0aW9ucz8udXNlQmlnSW50NjQgPz8gZmFsc2UsXG4gICAgICAgIHJlbGF4ZWQ6IG9wdGlvbnM/LnJlbGF4ZWQgPz8gdHJ1ZSxcbiAgICAgICAgbGVnYWN5OiBvcHRpb25zPy5sZWdhY3kgPz8gZmFsc2VcbiAgICB9O1xuICAgIHJldHVybiBKU09OLnBhcnNlKHRleHQsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChrZXkuaW5kZXhPZignXFx4MDAnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCU09ORXJyb3IoYEJTT04gRG9jdW1lbnQgZmllbGQgbmFtZXMgY2Fubm90IGNvbnRhaW4gbnVsbCBieXRlcywgZm91bmQ6ICR7SlNPTi5zdHJpbmdpZnkoa2V5KX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgZWpzb25PcHRpb25zKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlLCBvcHRpb25zKSB7XG4gICAgaWYgKHNwYWNlICE9IG51bGwgJiYgdHlwZW9mIHNwYWNlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zID0gc3BhY2U7XG4gICAgICAgIHNwYWNlID0gMDtcbiAgICB9XG4gICAgaWYgKHJlcGxhY2VyICE9IG51bGwgJiYgdHlwZW9mIHJlcGxhY2VyID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShyZXBsYWNlcikpIHtcbiAgICAgICAgb3B0aW9ucyA9IHJlcGxhY2VyO1xuICAgICAgICByZXBsYWNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgc3BhY2UgPSAwO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHJlbGF4ZWQ6IHRydWUsIGxlZ2FjeTogZmFsc2UgfSwgb3B0aW9ucywge1xuICAgICAgICBzZWVuT2JqZWN0czogW3sgcHJvcGVydHlOYW1lOiAnKHJvb3QpJywgb2JqOiBudWxsIH1dXG4gICAgfSk7XG4gICAgY29uc3QgZG9jID0gc2VyaWFsaXplVmFsdWUodmFsdWUsIHNlcmlhbGl6ZU9wdGlvbnMpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkb2MsIHJlcGxhY2VyLCBzcGFjZSk7XG59XG5mdW5jdGlvbiBFSlNPTnNlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZ2lmeSh2YWx1ZSwgb3B0aW9ucykpO1xufVxuZnVuY3Rpb24gRUpTT05kZXNlcmlhbGl6ZShlanNvbiwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHJldHVybiBwYXJzZShKU09OLnN0cmluZ2lmeShlanNvbiksIG9wdGlvbnMpO1xufVxuY29uc3QgRUpTT04gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuRUpTT04ucGFyc2UgPSBwYXJzZTtcbkVKU09OLnN0cmluZ2lmeSA9IHN0cmluZ2lmeTtcbkVKU09OLnNlcmlhbGl6ZSA9IEVKU09Oc2VyaWFsaXplO1xuRUpTT04uZGVzZXJpYWxpemUgPSBFSlNPTmRlc2VyaWFsaXplO1xuT2JqZWN0LmZyZWV6ZShFSlNPTik7XG5cbmNvbnN0IE1BWFNJWkUgPSAxMDI0ICogMTAyNCAqIDE3O1xubGV0IGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShNQVhTSVpFKTtcbmZ1bmN0aW9uIHNldEludGVybmFsQnVmZmVyU2l6ZShzaXplKSB7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBzaXplKSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ5dGVVdGlscy5hbGxvY2F0ZShzaXplKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJpYWxpemUob2JqZWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBjaGVja0tleXMgPSB0eXBlb2Ygb3B0aW9ucy5jaGVja0tleXMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuY2hlY2tLZXlzIDogZmFsc2U7XG4gICAgY29uc3Qgc2VyaWFsaXplRnVuY3Rpb25zID0gdHlwZW9mIG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA6IGZhbHNlO1xuICAgIGNvbnN0IGlnbm9yZVVuZGVmaW5lZCA9IHR5cGVvZiBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgOiB0cnVlO1xuICAgIGNvbnN0IG1pbkludGVybmFsQnVmZmVyU2l6ZSA9IHR5cGVvZiBvcHRpb25zLm1pbkludGVybmFsQnVmZmVyU2l6ZSA9PT0gJ251bWJlcicgPyBvcHRpb25zLm1pbkludGVybmFsQnVmZmVyU2l6ZSA6IE1BWFNJWkU7XG4gICAgaWYgKGJ1ZmZlci5sZW5ndGggPCBtaW5JbnRlcm5hbEJ1ZmZlclNpemUpIHtcbiAgICAgICAgYnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKG1pbkludGVybmFsQnVmZmVyU2l6ZSk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6YXRpb25JbmRleCA9IHNlcmlhbGl6ZUludG8oYnVmZmVyLCBvYmplY3QsIGNoZWNrS2V5cywgMCwgMCwgc2VyaWFsaXplRnVuY3Rpb25zLCBpZ25vcmVVbmRlZmluZWQsIG51bGwpO1xuICAgIGNvbnN0IGZpbmlzaGVkQnVmZmVyID0gQnl0ZVV0aWxzLmFsbG9jYXRlKHNlcmlhbGl6YXRpb25JbmRleCk7XG4gICAgZmluaXNoZWRCdWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBzZXJpYWxpemF0aW9uSW5kZXgpLCAwKTtcbiAgICByZXR1cm4gZmluaXNoZWRCdWZmZXI7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXgob2JqZWN0LCBmaW5hbEJ1ZmZlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tLZXlzID0gdHlwZW9mIG9wdGlvbnMuY2hlY2tLZXlzID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmNoZWNrS2V5cyA6IGZhbHNlO1xuICAgIGNvbnN0IHNlcmlhbGl6ZUZ1bmN0aW9ucyA9IHR5cGVvZiBvcHRpb25zLnNlcmlhbGl6ZUZ1bmN0aW9ucyA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgOiBmYWxzZTtcbiAgICBjb25zdCBpZ25vcmVVbmRlZmluZWQgPSB0eXBlb2Ygb3B0aW9ucy5pZ25vcmVVbmRlZmluZWQgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkIDogdHJ1ZTtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gdHlwZW9mIG9wdGlvbnMuaW5kZXggPT09ICdudW1iZXInID8gb3B0aW9ucy5pbmRleCA6IDA7XG4gICAgY29uc3Qgc2VyaWFsaXphdGlvbkluZGV4ID0gc2VyaWFsaXplSW50byhidWZmZXIsIG9iamVjdCwgY2hlY2tLZXlzLCAwLCAwLCBzZXJpYWxpemVGdW5jdGlvbnMsIGlnbm9yZVVuZGVmaW5lZCwgbnVsbCk7XG4gICAgZmluYWxCdWZmZXIuc2V0KGJ1ZmZlci5zdWJhcnJheSgwLCBzZXJpYWxpemF0aW9uSW5kZXgpLCBzdGFydEluZGV4KTtcbiAgICByZXR1cm4gc3RhcnRJbmRleCArIHNlcmlhbGl6YXRpb25JbmRleCAtIDE7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShidWZmZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBpbnRlcm5hbERlc2VyaWFsaXplKEJ5dGVVdGlscy50b0xvY2FsQnVmZmVyVHlwZShidWZmZXIpLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZU9iamVjdFNpemUob2JqZWN0LCBvcHRpb25zID0ge30pIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzZXJpYWxpemVGdW5jdGlvbnMgPSB0eXBlb2Ygb3B0aW9ucy5zZXJpYWxpemVGdW5jdGlvbnMgPT09ICdib29sZWFuJyA/IG9wdGlvbnMuc2VyaWFsaXplRnVuY3Rpb25zIDogZmFsc2U7XG4gICAgY29uc3QgaWdub3JlVW5kZWZpbmVkID0gdHlwZW9mIG9wdGlvbnMuaWdub3JlVW5kZWZpbmVkID09PSAnYm9vbGVhbicgPyBvcHRpb25zLmlnbm9yZVVuZGVmaW5lZCA6IHRydWU7XG4gICAgcmV0dXJuIGludGVybmFsQ2FsY3VsYXRlT2JqZWN0U2l6ZShvYmplY3QsIHNlcmlhbGl6ZUZ1bmN0aW9ucywgaWdub3JlVW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU3RyZWFtKGRhdGEsIHN0YXJ0SW5kZXgsIG51bWJlck9mRG9jdW1lbnRzLCBkb2N1bWVudHMsIGRvY1N0YXJ0SW5kZXgsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbnRlcm5hbE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgYWxsb3dPYmplY3RTbWFsbGVyVGhhbkJ1ZmZlclNpemU6IHRydWUsIGluZGV4OiAwIH0sIG9wdGlvbnMpO1xuICAgIGNvbnN0IGJ1ZmZlckRhdGEgPSBCeXRlVXRpbHMudG9Mb2NhbEJ1ZmZlclR5cGUoZGF0YSk7XG4gICAgbGV0IGluZGV4ID0gc3RhcnRJbmRleDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRG9jdW1lbnRzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGJ1ZmZlckRhdGFbaW5kZXhdIHxcbiAgICAgICAgICAgIChidWZmZXJEYXRhW2luZGV4ICsgMV0gPDwgOCkgfFxuICAgICAgICAgICAgKGJ1ZmZlckRhdGFbaW5kZXggKyAyXSA8PCAxNikgfFxuICAgICAgICAgICAgKGJ1ZmZlckRhdGFbaW5kZXggKyAzXSA8PCAyNCk7XG4gICAgICAgIGludGVybmFsT3B0aW9ucy5pbmRleCA9IGluZGV4O1xuICAgICAgICBkb2N1bWVudHNbZG9jU3RhcnRJbmRleCArIGldID0gaW50ZXJuYWxEZXNlcmlhbGl6ZShidWZmZXJEYXRhLCBpbnRlcm5hbE9wdGlvbnMpO1xuICAgICAgICBpbmRleCA9IGluZGV4ICsgc2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuXG52YXIgYnNvbiA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgQlNPTkVycm9yOiBCU09ORXJyb3IsXG4gICAgQlNPTlJlZ0V4cDogQlNPTlJlZ0V4cCxcbiAgICBCU09OUnVudGltZUVycm9yOiBCU09OUnVudGltZUVycm9yLFxuICAgIEJTT05TeW1ib2w6IEJTT05TeW1ib2wsXG4gICAgQlNPTlR5cGU6IEJTT05UeXBlLFxuICAgIEJTT05WYWx1ZTogQlNPTlZhbHVlLFxuICAgIEJTT05WZXJzaW9uRXJyb3I6IEJTT05WZXJzaW9uRXJyb3IsXG4gICAgQmluYXJ5OiBCaW5hcnksXG4gICAgQ29kZTogQ29kZSxcbiAgICBEQlJlZjogREJSZWYsXG4gICAgRGVjaW1hbDEyODogRGVjaW1hbDEyOCxcbiAgICBEb3VibGU6IERvdWJsZSxcbiAgICBFSlNPTjogRUpTT04sXG4gICAgSW50MzI6IEludDMyLFxuICAgIExvbmc6IExvbmcsXG4gICAgTWF4S2V5OiBNYXhLZXksXG4gICAgTWluS2V5OiBNaW5LZXksXG4gICAgT2JqZWN0SWQ6IE9iamVjdElkLFxuICAgIFRpbWVzdGFtcDogVGltZXN0YW1wLFxuICAgIFVVSUQ6IFVVSUQsXG4gICAgY2FsY3VsYXRlT2JqZWN0U2l6ZTogY2FsY3VsYXRlT2JqZWN0U2l6ZSxcbiAgICBkZXNlcmlhbGl6ZTogZGVzZXJpYWxpemUsXG4gICAgZGVzZXJpYWxpemVTdHJlYW06IGRlc2VyaWFsaXplU3RyZWFtLFxuICAgIHNlcmlhbGl6ZTogc2VyaWFsaXplLFxuICAgIHNlcmlhbGl6ZVdpdGhCdWZmZXJBbmRJbmRleDogc2VyaWFsaXplV2l0aEJ1ZmZlckFuZEluZGV4LFxuICAgIHNldEludGVybmFsQnVmZmVyU2l6ZTogc2V0SW50ZXJuYWxCdWZmZXJTaXplXG59KTtcblxuZXhwb3J0cy5CU09OID0gYnNvbjtcbmV4cG9ydHMuQlNPTkVycm9yID0gQlNPTkVycm9yO1xuZXhwb3J0cy5CU09OUmVnRXhwID0gQlNPTlJlZ0V4cDtcbmV4cG9ydHMuQlNPTlJ1bnRpbWVFcnJvciA9IEJTT05SdW50aW1lRXJyb3I7XG5leHBvcnRzLkJTT05TeW1ib2wgPSBCU09OU3ltYm9sO1xuZXhwb3J0cy5CU09OVHlwZSA9IEJTT05UeXBlO1xuZXhwb3J0cy5CU09OVmFsdWUgPSBCU09OVmFsdWU7XG5leHBvcnRzLkJTT05WZXJzaW9uRXJyb3IgPSBCU09OVmVyc2lvbkVycm9yO1xuZXhwb3J0cy5CaW5hcnkgPSBCaW5hcnk7XG5leHBvcnRzLkNvZGUgPSBDb2RlO1xuZXhwb3J0cy5EQlJlZiA9IERCUmVmO1xuZXhwb3J0cy5EZWNpbWFsMTI4ID0gRGVjaW1hbDEyODtcbmV4cG9ydHMuRG91YmxlID0gRG91YmxlO1xuZXhwb3J0cy5FSlNPTiA9IEVKU09OO1xuZXhwb3J0cy5JbnQzMiA9IEludDMyO1xuZXhwb3J0cy5Mb25nID0gTG9uZztcbmV4cG9ydHMuTWF4S2V5ID0gTWF4S2V5O1xuZXhwb3J0cy5NaW5LZXkgPSBNaW5LZXk7XG5leHBvcnRzLk9iamVjdElkID0gT2JqZWN0SWQ7XG5leHBvcnRzLlRpbWVzdGFtcCA9IFRpbWVzdGFtcDtcbmV4cG9ydHMuVVVJRCA9IFVVSUQ7XG5leHBvcnRzLmNhbGN1bGF0ZU9iamVjdFNpemUgPSBjYWxjdWxhdGVPYmplY3RTaXplO1xuZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuZXhwb3J0cy5kZXNlcmlhbGl6ZVN0cmVhbSA9IGRlc2VyaWFsaXplU3RyZWFtO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5leHBvcnRzLnNlcmlhbGl6ZVdpdGhCdWZmZXJBbmRJbmRleCA9IHNlcmlhbGl6ZVdpdGhCdWZmZXJBbmRJbmRleDtcbmV4cG9ydHMuc2V0SW50ZXJuYWxCdWZmZXJTaXplID0gc2V0SW50ZXJuYWxCdWZmZXJTaXplO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnNvbi5janMubWFwXG4iXSwibmFtZXMiOlsiaXNBbnlBcnJheUJ1ZmZlciIsInZhbHVlIiwiaW5jbHVkZXMiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJpc1VpbnQ4QXJyYXkiLCJpc1JlZ0V4cCIsImQiLCJpc01hcCIsImlzRGF0ZSIsImRlZmF1bHRJbnNwZWN0IiwieCIsIl9vcHRpb25zIiwiSlNPTiIsInN0cmluZ2lmeSIsImsiLCJ2IiwiJG51bWJlckxvbmciLCJmcm9tRW50cmllcyIsImdldFN0eWxpemVGdW5jdGlvbiIsIm9wdGlvbnMiLCJzdHlsaXplRXhpc3RzIiwic3R5bGl6ZSIsIkJTT05fTUFKT1JfVkVSU0lPTiIsIkJTT05fSU5UMzJfTUFYIiwiQlNPTl9JTlQzMl9NSU4iLCJCU09OX0lOVDY0X01BWCIsIk1hdGgiLCJwb3ciLCJCU09OX0lOVDY0X01JTiIsIkpTX0lOVF9NQVgiLCJKU19JTlRfTUlOIiwiQlNPTl9EQVRBX05VTUJFUiIsIkJTT05fREFUQV9TVFJJTkciLCJCU09OX0RBVEFfT0JKRUNUIiwiQlNPTl9EQVRBX0FSUkFZIiwiQlNPTl9EQVRBX0JJTkFSWSIsIkJTT05fREFUQV9VTkRFRklORUQiLCJCU09OX0RBVEFfT0lEIiwiQlNPTl9EQVRBX0JPT0xFQU4iLCJCU09OX0RBVEFfREFURSIsIkJTT05fREFUQV9OVUxMIiwiQlNPTl9EQVRBX1JFR0VYUCIsIkJTT05fREFUQV9EQlBPSU5URVIiLCJCU09OX0RBVEFfQ09ERSIsIkJTT05fREFUQV9TWU1CT0wiLCJCU09OX0RBVEFfQ09ERV9XX1NDT1BFIiwiQlNPTl9EQVRBX0lOVCIsIkJTT05fREFUQV9USU1FU1RBTVAiLCJCU09OX0RBVEFfTE9ORyIsIkJTT05fREFUQV9ERUNJTUFMMTI4IiwiQlNPTl9EQVRBX01JTl9LRVkiLCJCU09OX0RBVEFfTUFYX0tFWSIsIkJTT05fQklOQVJZX1NVQlRZUEVfREVGQVVMVCIsIkJTT05fQklOQVJZX1NVQlRZUEVfVVVJRF9ORVciLCJCU09OVHlwZSIsImZyZWV6ZSIsImRvdWJsZSIsInN0cmluZyIsIm9iamVjdCIsImFycmF5IiwiYmluRGF0YSIsInVuZGVmaW5lZCIsIm9iamVjdElkIiwiYm9vbCIsImRhdGUiLCJudWxsIiwicmVnZXgiLCJkYlBvaW50ZXIiLCJqYXZhc2NyaXB0Iiwic3ltYm9sIiwiamF2YXNjcmlwdFdpdGhTY29wZSIsImludCIsInRpbWVzdGFtcCIsImxvbmciLCJkZWNpbWFsIiwibWluS2V5IiwibWF4S2V5IiwiQlNPTkVycm9yIiwiRXJyb3IiLCJic29uRXJyb3IiLCJuYW1lIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwiaXNCU09ORXJyb3IiLCJCU09OVmVyc2lvbkVycm9yIiwiQlNPTlJ1bnRpbWVFcnJvciIsIkZJUlNUX0JJVCIsIkZJUlNUX1RXT19CSVRTIiwiRklSU1RfVEhSRUVfQklUUyIsIkZJUlNUX0ZPVVJfQklUUyIsIkZJUlNUX0ZJVkVfQklUUyIsIlRXT19CSVRfQ0hBUiIsIlRIUkVFX0JJVF9DSEFSIiwiRk9VUl9CSVRfQ0hBUiIsIkNPTlRJTlVJTkdfQ0hBUiIsInZhbGlkYXRlVXRmOCIsImJ5dGVzIiwic3RhcnQiLCJlbmQiLCJjb250aW51YXRpb24iLCJpIiwiYnl0ZSIsInRyeUxhdGluIiwidWludDhhcnJheSIsImxlbmd0aCIsInN0cmluZ0J5dGVMZW5ndGgiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJsYXRpbkJ5dGVzIiwicHVzaCIsIm5vZGVqc01hdGhSYW5kb21CeXRlcyIsImJ5dGVMZW5ndGgiLCJub2RlSnNCeXRlVXRpbHMiLCJmcm9tTnVtYmVyQXJyYXkiLCJBcnJheSIsImZyb20iLCJmbG9vciIsInJhbmRvbSIsIm5vZGVqc1JhbmRvbUJ5dGVzIiwicmVxdWlyZSIsInJhbmRvbUJ5dGVzIiwidG9Mb2NhbEJ1ZmZlclR5cGUiLCJwb3RlbnRpYWxCdWZmZXIiLCJCdWZmZXIiLCJpc0J1ZmZlciIsIkFycmF5QnVmZmVyIiwiaXNWaWV3IiwiYnVmZmVyIiwiYnl0ZU9mZnNldCIsInN0cmluZ1RhZyIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiYWxsb2NhdGUiLCJzaXplIiwiYWxsb2MiLCJlcXVhbHMiLCJhIiwiYiIsImZyb21CYXNlNjQiLCJiYXNlNjQiLCJ0b0Jhc2U2NCIsImZyb21JU084ODU5MSIsImNvZGVQb2ludHMiLCJ0b0lTTzg4NTkxIiwiZnJvbUhleCIsImhleCIsInRvSGV4IiwiZnJvbVVURjgiLCJ0ZXh0IiwidG9VVEY4IiwiZmF0YWwiLCJiYXNpY0xhdGluIiwiY2hhckNvZGVBdCIsInV0ZjhCeXRlTGVuZ3RoIiwiaW5wdXQiLCJlbmNvZGVVVEY4SW50byIsInNvdXJjZSIsIndyaXRlIiwiaXNSZWFjdE5hdGl2ZSIsIm5hdmlnYXRvciIsImdsb2JhbFRoaXMiLCJwcm9kdWN0Iiwid2ViTWF0aFJhbmRvbUJ5dGVzIiwiUmFuZ2VFcnJvciIsIndlYkJ5dGVVdGlscyIsIndlYlJhbmRvbUJ5dGVzIiwiY3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiY29uc29sZSIsIndhcm4iLCJIRVhfRElHSVQiLCJwb3RlbnRpYWxVaW50OGFycmF5IiwiVWludDhBcnJheSIsInNsaWNlIiwiVHlwZUVycm9yIiwiYXRvYiIsImMiLCJidG9hIiwiVWludDE2QXJyYXkiLCJqb2luIiwiZXZlbkxlbmd0aEhleCIsImZpcnN0RGlnaXQiLCJzZWNvbmREaWdpdCIsInRlc3QiLCJoZXhEaWdpdCIsIk51bWJlciIsInBhcnNlSW50IiwicGFkU3RhcnQiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiY2F1c2UiLCJzZXQiLCJoYXNHbG9iYWxCdWZmZXIiLCJfaXNCdWZmZXIiLCJCeXRlVXRpbHMiLCJCU09ORGF0YVZpZXciLCJEYXRhVmlldyIsImZyb21VaW50OEFycmF5IiwiQlNPTlZhbHVlIiwiZm9yIiwiZGVwdGgiLCJpbnNwZWN0IiwiQmluYXJ5IiwiX2Jzb250eXBlIiwic3ViVHlwZSIsImlzQXJyYXkiLCJzdWJfdHlwZSIsIkJVRkZFUl9TSVpFIiwicG9zaXRpb24iLCJwdXQiLCJieXRlVmFsdWUiLCJkZWNvZGVkQnl0ZSIsIm5ld1NwYWNlIiwic2VxdWVuY2UiLCJvZmZzZXQiLCJyZWFkIiwic3ViYXJyYXkiLCJ0b0pTT04iLCJlbmNvZGluZyIsInRvRXh0ZW5kZWRKU09OIiwiYmFzZTY0U3RyaW5nIiwibGVnYWN5IiwiJGJpbmFyeSIsIiR0eXBlIiwidG9VVUlEIiwiU1VCVFlQRV9VVUlEIiwiVVVJRCIsImNyZWF0ZUZyb21IZXhTdHJpbmciLCJjcmVhdGVGcm9tQmFzZTY0IiwiZnJvbUV4dGVuZGVkSlNPTiIsImRvYyIsImRhdGEiLCJ0eXBlIiwiYnl0ZXNGcm9tU3RyaW5nIiwiJHV1aWQiLCJiYXNlNjRBcmciLCJzdWJUeXBlQXJnIiwiU1VCVFlQRV9ERUZBVUxUIiwiU1VCVFlQRV9GVU5DVElPTiIsIlNVQlRZUEVfQllURV9BUlJBWSIsIlNVQlRZUEVfVVVJRF9PTEQiLCJTVUJUWVBFX01ENSIsIlNVQlRZUEVfRU5DUllQVEVEIiwiU1VCVFlQRV9DT0xVTU4iLCJTVUJUWVBFX1VTRVJfREVGSU5FRCIsIlVVSURfQllURV9MRU5HVEgiLCJVVUlEX1dJVEhPVVRfREFTSEVTIiwiVVVJRF9XSVRIX0RBU0hFUyIsImdlbmVyYXRlIiwiaWQiLCJ0b0hleFN0cmluZyIsImluY2x1ZGVEYXNoZXMiLCJvdGhlcklkIiwidG9CaW5hcnkiLCJpc1ZhbGlkIiwiaXNWYWxpZFVVSURTdHJpbmciLCJoZXhTdHJpbmciLCJyZXByZXNlbnRhdGlvbiIsInJlcGxhY2UiLCJDb2RlIiwiY29kZSIsInNjb3BlIiwiJGNvZGUiLCIkc2NvcGUiLCJwYXJhbWV0ZXJzU3RyaW5nIiwibXVsdGlMaW5lRm4iLCJlbmRpbmdOZXdsaW5lIiwiaXNEQlJlZkxpa2UiLCIkaWQiLCIkcmVmIiwiJGRiIiwiREJSZWYiLCJjb2xsZWN0aW9uIiwib2lkIiwiZGIiLCJmaWVsZHMiLCJwYXJ0cyIsInNwbGl0Iiwic2hpZnQiLCJuYW1lc3BhY2UiLCJvIiwiYXNzaWduIiwiY29weSIsImFyZ3MiLCJrZXlzIiwid2FzbSIsIldlYkFzc2VtYmx5IiwiSW5zdGFuY2UiLCJNb2R1bGUiLCJleHBvcnRzIiwiVFdPX1BXUl8xNl9EQkwiLCJUV09fUFdSXzI0X0RCTCIsIlRXT19QV1JfMzJfREJMIiwiVFdPX1BXUl82NF9EQkwiLCJUV09fUFdSXzYzX0RCTCIsIklOVF9DQUNIRSIsIlVJTlRfQ0FDSEUiLCJNQVhfSU5UNjRfU1RSSU5HX0xFTkdUSCIsIkRFQ0lNQUxfUkVHX0VYIiwiTG9uZyIsIl9faXNMb25nX18iLCJsb3ciLCJoaWdoIiwidW5zaWduZWQiLCJmcm9tQmlnSW50IiwiZnJvbVN0cmluZyIsImZyb21CaXRzIiwibG93Qml0cyIsImhpZ2hCaXRzIiwiZnJvbUludCIsIm9iaiIsImNhY2hlZE9iaiIsImNhY2hlIiwiZnJvbU51bWJlciIsImlzTmFOIiwiVVpFUk8iLCJaRVJPIiwiTUFYX1VOU0lHTkVEX1ZBTFVFIiwiTUlOX1ZBTFVFIiwiTUFYX1ZBTFVFIiwibmVnIiwic3RyIiwicmFkaXgiLCJwIiwiaW5kZXhPZiIsInN1YnN0cmluZyIsInJhZGl4VG9Qb3dlciIsInJlc3VsdCIsIm1pbiIsInBvd2VyIiwibXVsIiwiYWRkIiwiZnJvbUJ5dGVzIiwibGUiLCJmcm9tQnl0ZXNMRSIsImZyb21CeXRlc0JFIiwiaXNMb25nIiwiZnJvbVZhbHVlIiwidmFsIiwiYWRkZW5kIiwiYTQ4IiwiYTMyIiwiYTE2IiwiYTAwIiwiYjQ4IiwiYjMyIiwiYjE2IiwiYjAwIiwiYzQ4IiwiYzMyIiwiYzE2IiwiYzAwIiwiYW5kIiwib3RoZXIiLCJjb21wYXJlIiwiZXEiLCJ0aGlzTmVnIiwiaXNOZWdhdGl2ZSIsIm90aGVyTmVnIiwic3ViIiwiY29tcCIsImRpdmlkZSIsImRpdmlzb3IiLCJpc1plcm8iLCJkaXZfdSIsImRpdl9zIiwiZ2V0X2hpZ2giLCJhcHByb3giLCJyZW0iLCJyZXMiLCJPTkUiLCJORUdfT05FIiwiaGFsZlRoaXMiLCJzaHIiLCJkaXYiLCJzaGwiLCJ0b1Vuc2lnbmVkIiwiZ3QiLCJzaHJ1IiwiVU9ORSIsImd0ZSIsIm1heCIsInRvTnVtYmVyIiwibG9nMiIsImNlaWwiLCJsb2ciLCJMTjIiLCJkZWx0YSIsImFwcHJveFJlcyIsImFwcHJveFJlbSIsImdldEhpZ2hCaXRzIiwiZ2V0SGlnaEJpdHNVbnNpZ25lZCIsImdldExvd0JpdHMiLCJnZXRMb3dCaXRzVW5zaWduZWQiLCJnZXROdW1CaXRzQWJzIiwiYml0IiwiZ3JlYXRlclRoYW4iLCJncmVhdGVyVGhhbk9yRXF1YWwiLCJnZSIsImlzRXZlbiIsImlzT2RkIiwiaXNQb3NpdGl2ZSIsImxlc3NUaGFuIiwibHQiLCJsZXNzVGhhbk9yRXF1YWwiLCJsdGUiLCJtb2R1bG8iLCJyZW1fdSIsInJlbV9zIiwibW9kIiwibXVsdGlwbHkiLCJtdWx0aXBsaWVyIiwiVFdPX1BXUl8yNCIsIm5lZ2F0ZSIsIm5vdCIsIm5vdEVxdWFscyIsIm5lcSIsIm5lIiwib3IiLCJzaGlmdExlZnQiLCJudW1CaXRzIiwidG9JbnQiLCJzaGlmdFJpZ2h0Iiwic2hpZnRSaWdodFVuc2lnbmVkIiwic2hyX3UiLCJzdWJ0cmFjdCIsInN1YnRyYWhlbmQiLCJ0b0JpZ0ludCIsIkJpZ0ludCIsInRvQnl0ZXMiLCJ0b0J5dGVzTEUiLCJ0b0J5dGVzQkUiLCJoaSIsImxvIiwidG9TaWduZWQiLCJyYWRpeExvbmciLCJyZW0xIiwicmVtRGl2IiwiaW50dmFsIiwiZGlnaXRzIiwieG9yIiwiZXF6IiwicmVsYXhlZCIsInVzZUJpZ0ludDY0IiwiYmlnSW50UmVzdWx0IiwiYXNJbnROIiwibG9uZ1Jlc3VsdCIsImxvbmdWYWwiLCJ1bnNpZ25lZFZhbCIsIlBBUlNFX1NUUklOR19SRUdFWFAiLCJQQVJTRV9JTkZfUkVHRVhQIiwiUEFSU0VfTkFOX1JFR0VYUCIsIkVYUE9ORU5UX01BWCIsIkVYUE9ORU5UX01JTiIsIkVYUE9ORU5UX0JJQVMiLCJNQVhfRElHSVRTIiwiTkFOX0JVRkZFUiIsInJldmVyc2UiLCJJTkZfTkVHQVRJVkVfQlVGRkVSIiwiSU5GX1BPU0lUSVZFX0JVRkZFUiIsIkVYUE9ORU5UX1JFR0VYIiwiQ09NQklOQVRJT05fTUFTSyIsIkVYUE9ORU5UX01BU0siLCJDT01CSU5BVElPTl9JTkZJTklUWSIsIkNPTUJJTkFUSU9OX05BTiIsImlzRGlnaXQiLCJkaXZpZGV1MTI4IiwiRElWSVNPUiIsIl9yZW0iLCJxdW90aWVudCIsIm11bHRpcGx5NjR4MiIsImxlZnQiLCJyaWdodCIsImxlZnRIaWdoIiwibGVmdExvdyIsInJpZ2h0SGlnaCIsInJpZ2h0TG93IiwicHJvZHVjdEhpZ2giLCJwcm9kdWN0TWlkIiwicHJvZHVjdE1pZDIiLCJwcm9kdWN0TG93IiwidWhsZWZ0IiwidWhyaWdodCIsInVsbGVmdCIsInVscmlnaHQiLCJpbnZhbGlkRXJyIiwiRGVjaW1hbDEyOCIsIl9mcm9tU3RyaW5nIiwiYWxsb3dSb3VuZGluZyIsImZyb21TdHJpbmdXaXRoUm91bmRpbmciLCJzYXdTaWduIiwic2F3UmFkaXgiLCJmb3VuZE5vblplcm8iLCJzaWduaWZpY2FudERpZ2l0cyIsIm5EaWdpdHNSZWFkIiwibkRpZ2l0cyIsInJhZGl4UG9zaXRpb24iLCJmaXJzdE5vblplcm8iLCJuRGlnaXRzU3RvcmVkIiwiZGlnaXRzSW5zZXJ0IiwibGFzdERpZ2l0IiwiZXhwb25lbnQiLCJzaWduaWZpY2FuZEhpZ2giLCJzaWduaWZpY2FuZExvdyIsImJpYXNlZEV4cG9uZW50IiwiaW5kZXgiLCJzdHJpbmdNYXRjaCIsIm1hdGNoIiwiaW5mTWF0Y2giLCJuYW5NYXRjaCIsInVuc2lnbmVkTnVtYmVyIiwiZSIsImV4cFNpZ24iLCJleHBOdW1iZXIiLCJzdWJzdHIiLCJkaWdpdHNTdHJpbmciLCJlbmRPZlN0cmluZyIsInJvdW5kRGlnaXQiLCJyb3VuZEJpdCIsImRJZHgiLCJzaWduaWZpY2FuZCIsImRlYyIsImJpYXNlZF9leHBvbmVudCIsInNpZ25pZmljYW5kX2RpZ2l0cyIsImlzX3plcm8iLCJzaWduaWZpY2FuZF9tc2IiLCJzaWduaWZpY2FuZDEyOCIsImoiLCJtaWRsIiwibWlkaCIsImNvbWJpbmF0aW9uIiwibGVhc3RfZGlnaXRzIiwic2NpZW50aWZpY19leHBvbmVudCIsInJhZGl4X3Bvc2l0aW9uIiwiJG51bWJlckRlY2ltYWwiLCJkMTI4c3RyaW5nIiwiRG91YmxlIiwidmFsdWVPZiIsImlzRmluaXRlIiwiaXMiLCJzaWduIiwiJG51bWJlckRvdWJsZSIsImlzSW50ZWdlciIsInRvRml4ZWQiLCJkb3VibGVWYWx1ZSIsInBhcnNlRmxvYXQiLCJJbnQzMiIsIiRudW1iZXJJbnQiLCJNYXhLZXkiLCIkbWF4S2V5IiwiTWluS2V5IiwiJG1pbktleSIsImNoZWNrRm9ySGV4UmVnRXhwIiwiUmVnRXhwIiwiUFJPQ0VTU19VTklRVUUiLCJrSWQiLCJPYmplY3RJZCIsImlucHV0SWQiLCJ3b3JraW5nSWQiLCJjYWNoZUhleFN0cmluZyIsIl9faWQiLCJnZXRJbmMiLCJ0aW1lIiwiRGF0ZSIsIm5vdyIsImluYyIsInNldFVpbnQzMiIsInZhcmlhYmxlIiwidG9Mb3dlckNhc2UiLCJvdGhlcklkU3RyaW5nIiwidGhpc0lkU3RyaW5nIiwiZ2V0VGltZXN0YW1wIiwiZ2V0VWludDMyIiwic2V0VGltZSIsImNyZWF0ZVBrIiwiY3JlYXRlRnJvbVRpbWUiLCIkb2lkIiwiaW50ZXJuYWxDYWxjdWxhdGVPYmplY3RTaXplIiwic2VyaWFsaXplRnVuY3Rpb25zIiwiaWdub3JlVW5kZWZpbmVkIiwidG90YWxMZW5ndGgiLCJjYWxjdWxhdGVFbGVtZW50IiwidG9CU09OIiwia2V5IiwiYmluYXJ5Iiwib3JkZXJlZF92YWx1ZXMiLCJnbG9iYWwiLCJpZ25vcmVDYXNlIiwibXVsdGlsaW5lIiwicGF0dGVybiIsImFscGhhYmV0aXplIiwic29ydCIsIkJTT05SZWdFeHAiLCJwYXJzZU9wdGlvbnMiLCIkcmVnZXgiLCIkb3B0aW9ucyIsIiRyZWd1bGFyRXhwcmVzc2lvbiIsImZsYWdzIiwiQlNPTlN5bWJvbCIsIiRzeW1ib2wiLCJMb25nV2l0aG91dE92ZXJyaWRlc0NsYXNzIiwiVGltZXN0YW1wIiwidCIsIiR0aW1lc3RhbXAiLCJvcHRSYWRpeCIsIkpTX0lOVF9NQVhfTE9ORyIsIkpTX0lOVF9NSU5fTE9ORyIsImludGVybmFsRGVzZXJpYWxpemUiLCJhbGxvd09iamVjdFNtYWxsZXJUaGFuQnVmZmVyU2l6ZSIsImRlc2VyaWFsaXplT2JqZWN0IiwiYWxsb3dlZERCUmVmS2V5cyIsImZpZWxkc0FzUmF3IiwicmF3IiwiYnNvblJlZ0V4cCIsInByb21vdGVCdWZmZXJzIiwicHJvbW90ZUxvbmdzIiwicHJvbW90ZVZhbHVlcyIsInZhbGlkYXRpb24iLCJ1dGY4IiwiZ2xvYmFsVVRGVmFsaWRhdGlvbiIsInZhbGlkYXRpb25TZXR0aW5nIiwidXRmOEtleXNTZXQiLCJTZXQiLCJ1dGY4VmFsaWRhdGVkS2V5cyIsInV0ZjhWYWxpZGF0aW9uVmFsdWVzIiwibWFwIiwiZXZlcnkiLCJpdGVtIiwic3RhcnRJbmRleCIsImFycmF5SW5kZXgiLCJkb25lIiwiaXNQb3NzaWJsZURCUmVmIiwiZGF0YXZpZXciLCJlbGVtZW50VHlwZSIsInNob3VsZFZhbGlkYXRlS2V5IiwiaGFzIiwic3RyaW5nU2l6ZSIsImdldEZsb2F0NjQiLCJfaW5kZXgiLCJvYmplY3RTaXplIiwib2JqZWN0T3B0aW9ucyIsImFycmF5T3B0aW9ucyIsInN0b3BJbmRleCIsImdldEJpZ0ludDY0IiwiYmluYXJ5U2l6ZSIsInRvdGFsQmluYXJ5U2l6ZSIsIl9idWZmZXIiLCJyZWdFeHBPcHRpb25zIiwib3B0aW9uc0FycmF5IiwiZnVuY3Rpb25TdHJpbmciLCJ0b3RhbFNpemUiLCJzY29wZU9iamVjdCIsIm9pZEJ1ZmZlciIsImRlZmluZVByb3BlcnR5Iiwid3JpdGFibGUiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwicmVnZXhwIiwiaWdub3JlS2V5cyIsInNlcmlhbGl6ZVN0cmluZyIsIm51bWJlck9mV3JpdHRlbkJ5dGVzIiwiTlVNQkVSX1NQQUNFIiwiRk9VUl9CWVRFX1ZJRVdfT05fTlVNQkVSIiwiRUlHSFRfQllURV9WSUVXX09OX05VTUJFUiIsInNlcmlhbGl6ZU51bWJlciIsImlzTmVnYXRpdmVaZXJvIiwiaXNTYWZlSW50ZWdlciIsInNldEludDMyIiwic2V0RmxvYXQ2NCIsInNlcmlhbGl6ZUJpZ0ludCIsInNldEJpZ0ludDY0Iiwic2VyaWFsaXplTnVsbCIsIl8iLCJzZXJpYWxpemVCb29sZWFuIiwic2VyaWFsaXplRGF0ZSIsImRhdGVJbk1pbGlzIiwiZ2V0VGltZSIsInNlcmlhbGl6ZVJlZ0V4cCIsInNlcmlhbGl6ZUJTT05SZWdFeHAiLCJzb3J0ZWRPcHRpb25zIiwic2VyaWFsaXplTWluTWF4Iiwic2VyaWFsaXplT2JqZWN0SWQiLCJpZFZhbHVlIiwic2VyaWFsaXplQnVmZmVyIiwic2VyaWFsaXplT2JqZWN0IiwiY2hlY2tLZXlzIiwicGF0aCIsImVuZEluZGV4Iiwic2VyaWFsaXplSW50byIsImRlbGV0ZSIsInNlcmlhbGl6ZURlY2ltYWwxMjgiLCJzZXJpYWxpemVMb25nIiwic2VyaWFsaXplSW50MzIiLCJzZXJpYWxpemVEb3VibGUiLCJzZXJpYWxpemVGdW5jdGlvbiIsInNlcmlhbGl6ZUNvZGUiLCJjb2RlU2l6ZSIsInNlcmlhbGl6ZUJpbmFyeSIsInNlcmlhbGl6ZVN5bWJvbCIsInNlcmlhbGl6ZURCUmVmIiwib3V0cHV0Iiwic3RhcnRpbmdJbmRleCIsIk1hcCIsIml0ZXJhdG9yIiwiZW50cmllcyIsImVudHJ5IiwibmV4dCIsImlzQlNPTlR5cGUiLCJrZXlzVG9Db2RlY3MiLCJkZXNlcmlhbGl6ZVZhbHVlIiwiaW4zMkJpdFJhbmdlIiwiaW42NEJpdFJhbmdlIiwiJHVuZGVmaW5lZCIsImZpbHRlciIsInN0YXJ0c1dpdGgiLCIkZGF0ZSIsInBhcnNlIiwiJGRiUG9pbnRlciIsImRvbGxhcktleXMiLCJ2YWxpZCIsImZvckVhY2giLCJzZXJpYWxpemVBcnJheSIsInNlZW5PYmplY3RzIiwicHJvcGVydHlOYW1lIiwic2VyaWFsaXplVmFsdWUiLCJwb3AiLCJnZXRJU09TdHJpbmciLCJpc29TdHIiLCJ0b0lTT1N0cmluZyIsImdldFVUQ01pbGxpc2Vjb25kcyIsImNyZWF0ZSIsImZpbmRJbmRleCIsInByb3BzIiwibGVhZGluZ1BhcnQiLCJwcm9wIiwiYWxyZWFkeVNlZW4iLCJjaXJjdWxhclBhcnQiLCJjdXJyZW50IiwibGVhZGluZ1NwYWNlIiwicmVwZWF0IiwiZGFzaGVzIiwiZGF0ZU51bSIsImluUmFuZ2UiLCJyeCIsInNlcmlhbGl6ZURvY3VtZW50IiwiQlNPTl9UWVBFX01BUFBJTkdTIiwibG93XyIsImhpZ2hfIiwidW5zaWduZWRfIiwiYnNvbnR5cGUiLCJfZG9jIiwib3V0RG9jIiwibWFwcGVyIiwiZWpzb25PcHRpb25zIiwicmVwbGFjZXIiLCJzcGFjZSIsInNlcmlhbGl6ZU9wdGlvbnMiLCJFSlNPTnNlcmlhbGl6ZSIsIkVKU09OZGVzZXJpYWxpemUiLCJlanNvbiIsIkVKU09OIiwic2VyaWFsaXplIiwiZGVzZXJpYWxpemUiLCJNQVhTSVpFIiwic2V0SW50ZXJuYWxCdWZmZXJTaXplIiwibWluSW50ZXJuYWxCdWZmZXJTaXplIiwic2VyaWFsaXphdGlvbkluZGV4IiwiZmluaXNoZWRCdWZmZXIiLCJzZXJpYWxpemVXaXRoQnVmZmVyQW5kSW5kZXgiLCJmaW5hbEJ1ZmZlciIsImNhbGN1bGF0ZU9iamVjdFNpemUiLCJkZXNlcmlhbGl6ZVN0cmVhbSIsIm51bWJlck9mRG9jdW1lbnRzIiwiZG9jdW1lbnRzIiwiZG9jU3RhcnRJbmRleCIsImludGVybmFsT3B0aW9ucyIsImJ1ZmZlckRhdGEiLCJic29uIiwiX19wcm90b19fIiwiQlNPTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/bson/lib/bson.cjs\n");

/***/ })

};
;